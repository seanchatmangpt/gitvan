{
    "sourceFile": "src/jobs/runner.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1758048492165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758048967790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n \n import { createHash } from \"node:crypto\";\n import { useGit } from \"../composables/git.mjs\";\n import { createJobContext } from \"./define.mjs\";\n+import { createJobHooks } from \"./hooks.mjs\";\n \n /**\n  * Job execution result\n  */\n@@ -90,9 +91,9 @@\n     this.git = useGit();\n     this.receiptsRef = options.receiptsRef || \"refs/notes/gitvan/results\";\n     this.locksRef = options.locksRef || \"refs/gitvan/locks\";\n     this.executionsRef = options.executionsRef || \"refs/gitvan/executions\";\n-    this.hooks = options.hooks || {};\n+    this.hooks = options.hooks || createJobHooks();\n   }\n \n   /**\n    * Generate execution fingerprint\n@@ -137,8 +138,12 @@\n     } catch {\n       // Lock doesn't exist, create it\n       await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n       await this.git.noteAdd(lockRef, fingerprint, await this.git.head());\n+\n+      // Call lock acquire hook\n+      await this.hooks.callHook(\"lock:acquire\", { id: jobId, fingerprint });\n+\n       return fingerprint;\n     }\n   }\n \n@@ -149,8 +154,11 @@\n     const encodedJobId = this.encodeJobId(jobId);\n     const lockRef = `${this.locksRef}/${encodedJobId}`;\n     try {\n       await this.git.runVoid([\"update-ref\", \"-d\", lockRef]);\n+\n+      // Call lock release hook\n+      await this.hooks.callHook(\"lock:release\", { id: jobId });\n     } catch (error) {\n       // Lock might not exist, which is fine\n       if (!error.message.includes(\"doesn't exist\")) {\n         throw error;\n@@ -177,8 +185,15 @@\n     const receiptJson = JSON.stringify(receipt, null, 2);\n \n     try {\n       await this.git.noteAdd(this.receiptsRef, receiptJson, result.head);\n+\n+      // Call receipt write hook\n+      await this.hooks.callHook(\"receipt:write\", {\n+        id: result.id,\n+        note: receipt,\n+        ref: this.receiptsRef,\n+      });\n     } catch (error) {\n       // If note already exists, append to it\n       try {\n         await this.git.noteAppend(\n@@ -273,15 +288,13 @@\n \n     let result;\n     try {\n       // Call before hook\n-      if (this.hooks[\"job:before\"]) {\n-        await this.hooks[\"job:before\"]({\n-          id: jobDef.id,\n-          payload,\n-          ctx: await execContext.buildContext(),\n-        });\n-      }\n+      await this.hooks.callHook(\"job:before\", {\n+        id: jobDef.id,\n+        payload,\n+        ctx: await execContext.buildContext(),\n+      });\n \n       // Build execution context\n       const ctx = await execContext.buildContext();\n \n@@ -301,15 +314,13 @@\n         duration: finishedAt - startedAt,\n       });\n \n       // Call after hook\n-      if (this.hooks[\"job:after\"]) {\n-        await this.hooks[\"job:after\"]({\n-          id: jobDef.id,\n-          result,\n-          ctx,\n-        });\n-      }\n+      await this.hooks.callHook(\"job:after\", {\n+        id: jobDef.id,\n+        result,\n+        ctx,\n+      });\n     } catch (error) {\n       // Create error result\n       const finishedAt = new Date().toISOString();\n       result = new JobResult({\n@@ -323,15 +334,13 @@\n         duration: finishedAt - startedAt,\n       });\n \n       // Call error hook\n-      if (this.hooks[\"job:error\"]) {\n-        await this.hooks[\"job:error\"]({\n-          id: jobDef.id,\n-          error,\n-          ctx: await execContext.buildContext(),\n-        });\n-      }\n+      await this.hooks.callHook(\"job:error\", {\n+        id: jobDef.id,\n+        error,\n+        ctx: await execContext.buildContext(),\n+      });\n \n       throw error;\n     } finally {\n       // Always release lock and write receipt\n"
                },
                {
                    "date": 1758049154435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,418 @@\n+// src/jobs/runner.mjs\n+// GitVan v2 — Job Runner with Locking and Receipts\n+// Handles job execution, concurrency control, and audit trails\n+\n+import { createHash } from \"node:crypto\";\n+import { useGit } from \"../composables/git.mjs\";\n+import { createJobContext } from \"./define.mjs\";\n+import { createJobHooks } from \"./hooks.mjs\";\n+\n+/**\n+ * Job execution result\n+ */\n+export class JobResult {\n+  constructor(options = {}) {\n+    this.id = options.id;\n+    this.fingerprint = options.fingerprint;\n+    this.startedAt = options.startedAt;\n+    this.finishedAt = options.finishedAt;\n+    this.head = options.head;\n+    this.ok = options.ok;\n+    this.error = options.error;\n+    this.artifacts = options.artifacts || [];\n+    this.duration = options.duration;\n+  }\n+\n+  toJSON() {\n+    return {\n+      id: this.id,\n+      fingerprint: this.fingerprint,\n+      startedAt: this.startedAt,\n+      finishedAt: this.finishedAt,\n+      head: this.head,\n+      ok: this.ok,\n+      error: this.error?.message,\n+      artifacts: this.artifacts,\n+      duration: this.duration,\n+    };\n+  }\n+}\n+\n+/**\n+ * Job execution context\n+ */\n+export class JobExecutionContext {\n+  constructor(jobDef, options = {}) {\n+    this.jobDef = jobDef;\n+    this.git = useGit();\n+    this.root = options.root || process.cwd();\n+    this.nowISO = options.nowISO || new Date().toISOString();\n+    this.env = options.env || process.env;\n+    this.logger = options.logger || console;\n+    this.trigger = options.trigger;\n+    this.payload = options.payload || {};\n+  }\n+\n+  async buildContext() {\n+    const git = this.git;\n+\n+    return createJobContext(this.jobDef, {\n+      root: this.root,\n+      nowISO: this.nowISO,\n+      env: this.env,\n+      git: {\n+        head: await git.head(),\n+        branch: await git.getCurrentBranch(),\n+        isSigned: await this.isCommitSigned(),\n+      },\n+      trigger: this.trigger,\n+      logger: this.logger,\n+      payload: this.payload,\n+    });\n+  }\n+\n+  async isCommitSigned() {\n+    try {\n+      const git = this.git;\n+      const head = await git.head();\n+      const commitInfo = await git.run([\"show\", \"--show-signature\", head]);\n+      return commitInfo.includes(\"Good signature\");\n+    } catch {\n+      return false;\n+    }\n+  }\n+}\n+\n+/**\n+ * Job runner with locking and receipts\n+ */\n+export class JobRunner {\n+  constructor(options = {}) {\n+    this.git = useGit();\n+    this.receiptsRef = options.receiptsRef || \"refs/notes/gitvan/results\";\n+    this.locksRef = options.locksRef || \"refs/gitvan/locks\";\n+    this.executionsRef = options.executionsRef || \"refs/gitvan/executions\";\n+    this.hooks = options.hooks || createJobHooks();\n+  }\n+\n+  /**\n+   * Generate execution fingerprint\n+   */\n+  generateFingerprint(jobDef, head, payload, trigger) {\n+    const payloadHash = payload\n+      ? createHash(\"sha256\").update(JSON.stringify(payload)).digest(\"hex\")\n+      : \"\";\n+    const triggerKind = trigger?.kind || \"cli\";\n+    const data = `${jobDef.id}@${head}@${payloadHash}@${jobDef.version}@${triggerKind}`;\n+    return createHash(\"sha256\").update(data).digest(\"hex\");\n+  }\n+\n+  /**\n+   * Encode job ID for use in Git ref names\n+   */\n+  encodeJobId(jobId) {\n+    return jobId.replace(/:/g, \"-\").replace(/[^a-zA-Z0-9\\-_]/g, \"_\");\n+  }\n+\n+  /**\n+   * Acquire job lock\n+   */\n+  async acquireLock(jobId, fingerprint, force = false) {\n+    const encodedJobId = this.encodeJobId(jobId);\n+    const lockRef = `${this.locksRef}/${encodedJobId}`;\n+\n+    if (force) {\n+      // Force mode: create new lock with timestamp\n+      const timestamp = Date.now();\n+      const forceFingerprint = `${fingerprint}-force-${timestamp}`;\n+      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n+      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.head());\n+      return forceFingerprint;\n+    }\n+\n+    // Normal mode: try to acquire lock\n+    try {\n+      await this.git.runVoid([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n+      // Lock exists, return false\n+      return false;\n+    } catch {\n+      // Lock doesn't exist, create it\n+      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n+      await this.git.noteAdd(lockRef, fingerprint, await this.git.head());\n+\n+      // Call lock acquire hook\n+      await this.hooks.callHook(\"lock:acquire\", { id: jobId, fingerprint });\n+\n+      return fingerprint;\n+    }\n+  }\n+\n+  /**\n+   * Release job lock\n+   */\n+  async releaseLock(jobId) {\n+    const encodedJobId = this.encodeJobId(jobId);\n+    const lockRef = `${this.locksRef}/${encodedJobId}`;\n+    try {\n+      await this.git.runVoid([\"update-ref\", \"-d\", lockRef]);\n+\n+      // Call lock release hook\n+      await this.hooks.callHook(\"lock:release\", { id: jobId });\n+    } catch (error) {\n+      // Lock might not exist, which is fine\n+      if (!error.message.includes(\"doesn't exist\")) {\n+        throw error;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Write execution receipt\n+   */\n+  async writeReceipt(result) {\n+    const receipt = {\n+      id: result.id,\n+      fingerprint: result.fingerprint,\n+      startedAt: result.startedAt,\n+      finishedAt: result.finishedAt,\n+      head: result.head,\n+      ok: result.ok,\n+      error: result.error?.message,\n+      artifacts: result.artifacts,\n+      duration: result.duration,\n+    };\n+\n+    const receiptJson = JSON.stringify(receipt, null, 2);\n+\n+    try {\n+      await this.git.noteAdd(this.receiptsRef, receiptJson, result.head);\n+\n+      // Call receipt write hook\n+      await this.hooks.callHook(\"receipt:write\", {\n+        id: result.id,\n+        note: receipt,\n+        ref: this.receiptsRef,\n+      });\n+    } catch (error) {\n+      // If note already exists, append to it\n+      try {\n+        await this.git.noteAppend(\n+          this.receiptsRef,\n+          `\\n---\\n${receiptJson}`,\n+          result.head,\n+        );\n+      } catch (appendError) {\n+        this.git.logger?.warn(\n+          `Failed to write receipt: ${appendError.message}`,\n+        );\n+      }\n+    }\n+\n+    // Call receipt hook\n+    if (this.hooks[\"receipt:write\"]) {\n+      try {\n+        await this.hooks[\"receipt:write\"]({\n+          id: result.id,\n+          note: receipt,\n+          ref: this.receiptsRef,\n+        });\n+      } catch (error) {\n+        this.git.logger?.warn(`Receipt hook failed: ${error.message}`);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Record execution in git refs\n+   */\n+  async recordExecution(result) {\n+    const encodedJobId = this.encodeJobId(result.id);\n+    const executionRef = `${this.executionsRef}/${encodedJobId}/${result.fingerprint}`;\n+    const executionData = JSON.stringify(result.toJSON(), null, 2);\n+\n+    try {\n+      await this.git.runVoid([\n+        \"update-ref\",\n+        executionRef,\n+        await this.git.head(),\n+      ]);\n+      await this.git.noteAdd(\n+        executionRef,\n+        executionData,\n+        await this.git.head(),\n+      );\n+    } catch (error) {\n+      this.git.logger?.warn(`Failed to record execution: ${error.message}`);\n+    }\n+  }\n+\n+  /**\n+   * Run a job\n+   */\n+  async runJob(jobDef, options = {}) {\n+    const {\n+      payload = {},\n+      trigger = null,\n+      force = false,\n+      head = null,\n+    } = options;\n+\n+    const startTime = Date.now();\n+    const startedAt = new Date().toISOString();\n+    const currentHead = head || (await this.git.head());\n+\n+    // Generate fingerprint\n+    const fingerprint = this.generateFingerprint(\n+      jobDef,\n+      currentHead,\n+      payload,\n+      trigger,\n+    );\n+\n+    // Create execution context\n+    const execContext = new JobExecutionContext(jobDef, {\n+      root: this.git.cwd,\n+      nowISO: startedAt,\n+      env: this.git.env,\n+      logger: this.git.logger || console,\n+      trigger,\n+      payload,\n+    });\n+\n+    // Acquire lock\n+    const lockFingerprint = await this.acquireLock(\n+      jobDef.id,\n+      fingerprint,\n+      force,\n+    );\n+\n+    let result;\n+    try {\n+      // Call before hook\n+      await this.hooks.callHook(\"job:before\", {\n+        id: jobDef.id,\n+        payload,\n+        ctx: await execContext.buildContext(),\n+      });\n+\n+      // Build execution context\n+      const ctx = await execContext.buildContext();\n+\n+      // Execute job\n+      const jobResult = await jobDef.run({ payload, ctx });\n+\n+      // Create result\n+      const finishedAt = new Date().toISOString();\n+      result = new JobResult({\n+        id: jobDef.id,\n+        fingerprint: lockFingerprint,\n+        startedAt,\n+        finishedAt,\n+        head: currentHead,\n+        ok: true,\n+        artifacts: jobResult?.artifacts || [],\n+        duration: finishedAt - startedAt,\n+      });\n+\n+      // Call after hook\n+      await this.hooks.callHook(\"job:after\", {\n+        id: jobDef.id,\n+        result,\n+        ctx,\n+      });\n+    } catch (error) {\n+      // Create error result\n+      const finishedAt = new Date().toISOString();\n+      result = new JobResult({\n+        id: jobDef.id,\n+        fingerprint: lockFingerprint,\n+        startedAt,\n+        finishedAt,\n+        head: currentHead,\n+        ok: false,\n+        error,\n+        duration: finishedAt - startedAt,\n+      });\n+\n+      // Call error hook\n+      await this.hooks.callHook(\"job:error\", {\n+        id: jobDef.id,\n+        error,\n+        ctx: await execContext.buildContext(),\n+      });\n+\n+      throw error;\n+    } finally {\n+      // Always release lock and write receipt\n+      await this.releaseLock(jobDef.id);\n+      await this.writeReceipt(result);\n+      await this.recordExecution(result);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Check if job is currently running\n+   */\n+  async isJobRunning(jobId) {\n+    const encodedJobId = this.encodeJobId(jobId);\n+    const lockRef = `${this.locksRef}/${encodedJobId}`;\n+    try {\n+      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n+      return true;\n+    } catch {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Get job lock info\n+   */\n+  async getJobLockInfo(jobId) {\n+    const encodedJobId = this.encodeJobId(jobId);\n+    const lockRef = `${this.locksRef}/${encodedJobId}`;\n+    try {\n+      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n+      const fingerprint = await this.git.noteShow(lockRef);\n+      return { locked: true, fingerprint: fingerprint.trim() };\n+    } catch {\n+      return { locked: false };\n+    }\n+  }\n+\n+  /**\n+   * Clear job lock (force unlock)\n+   */\n+  async clearJobLock(jobId) {\n+    await this.releaseLock(jobId);\n+  }\n+\n+  /**\n+   * List all job locks\n+   */\n+  async listJobLocks() {\n+    try {\n+      const locks = await this.git.run([\n+        \"for-each-ref\",\n+        \"--format=%(refname)\",\n+        this.locksRef,\n+      ]);\n+      return locks\n+        .split(\"\\n\")\n+        .filter(Boolean)\n+        .map((ref) => {\n+          const parts = ref.split(\"/\");\n+          const encodedId = parts[parts.length - 1];\n+          // Decode job ID (reverse the encoding)\n+          const jobId = encodedId.replace(/-/g, \":\").replace(/_/g, \"-\");\n+          return {\n+            id: jobId,\n+            ref,\n+          };\n+        });\n+    } catch {\n+      return [];\n+    }\n+  }\n+}\n"
                },
                {
                    "date": 1758090282936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n // Handles job execution, concurrency control, and audit trails\n \n import { createHash } from \"node:crypto\";\n import { useGit } from \"../composables/git.mjs\";\n-import { createJobContext } from \"./define.mjs\";\n+import { defineJob } from \"./define.mjs\";\n import { createJobHooks } from \"./hooks.mjs\";\n \n /**\n  * Job execution result\n@@ -55,9 +55,9 @@\n \n   async buildContext() {\n     const git = this.git;\n \n-    return createJobContext(this.jobDef, {\n+    return {\n       root: this.root,\n       nowISO: this.nowISO,\n       env: this.env,\n       git: {\n@@ -67,429 +67,11 @@\n       },\n       trigger: this.trigger,\n       logger: this.logger,\n       payload: this.payload,\n-    });\n-  }\n-\n-  async isCommitSigned() {\n-    try {\n-      const git = this.git;\n-      const head = await git.head();\n-      const commitInfo = await git.run([\"show\", \"--show-signature\", head]);\n-      return commitInfo.includes(\"Good signature\");\n-    } catch {\n-      return false;\n-    }\n-  }\n-}\n-\n-/**\n- * Job runner with locking and receipts\n- */\n-export class JobRunner {\n-  constructor(options = {}) {\n-    this.git = useGit();\n-    this.receiptsRef = options.receiptsRef || \"refs/notes/gitvan/results\";\n-    this.locksRef = options.locksRef || \"refs/gitvan/locks\";\n-    this.executionsRef = options.executionsRef || \"refs/gitvan/executions\";\n-    this.hooks = options.hooks || createJobHooks();\n-  }\n-\n-  /**\n-   * Generate execution fingerprint\n-   */\n-  generateFingerprint(jobDef, head, payload, trigger) {\n-    const payloadHash = payload\n-      ? createHash(\"sha256\").update(JSON.stringify(payload)).digest(\"hex\")\n-      : \"\";\n-    const triggerKind = trigger?.kind || \"cli\";\n-    const data = `${jobDef.id}@${head}@${payloadHash}@${jobDef.version}@${triggerKind}`;\n-    return createHash(\"sha256\").update(data).digest(\"hex\");\n-  }\n-\n-  /**\n-   * Encode job ID for use in Git ref names\n-   */\n-  encodeJobId(jobId) {\n-    return jobId.replace(/:/g, \"-\").replace(/[^a-zA-Z0-9\\-_]/g, \"_\");\n-  }\n-\n-  /**\n-   * Acquire job lock\n-   */\n-  async acquireLock(jobId, fingerprint, force = false) {\n-    const encodedJobId = this.encodeJobId(jobId);\n-    const lockRef = `${this.locksRef}/${encodedJobId}`;\n-\n-    if (force) {\n-      // Force mode: create new lock with timestamp\n-      const timestamp = Date.now();\n-      const forceFingerprint = `${fingerprint}-force-${timestamp}`;\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n-      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.head());\n-      return forceFingerprint;\n-    }\n-\n-    // Normal mode: try to acquire lock\n-    try {\n-      await this.git.runVoid([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n-      // Lock exists, return false\n-      return false;\n-    } catch {\n-      // Lock doesn't exist, create it\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n-      await this.git.noteAdd(lockRef, fingerprint, await this.git.head());\n-\n-      // Call lock acquire hook\n-      await this.hooks.callHook(\"lock:acquire\", { id: jobId, fingerprint });\n-\n-      return fingerprint;\n-    }\n-  }\n-\n-  /**\n-   * Release job lock\n-   */\n-  async releaseLock(jobId) {\n-    const encodedJobId = this.encodeJobId(jobId);\n-    const lockRef = `${this.locksRef}/${encodedJobId}`;\n-    try {\n-      await this.git.runVoid([\"update-ref\", \"-d\", lockRef]);\n-\n-      // Call lock release hook\n-      await this.hooks.callHook(\"lock:release\", { id: jobId });\n-    } catch (error) {\n-      // Lock might not exist, which is fine\n-      if (!error.message.includes(\"doesn't exist\")) {\n-        throw error;\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Write execution receipt\n-   */\n-  async writeReceipt(result) {\n-    const receipt = {\n-      id: result.id,\n-      fingerprint: result.fingerprint,\n-      startedAt: result.startedAt,\n-      finishedAt: result.finishedAt,\n-      head: result.head,\n-      ok: result.ok,\n-      error: result.error?.message,\n-      artifacts: result.artifacts,\n-      duration: result.duration,\n     };\n-\n-    const receiptJson = JSON.stringify(receipt, null, 2);\n-\n-    try {\n-      await this.git.noteAdd(this.receiptsRef, receiptJson, result.head);\n-\n-      // Call receipt write hook\n-      await this.hooks.callHook(\"receipt:write\", {\n-        id: result.id,\n-        note: receipt,\n-        ref: this.receiptsRef,\n-      });\n-    } catch (error) {\n-      // If note already exists, append to it\n-      try {\n-        await this.git.noteAppend(\n-          this.receiptsRef,\n-          `\\n---\\n${receiptJson}`,\n-          result.head,\n-        );\n-      } catch (appendError) {\n-        this.git.logger?.warn(\n-          `Failed to write receipt: ${appendError.message}`,\n-        );\n-      }\n-    }\n-\n-    // Call receipt hook\n-    if (this.hooks[\"receipt:write\"]) {\n-      try {\n-        await this.hooks[\"receipt:write\"]({\n-          id: result.id,\n-          note: receipt,\n-          ref: this.receiptsRef,\n-        });\n-      } catch (error) {\n-        this.git.logger?.warn(`Receipt hook failed: ${error.message}`);\n-      }\n-    }\n   }\n \n-  /**\n-   * Record execution in git refs\n-   */\n-  async recordExecution(result) {\n-    const encodedJobId = this.encodeJobId(result.id);\n-    const executionRef = `${this.executionsRef}/${encodedJobId}/${result.fingerprint}`;\n-    const executionData = JSON.stringify(result.toJSON(), null, 2);\n-\n-    try {\n-      await this.git.runVoid([\n-        \"update-ref\",\n-        executionRef,\n-        await this.git.head(),\n-      ]);\n-      await this.git.noteAdd(\n-        executionRef,\n-        executionData,\n-        await this.git.head(),\n-      );\n-    } catch (error) {\n-      this.git.logger?.warn(`Failed to record execution: ${error.message}`);\n-    }\n-  }\n-\n-  /**\n-   * Run a job\n-   */\n-  async runJob(jobDef, options = {}) {\n-    const {\n-      payload = {},\n-      trigger = null,\n-      force = false,\n-      head = null,\n-    } = options;\n-\n-    const startTime = Date.now();\n-    const startedAt = new Date().toISOString();\n-    const currentHead = head || (await this.git.head());\n-\n-    // Generate fingerprint\n-    const fingerprint = this.generateFingerprint(\n-      jobDef,\n-      currentHead,\n-      payload,\n-      trigger,\n-    );\n-\n-    // Create execution context\n-    const execContext = new JobExecutionContext(jobDef, {\n-      root: this.git.cwd,\n-      nowISO: startedAt,\n-      env: this.git.env,\n-      logger: this.git.logger || console,\n-      trigger,\n-      payload,\n-    });\n-\n-    // Acquire lock\n-    const lockFingerprint = await this.acquireLock(\n-      jobDef.id,\n-      fingerprint,\n-      force,\n-    );\n-\n-    let result;\n-    try {\n-      // Call before hook\n-      await this.hooks.callHook(\"job:before\", {\n-        id: jobDef.id,\n-        payload,\n-        ctx: await execContext.buildContext(),\n-      });\n-\n-      // Build execution context\n-      const ctx = await execContext.buildContext();\n-\n-      // Execute job\n-      const jobResult = await jobDef.run({ payload, ctx });\n-\n-      // Create result\n-      const finishedAt = new Date().toISOString();\n-      result = new JobResult({\n-        id: jobDef.id,\n-        fingerprint: lockFingerprint,\n-        startedAt,\n-        finishedAt,\n-        head: currentHead,\n-        ok: true,\n-        artifacts: jobResult?.artifacts || [],\n-        duration: finishedAt - startedAt,\n-      });\n-\n-      // Call after hook\n-      await this.hooks.callHook(\"job:after\", {\n-        id: jobDef.id,\n-        result,\n-        ctx,\n-      });\n-    } catch (error) {\n-      // Create error result\n-      const finishedAt = new Date().toISOString();\n-      result = new JobResult({\n-        id: jobDef.id,\n-        fingerprint: lockFingerprint,\n-        startedAt,\n-        finishedAt,\n-        head: currentHead,\n-        ok: false,\n-        error,\n-        duration: finishedAt - startedAt,\n-      });\n-\n-      // Call error hook\n-      await this.hooks.callHook(\"job:error\", {\n-        id: jobDef.id,\n-        error,\n-        ctx: await execContext.buildContext(),\n-      });\n-\n-      throw error;\n-    } finally {\n-      // Always release lock and write receipt\n-      await this.releaseLock(jobDef.id);\n-      await this.writeReceipt(result);\n-      await this.recordExecution(result);\n-    }\n-\n-    return result;\n-  }\n-\n-  /**\n-   * Check if job is currently running\n-   */\n-  async isJobRunning(jobId) {\n-    const encodedJobId = this.encodeJobId(jobId);\n-    const lockRef = `${this.locksRef}/${encodedJobId}`;\n-    try {\n-      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n-      return true;\n-    } catch {\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * Get job lock info\n-   */\n-  async getJobLockInfo(jobId) {\n-    const encodedJobId = this.encodeJobId(jobId);\n-    const lockRef = `${this.locksRef}/${encodedJobId}`;\n-    try {\n-      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n-      const fingerprint = await this.git.noteShow(lockRef);\n-      return { locked: true, fingerprint: fingerprint.trim() };\n-    } catch {\n-      return { locked: false };\n-    }\n-  }\n-\n-  /**\n-   * Clear job lock (force unlock)\n-   */\n-  async clearJobLock(jobId) {\n-    await this.releaseLock(jobId);\n-  }\n-\n-  /**\n-   * List all job locks\n-   */\n-  async listJobLocks() {\n-    try {\n-      const locks = await this.git.run([\n-        \"for-each-ref\",\n-        \"--format=%(refname)\",\n-        this.locksRef,\n-      ]);\n-      return locks\n-        .split(\"\\n\")\n-        .filter(Boolean)\n-        .map((ref) => {\n-          const parts = ref.split(\"/\");\n-          const encodedId = parts[parts.length - 1];\n-          // Decode job ID (reverse the encoding)\n-          const jobId = encodedId.replace(/-/g, \":\").replace(/_/g, \"-\");\n-          return {\n-            id: jobId,\n-            ref,\n-          };\n-        });\n-    } catch {\n-      return [];\n-    }\n-  }\n-}\n-// src/jobs/runner.mjs\n-// GitVan v2 — Job Runner with Locking and Receipts\n-// Handles job execution, concurrency control, and audit trails\n-\n-import { createHash } from \"node:crypto\";\n-import { useGit } from \"../composables/git.mjs\";\n-import { createJobContext } from \"./define.mjs\";\n-import { createJobHooks } from \"./hooks.mjs\";\n-\n-/**\n- * Job execution result\n- */\n-export class JobResult {\n-  constructor(options = {}) {\n-    this.id = options.id;\n-    this.fingerprint = options.fingerprint;\n-    this.startedAt = options.startedAt;\n-    this.finishedAt = options.finishedAt;\n-    this.head = options.head;\n-    this.ok = options.ok;\n-    this.error = options.error;\n-    this.artifacts = options.artifacts || [];\n-    this.duration = options.duration;\n-  }\n-\n-  toJSON() {\n-    return {\n-      id: this.id,\n-      fingerprint: this.fingerprint,\n-      startedAt: this.startedAt,\n-      finishedAt: this.finishedAt,\n-      head: this.head,\n-      ok: this.ok,\n-      error: this.error?.message,\n-      artifacts: this.artifacts,\n-      duration: this.duration,\n-    };\n-  }\n-}\n-\n-/**\n- * Job execution context\n- */\n-export class JobExecutionContext {\n-  constructor(jobDef, options = {}) {\n-    this.jobDef = jobDef;\n-    this.git = useGit();\n-    this.root = options.root || process.cwd();\n-    this.nowISO = options.nowISO || new Date().toISOString();\n-    this.env = options.env || process.env;\n-    this.logger = options.logger || console;\n-    this.trigger = options.trigger;\n-    this.payload = options.payload || {};\n-  }\n-\n-  async buildContext() {\n-    const git = this.git;\n-\n-    return createJobContext(this.jobDef, {\n-      root: this.root,\n-      nowISO: this.nowISO,\n-      env: this.env,\n-      git: {\n-        head: await git.head(),\n-        branch: await git.getCurrentBranch(),\n-        isSigned: await this.isCommitSigned(),\n-      },\n-      trigger: this.trigger,\n-      logger: this.logger,\n-      payload: this.payload,\n-    });\n-  }\n-\n   async isCommitSigned() {\n     try {\n       const git = this.git;\n       const head = await git.head();\n"
                },
                {
                    "date": 1758096593599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n // GitVan v2 — Job Runner with Locking and Receipts\n // Handles job execution, concurrency control, and audit trails\n \n import { createHash } from \"node:crypto\";\n-import { useGit } from \"../composables/git.mjs\";\n+import { useGit } from \"../composables/git/index.mjs\";\n import { defineJob } from \"./define.mjs\";\n import { createJobHooks } from \"./hooks.mjs\";\n \n /**\n@@ -198,13 +198,13 @@\n       try {\n         await this.git.noteAppend(\n           this.receiptsRef,\n           `\\n---\\n${receiptJson}`,\n-          result.head,\n+          result.head\n         );\n       } catch (appendError) {\n         this.git.logger?.warn(\n-          `Failed to write receipt: ${appendError.message}`,\n+          `Failed to write receipt: ${appendError.message}`\n         );\n       }\n     }\n \n@@ -238,9 +238,9 @@\n       ]);\n       await this.git.noteAdd(\n         executionRef,\n         executionData,\n-        await this.git.head(),\n+        await this.git.head()\n       );\n     } catch (error) {\n       this.git.logger?.warn(`Failed to record execution: ${error.message}`);\n     }\n@@ -265,9 +265,9 @@\n     const fingerprint = this.generateFingerprint(\n       jobDef,\n       currentHead,\n       payload,\n-      trigger,\n+      trigger\n     );\n \n     // Create execution context\n     const execContext = new JobExecutionContext(jobDef, {\n@@ -282,9 +282,9 @@\n     // Acquire lock\n     const lockFingerprint = await this.acquireLock(\n       jobDef.id,\n       fingerprint,\n-      force,\n+      force\n     );\n \n     let result;\n     try {\n"
                },
                {
                    "date": 1758097155218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n       nowISO: this.nowISO,\n       env: this.env,\n       git: {\n         head: await git.head(),\n-        branch: await git.getCurrentBranch(),\n+        branch: await git.branch(),\n         isSigned: await this.isCommitSigned(),\n       },\n       trigger: this.trigger,\n       logger: this.logger,\n"
                },
                {
                    "date": 1758097484104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,10 +60,10 @@\n       root: this.root,\n       nowISO: this.nowISO,\n       env: this.env,\n       git: {\n-        head: await git.head(),\n-        branch: await git.branch(),\n+        head: await git.currentHead(),\n+        branch: await git.currentBranch(),\n         isSigned: await this.isCommitSigned(),\n       },\n       trigger: this.trigger,\n       logger: this.logger,\n@@ -73,9 +73,9 @@\n \n   async isCommitSigned() {\n     try {\n       const git = this.git;\n-      const head = await git.head();\n+      const head = await git.currentHead();\n       const commitInfo = await git.run([\"show\", \"--show-signature\", head]);\n       return commitInfo.includes(\"Good signature\");\n     } catch {\n       return false;\n@@ -124,10 +124,10 @@\n     if (force) {\n       // Force mode: create new lock with timestamp\n       const timestamp = Date.now();\n       const forceFingerprint = `${fingerprint}-force-${timestamp}`;\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n-      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.head());\n+      await this.git.runVoid([\"update-ref\", lockRef, await this.git.currentHead()]);\n+      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.currentHead());\n       return forceFingerprint;\n     }\n \n     // Normal mode: try to acquire lock\n@@ -136,10 +136,10 @@\n       // Lock exists, return false\n       return false;\n     } catch {\n       // Lock doesn't exist, create it\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n-      await this.git.noteAdd(lockRef, fingerprint, await this.git.head());\n+      await this.git.runVoid([\"update-ref\", lockRef, await this.git.currentHead()]);\n+      await this.git.noteAdd(lockRef, fingerprint, await this.git.currentHead());\n \n       // Call lock acquire hook\n       await this.hooks.callHook(\"lock:acquire\", { id: jobId, fingerprint });\n \n@@ -233,14 +233,14 @@\n     try {\n       await this.git.runVoid([\n         \"update-ref\",\n         executionRef,\n-        await this.git.head(),\n+        await this.git.currentHead(),\n       ]);\n       await this.git.noteAdd(\n         executionRef,\n         executionData,\n-        await this.git.head()\n+        await this.git.currentHead()\n       );\n     } catch (error) {\n       this.git.logger?.warn(`Failed to record execution: ${error.message}`);\n     }\n@@ -258,9 +258,9 @@\n     } = options;\n \n     const startTime = Date.now();\n     const startedAt = new Date().toISOString();\n-    const currentHead = head || (await this.git.head());\n+    const currentHead = head || (await this.git.currentHead());\n \n     // Generate fingerprint\n     const fingerprint = this.generateFingerprint(\n       jobDef,\n"
                },
                {
                    "date": 1758130991168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,10 +124,18 @@\n     if (force) {\n       // Force mode: create new lock with timestamp\n       const timestamp = Date.now();\n       const forceFingerprint = `${fingerprint}-force-${timestamp}`;\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.currentHead()]);\n-      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.currentHead());\n+      await this.git.runVoid([\n+        \"update-ref\",\n+        lockRef,\n+        await this.git.currentHead(),\n+      ]);\n+      await this.git.noteAdd(\n+        lockRef,\n+        forceFingerprint,\n+        await this.git.currentHead()\n+      );\n       return forceFingerprint;\n     }\n \n     // Normal mode: try to acquire lock\n@@ -136,10 +144,18 @@\n       // Lock exists, return false\n       return false;\n     } catch {\n       // Lock doesn't exist, create it\n-      await this.git.runVoid([\"update-ref\", lockRef, await this.git.currentHead()]);\n-      await this.git.noteAdd(lockRef, fingerprint, await this.git.currentHead());\n+      await this.git.runVoid([\n+        \"update-ref\",\n+        lockRef,\n+        await this.git.currentHead(),\n+      ]);\n+      await this.git.noteAdd(\n+        lockRef,\n+        fingerprint,\n+        await this.git.currentHead()\n+      );\n \n       // Call lock acquire hook\n       await this.hooks.callHook(\"lock:acquire\", { id: jobId, fingerprint });\n \n"
                }
            ],
            "date": 1758048492165,
            "name": "Commit-0",
            "content": "// src/jobs/runner.mjs\n// GitVan v2 — Job Runner with Locking and Receipts\n// Handles job execution, concurrency control, and audit trails\n\nimport { createHash } from \"node:crypto\";\nimport { useGit } from \"../composables/git.mjs\";\nimport { createJobContext } from \"./define.mjs\";\n\n/**\n * Job execution result\n */\nexport class JobResult {\n  constructor(options = {}) {\n    this.id = options.id;\n    this.fingerprint = options.fingerprint;\n    this.startedAt = options.startedAt;\n    this.finishedAt = options.finishedAt;\n    this.head = options.head;\n    this.ok = options.ok;\n    this.error = options.error;\n    this.artifacts = options.artifacts || [];\n    this.duration = options.duration;\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      fingerprint: this.fingerprint,\n      startedAt: this.startedAt,\n      finishedAt: this.finishedAt,\n      head: this.head,\n      ok: this.ok,\n      error: this.error?.message,\n      artifacts: this.artifacts,\n      duration: this.duration,\n    };\n  }\n}\n\n/**\n * Job execution context\n */\nexport class JobExecutionContext {\n  constructor(jobDef, options = {}) {\n    this.jobDef = jobDef;\n    this.git = useGit();\n    this.root = options.root || process.cwd();\n    this.nowISO = options.nowISO || new Date().toISOString();\n    this.env = options.env || process.env;\n    this.logger = options.logger || console;\n    this.trigger = options.trigger;\n    this.payload = options.payload || {};\n  }\n\n  async buildContext() {\n    const git = this.git;\n\n    return createJobContext(this.jobDef, {\n      root: this.root,\n      nowISO: this.nowISO,\n      env: this.env,\n      git: {\n        head: await git.head(),\n        branch: await git.getCurrentBranch(),\n        isSigned: await this.isCommitSigned(),\n      },\n      trigger: this.trigger,\n      logger: this.logger,\n      payload: this.payload,\n    });\n  }\n\n  async isCommitSigned() {\n    try {\n      const git = this.git;\n      const head = await git.head();\n      const commitInfo = await git.run([\"show\", \"--show-signature\", head]);\n      return commitInfo.includes(\"Good signature\");\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Job runner with locking and receipts\n */\nexport class JobRunner {\n  constructor(options = {}) {\n    this.git = useGit();\n    this.receiptsRef = options.receiptsRef || \"refs/notes/gitvan/results\";\n    this.locksRef = options.locksRef || \"refs/gitvan/locks\";\n    this.executionsRef = options.executionsRef || \"refs/gitvan/executions\";\n    this.hooks = options.hooks || {};\n  }\n\n  /**\n   * Generate execution fingerprint\n   */\n  generateFingerprint(jobDef, head, payload, trigger) {\n    const payloadHash = payload\n      ? createHash(\"sha256\").update(JSON.stringify(payload)).digest(\"hex\")\n      : \"\";\n    const triggerKind = trigger?.kind || \"cli\";\n    const data = `${jobDef.id}@${head}@${payloadHash}@${jobDef.version}@${triggerKind}`;\n    return createHash(\"sha256\").update(data).digest(\"hex\");\n  }\n\n  /**\n   * Encode job ID for use in Git ref names\n   */\n  encodeJobId(jobId) {\n    return jobId.replace(/:/g, \"-\").replace(/[^a-zA-Z0-9\\-_]/g, \"_\");\n  }\n\n  /**\n   * Acquire job lock\n   */\n  async acquireLock(jobId, fingerprint, force = false) {\n    const encodedJobId = this.encodeJobId(jobId);\n    const lockRef = `${this.locksRef}/${encodedJobId}`;\n\n    if (force) {\n      // Force mode: create new lock with timestamp\n      const timestamp = Date.now();\n      const forceFingerprint = `${fingerprint}-force-${timestamp}`;\n      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n      await this.git.noteAdd(lockRef, forceFingerprint, await this.git.head());\n      return forceFingerprint;\n    }\n\n    // Normal mode: try to acquire lock\n    try {\n      await this.git.runVoid([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n      // Lock exists, return false\n      return false;\n    } catch {\n      // Lock doesn't exist, create it\n      await this.git.runVoid([\"update-ref\", lockRef, await this.git.head()]);\n      await this.git.noteAdd(lockRef, fingerprint, await this.git.head());\n      return fingerprint;\n    }\n  }\n\n  /**\n   * Release job lock\n   */\n  async releaseLock(jobId) {\n    const encodedJobId = this.encodeJobId(jobId);\n    const lockRef = `${this.locksRef}/${encodedJobId}`;\n    try {\n      await this.git.runVoid([\"update-ref\", \"-d\", lockRef]);\n    } catch (error) {\n      // Lock might not exist, which is fine\n      if (!error.message.includes(\"doesn't exist\")) {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Write execution receipt\n   */\n  async writeReceipt(result) {\n    const receipt = {\n      id: result.id,\n      fingerprint: result.fingerprint,\n      startedAt: result.startedAt,\n      finishedAt: result.finishedAt,\n      head: result.head,\n      ok: result.ok,\n      error: result.error?.message,\n      artifacts: result.artifacts,\n      duration: result.duration,\n    };\n\n    const receiptJson = JSON.stringify(receipt, null, 2);\n\n    try {\n      await this.git.noteAdd(this.receiptsRef, receiptJson, result.head);\n    } catch (error) {\n      // If note already exists, append to it\n      try {\n        await this.git.noteAppend(\n          this.receiptsRef,\n          `\\n---\\n${receiptJson}`,\n          result.head,\n        );\n      } catch (appendError) {\n        this.git.logger?.warn(\n          `Failed to write receipt: ${appendError.message}`,\n        );\n      }\n    }\n\n    // Call receipt hook\n    if (this.hooks[\"receipt:write\"]) {\n      try {\n        await this.hooks[\"receipt:write\"]({\n          id: result.id,\n          note: receipt,\n          ref: this.receiptsRef,\n        });\n      } catch (error) {\n        this.git.logger?.warn(`Receipt hook failed: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Record execution in git refs\n   */\n  async recordExecution(result) {\n    const encodedJobId = this.encodeJobId(result.id);\n    const executionRef = `${this.executionsRef}/${encodedJobId}/${result.fingerprint}`;\n    const executionData = JSON.stringify(result.toJSON(), null, 2);\n\n    try {\n      await this.git.runVoid([\n        \"update-ref\",\n        executionRef,\n        await this.git.head(),\n      ]);\n      await this.git.noteAdd(\n        executionRef,\n        executionData,\n        await this.git.head(),\n      );\n    } catch (error) {\n      this.git.logger?.warn(`Failed to record execution: ${error.message}`);\n    }\n  }\n\n  /**\n   * Run a job\n   */\n  async runJob(jobDef, options = {}) {\n    const {\n      payload = {},\n      trigger = null,\n      force = false,\n      head = null,\n    } = options;\n\n    const startTime = Date.now();\n    const startedAt = new Date().toISOString();\n    const currentHead = head || (await this.git.head());\n\n    // Generate fingerprint\n    const fingerprint = this.generateFingerprint(\n      jobDef,\n      currentHead,\n      payload,\n      trigger,\n    );\n\n    // Create execution context\n    const execContext = new JobExecutionContext(jobDef, {\n      root: this.git.cwd,\n      nowISO: startedAt,\n      env: this.git.env,\n      logger: this.git.logger || console,\n      trigger,\n      payload,\n    });\n\n    // Acquire lock\n    const lockFingerprint = await this.acquireLock(\n      jobDef.id,\n      fingerprint,\n      force,\n    );\n\n    let result;\n    try {\n      // Call before hook\n      if (this.hooks[\"job:before\"]) {\n        await this.hooks[\"job:before\"]({\n          id: jobDef.id,\n          payload,\n          ctx: await execContext.buildContext(),\n        });\n      }\n\n      // Build execution context\n      const ctx = await execContext.buildContext();\n\n      // Execute job\n      const jobResult = await jobDef.run({ payload, ctx });\n\n      // Create result\n      const finishedAt = new Date().toISOString();\n      result = new JobResult({\n        id: jobDef.id,\n        fingerprint: lockFingerprint,\n        startedAt,\n        finishedAt,\n        head: currentHead,\n        ok: true,\n        artifacts: jobResult?.artifacts || [],\n        duration: finishedAt - startedAt,\n      });\n\n      // Call after hook\n      if (this.hooks[\"job:after\"]) {\n        await this.hooks[\"job:after\"]({\n          id: jobDef.id,\n          result,\n          ctx,\n        });\n      }\n    } catch (error) {\n      // Create error result\n      const finishedAt = new Date().toISOString();\n      result = new JobResult({\n        id: jobDef.id,\n        fingerprint: lockFingerprint,\n        startedAt,\n        finishedAt,\n        head: currentHead,\n        ok: false,\n        error,\n        duration: finishedAt - startedAt,\n      });\n\n      // Call error hook\n      if (this.hooks[\"job:error\"]) {\n        await this.hooks[\"job:error\"]({\n          id: jobDef.id,\n          error,\n          ctx: await execContext.buildContext(),\n        });\n      }\n\n      throw error;\n    } finally {\n      // Always release lock and write receipt\n      await this.releaseLock(jobDef.id);\n      await this.writeReceipt(result);\n      await this.recordExecution(result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if job is currently running\n   */\n  async isJobRunning(jobId) {\n    const encodedJobId = this.encodeJobId(jobId);\n    const lockRef = `${this.locksRef}/${encodedJobId}`;\n    try {\n      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get job lock info\n   */\n  async getJobLockInfo(jobId) {\n    const encodedJobId = this.encodeJobId(jobId);\n    const lockRef = `${this.locksRef}/${encodedJobId}`;\n    try {\n      await this.git.run([\"show-ref\", \"--verify\", \"--quiet\", lockRef]);\n      const fingerprint = await this.git.noteShow(lockRef);\n      return { locked: true, fingerprint: fingerprint.trim() };\n    } catch {\n      return { locked: false };\n    }\n  }\n\n  /**\n   * Clear job lock (force unlock)\n   */\n  async clearJobLock(jobId) {\n    await this.releaseLock(jobId);\n  }\n\n  /**\n   * List all job locks\n   */\n  async listJobLocks() {\n    try {\n      const locks = await this.git.run([\n        \"for-each-ref\",\n        \"--format=%(refname)\",\n        this.locksRef,\n      ]);\n      return locks\n        .split(\"\\n\")\n        .filter(Boolean)\n        .map((ref) => {\n          const parts = ref.split(\"/\");\n          const encodedId = parts[parts.length - 1];\n          // Decode job ID (reverse the encoding)\n          const jobId = encodedId.replace(/-/g, \":\").replace(/_/g, \"-\");\n          return {\n            id: jobId,\n            ref,\n          };\n        });\n    } catch {\n      return [];\n    }\n  }\n}\n"
        }
    ]
}