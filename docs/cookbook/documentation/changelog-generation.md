# Changelog Generation

## üéØ **Recipe Overview**

**Category**: Documentation  
**Difficulty**: Beginner  
**Time**: 20 minutes  
**Prerequisites**: Basic GitVan knowledge, Git repository

## üìã **Problem**

You need to automatically generate changelogs from your Git repository history. You want a flexible system that can create different formats and include various commit information.

## üç≥ **Solution**

### **Step 1: Create Basic Changelog Job**

```javascript
// jobs/docs/changelog.mjs
import { defineJob } from "gitvan/define";
import { useGit } from "gitvan/useGit";
import { useTemplate } from "gitvan/useTemplate";

export default defineJob({
  meta: {
    desc: "Generate changelog from git commit history",
    tags: ["documentation", "changelog", "git"]
  },
  async run({ ctx, payload }) {
    const git = useGit();
    const template = await useTemplate();
    
    // Get commit limit from payload or default
    const limit = payload?.limit || 50;
    
    // Get recent commits
    const logOutput = await git.log("%h%x09%s%x09%an%x09%ad", ["-n", limit.toString()]);
    const lines = logOutput.split("\n").filter(Boolean);
    
    // Parse commits
    const commits = lines.map((line) => {
      const [hash, subject, author, date] = line.split("\t");
      return {
        hash,
        subject,
        author,
        date: new Date(date).toISOString(),
        shortHash: hash.substring(0, 7)
      };
    });
    
    // Group commits by type (conventional commits)
    const groupedCommits = {
      features: [],
      fixes: [],
      breaking: [],
      other: []
    };
    
    commits.forEach(commit => {
      const subject = commit.subject.toLowerCase();
      if (subject.startsWith('feat:')) {
        groupedCommits.features.push(commit);
      } else if (subject.startsWith('fix:')) {
        groupedCommits.fixes.push(commit);
      } else if (subject.includes('breaking change') || subject.includes('!:')) {
        groupedCommits.breaking.push(commit);
      } else {
        groupedCommits.other.push(commit);
      }
    });
    
    // Prepare template data
    const data = {
      title: "Changelog",
      subtitle: `Generated from ${commits.length} recent commits`,
      commits,
      groupedCommits,
      generatedAt: ctx.nowISO,
      totalCommits: commits.length,
      repository: {
        head: await git.currentHead(),
        branch: await git.currentBranch()
      }
    };
    
    // Render template to file
    const outputPath = await template.renderToFile(
      "changelog.njk",
      "dist/CHANGELOG.md",
      data
    );
    
    ctx.logger.log(`üìù Changelog generated: ${outputPath}`);
    ctx.logger.log(`üìä Processed ${commits.length} commits`);
    
    return {
      ok: true,
      artifacts: [outputPath],
      data: {
        outputPath,
        totalCommits: commits.length,
        groupedCommits: Object.keys(groupedCommits).reduce((acc, key) => {
          acc[key] = groupedCommits[key].length;
          return acc;
        }, {})
      }
    };
  }
});
```

### **Step 2: Create Changelog Template**

```njk
<!-- templates/changelog.njk -->
# {{ title }}

{{ subtitle }}

Generated at: {{ generatedAt }}
Total commits: {{ totalCommits }}

## Recent Changes

{% if groupedCommits.breaking.length > 0 %}
### üö® Breaking Changes
{% for commit in groupedCommits.breaking %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.features.length > 0 %}
### ‚ú® New Features
{% for commit in groupedCommits.features %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.fixes.length > 0 %}
### üêõ Bug Fixes
{% for commit in groupedCommits.fixes %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.other.length > 0 %}
### üìù Other Changes
{% for commit in groupedCommits.other %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

## All Commits

{% for commit in commits %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}

---
*Generated by GitVan Jobs System*
```

### **Step 3: Create Advanced Changelog Job**

```javascript
// jobs/docs/advanced-changelog.mjs
import { defineJob } from "gitvan/define";
import { useGit } from "gitvan/useGit";
import { useTemplate } from "gitvan/useTemplate";

export default defineJob({
  meta: {
    desc: "Generate advanced changelog with release notes and statistics",
    tags: ["documentation", "changelog", "advanced", "releases"]
  },
  async run({ ctx, payload }) {
    const git = useGit();
    const template = await useTemplate();
    
    // Get configuration
    const since = payload?.since || "1 month ago";
    const limit = payload?.limit || 100;
    const includeStats = payload?.includeStats !== false;
    
    // Get commits since specified date
    const logOutput = await git.log(
      "%h%x09%s%x09%an%x09%ae%x09%ad%x09%at",
      ["--since", since, "-n", limit.toString()]
    );
    
    const lines = logOutput.split("\n").filter(Boolean);
    const commits = lines.map((line) => {
      const [hash, subject, author, email, date, timestamp] = line.split("\t");
      return {
        hash,
        subject,
        author,
        email,
        date: new Date(date).toISOString(),
        timestamp: parseInt(timestamp),
        shortHash: hash.substring(0, 7)
      };
    });
    
    // Analyze commits
    const analysis = {
      totalCommits: commits.length,
      uniqueAuthors: [...new Set(commits.map(c => c.author))].length,
      dateRange: {
        first: commits[commits.length - 1]?.date,
        last: commits[0]?.date
      },
      commitTypes: {},
      authorStats: {},
      weeklyStats: {}
    };
    
    // Analyze commit types
    commits.forEach(commit => {
      const type = commit.subject.split(':')[0].toLowerCase();
      analysis.commitTypes[type] = (analysis.commitTypes[type] || 0) + 1;
      
      // Author statistics
      analysis.authorStats[commit.author] = (analysis.authorStats[commit.author] || 0) + 1;
      
      // Weekly statistics
      const week = new Date(commit.timestamp * 1000);
      const weekKey = `${week.getFullYear()}-W${Math.ceil(week.getDate() / 7)}`;
      analysis.weeklyStats[weekKey] = (analysis.weeklyStats[weekKey] || 0) + 1;
    });
    
    // Group commits by type
    const groupedCommits = {
      features: [],
      fixes: [],
      docs: [],
      style: [],
      refactor: [],
      test: [],
      chore: [],
      breaking: [],
      other: []
    };
    
    commits.forEach(commit => {
      const subject = commit.subject.toLowerCase();
      const type = subject.split(':')[0];
      
      if (subject.includes('breaking change') || subject.includes('!:')) {
        groupedCommits.breaking.push(commit);
      } else if (type === 'feat') {
        groupedCommits.features.push(commit);
      } else if (type === 'fix') {
        groupedCommits.fixes.push(commit);
      } else if (type === 'docs') {
        groupedCommits.docs.push(commit);
      } else if (type === 'style') {
        groupedCommits.style.push(commit);
      } else if (type === 'refactor') {
        groupedCommits.refactor.push(commit);
      } else if (type === 'test') {
        groupedCommits.test.push(commit);
      } else if (type === 'chore') {
        groupedCommits.chore.push(commit);
      } else {
        groupedCommits.other.push(commit);
      }
    });
    
    // Get repository information
    const repository = {
      head: await git.currentHead(),
      branch: await git.currentBranch(),
      isClean: await git.isClean()
    };
    
    // Prepare template data
    const data = {
      title: "Advanced Changelog",
      subtitle: `Generated from ${commits.length} commits since ${since}`,
      commits,
      groupedCommits,
      analysis: includeStats ? analysis : null,
      generatedAt: ctx.nowISO,
      repository,
      config: {
        since,
        limit,
        includeStats
      }
    };
    
    // Render template to file
    const outputPath = await template.renderToFile(
      "advanced-changelog.njk",
      "dist/ADVANCED_CHANGELOG.md",
      data
    );
    
    ctx.logger.log(`üìù Advanced changelog generated: ${outputPath}`);
    ctx.logger.log(`üìä Processed ${commits.length} commits from ${analysis.uniqueAuthors} authors`);
    
    return {
      ok: true,
      artifacts: [outputPath],
      data: {
        outputPath,
        analysis,
        groupedCommits: Object.keys(groupedCommits).reduce((acc, key) => {
          acc[key] = groupedCommits[key].length;
          return acc;
        }, {})
      }
    };
  }
});
```

### **Step 4: Create Advanced Changelog Template**

```njk
<!-- templates/advanced-changelog.njk -->
# {{ title }}

{{ subtitle }}

Generated at: {{ generatedAt }}
Repository: {{ repository.branch }} ({{ repository.head.substring(0, 8) }})

{% if analysis %}
## üìä Statistics

- **Total Commits**: {{ analysis.totalCommits }}
- **Unique Authors**: {{ analysis.uniqueAuthors }}
- **Date Range**: {{ analysis.dateRange.first | date("MMM DD, YYYY") }} - {{ analysis.dateRange.last | date("MMM DD, YYYY") }}

### Commit Types
{% for type, count in analysis.commitTypes %}
- **{{ type | titleize }}**: {{ count }}
{% endfor %}

### Top Contributors
{% for author, count in analysis.authorStats | dictsort(true, 'value') | slice(0, 5) %}
- **{{ author }}**: {{ count }} commits
{% endfor %}

### Weekly Activity
{% for week, count in analysis.weeklyStats | dictsort(true, 'value') | slice(0, 8) %}
- **{{ week }}**: {{ count }} commits
{% endfor %}
{% endif %}

## üìù Changes by Category

{% if groupedCommits.breaking.length > 0 %}
### üö® Breaking Changes
{% for commit in groupedCommits.breaking %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.features.length > 0 %}
### ‚ú® New Features
{% for commit in groupedCommits.features %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.fixes.length > 0 %}
### üêõ Bug Fixes
{% for commit in groupedCommits.fixes %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.docs.length > 0 %}
### üìö Documentation
{% for commit in groupedCommits.docs %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.refactor.length > 0 %}
### üîß Refactoring
{% for commit in groupedCommits.refactor %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.test.length > 0 %}
### üß™ Tests
{% for commit in groupedCommits.test %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.chore.length > 0 %}
### üî® Chores
{% for commit in groupedCommits.chore %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

{% if groupedCommits.other.length > 0 %}
### üìù Other Changes
{% for commit in groupedCommits.other %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}
{% endif %}

## üìã All Commits

{% for commit in commits %}
- **{{ commit.shortHash }}** {{ commit.subject }}
  - *{{ commit.author }} - {{ commit.date | date("MMM DD, YYYY") }}*
{% endfor %}

---
*Generated by GitVan Jobs System*
```

## üîç **Explanation**

### **Commit Parsing**

1. **Git Log Format**: Uses custom format string to extract commit data
2. **Commit Types**: Categorizes commits based on conventional commit format
3. **Author Analysis**: Tracks commit statistics per author
4. **Date Filtering**: Filters commits by date range

### **Template Features**

1. **Grouped Display**: Shows commits organized by type
2. **Statistics**: Includes commit statistics and analysis
3. **Flexible Formatting**: Supports different output formats
4. **Metadata**: Includes generation timestamp and repository info

### **Conventional Commits**

- **`feat:`**: New features
- **`fix:`**: Bug fixes
- **`docs:`**: Documentation changes
- **`style:`**: Code style changes
- **`refactor:`**: Code refactoring
- **`test:`**: Test changes
- **`chore:`**: Maintenance tasks

## üîÑ **Variations**

### **Variation 1: Release-Based Changelog**

```javascript
// jobs/docs/release-changelog.mjs
import { defineJob } from "gitvan/define";
import { useGit } from "gitvan/useGit";
import { useTemplate } from "gitvan/useTemplate";

export default defineJob({
  meta: {
    desc: "Generate changelog for a specific release",
    tags: ["documentation", "changelog", "release"]
  },
  async run({ ctx, payload }) {
    const git = useGit();
    const template = await useTemplate();
    
    const fromTag = payload?.fromTag || "HEAD~10";
    const toTag = payload?.toTag || "HEAD";
    
    // Get commits between tags
    const logOutput = await git.log(
      "%h%x09%s%x09%an%x09%ad",
      [`${fromTag}..${toTag}`]
    );
    
    // Process commits and generate changelog
    // ... (similar to basic changelog)
    
    return {
      ok: true,
      artifacts: [outputPath],
      data: { fromTag, toTag, commitCount: commits.length }
    };
  }
});
```

### **Variation 2: Multi-Format Changelog**

```javascript
// jobs/docs/multi-format-changelog.mjs
import { defineJob } from "gitvan/define";
import { useGit } from "gitvan/useGit";
import { useTemplate } from "gitvan/useTemplate";

export default defineJob({
  meta: {
    desc: "Generate changelog in multiple formats",
    tags: ["documentation", "changelog", "multi-format"]
  },
  async run({ ctx, payload }) {
    const git = useGit();
    const template = await useTemplate();
    
    // Get commits (same as basic changelog)
    const commits = await getCommits(git, payload);
    
    const formats = payload?.formats || ['markdown', 'html', 'json'];
    const artifacts = [];
    
    // Generate Markdown
    if (formats.includes('markdown')) {
      const mdPath = await template.renderToFile(
        "changelog.njk",
        "dist/CHANGELOG.md",
        { commits, format: 'markdown' }
      );
      artifacts.push(mdPath);
    }
    
    // Generate HTML
    if (formats.includes('html')) {
      const htmlPath = await template.renderToFile(
        "changelog-html.njk",
        "dist/CHANGELOG.html",
        { commits, format: 'html' }
      );
      artifacts.push(htmlPath);
    }
    
    // Generate JSON
    if (formats.includes('json')) {
      const jsonPath = join(ctx.root, "dist", "CHANGELOG.json");
      await fs.writeFile(jsonPath, JSON.stringify({ commits }, null, 2));
      artifacts.push(jsonPath);
    }
    
    return {
      ok: true,
      artifacts,
      data: { formats, artifactCount: artifacts.length }
    };
  }
});
```

## üéØ **Best Practices**

### **Commit Messages**
- **Conventional Commits**: Use conventional commit format
- **Clear Descriptions**: Write clear, descriptive commit messages
- **Breaking Changes**: Mark breaking changes appropriately
- **Consistent Format**: Maintain consistent commit message format

### **Changelog Generation**
- **Regular Updates**: Generate changelogs regularly
- **Automated Process**: Integrate with CI/CD pipeline
- **Version Control**: Keep generated changelogs in version control
- **Review Process**: Review generated changelogs before release

### **Template Design**
- **Consistent Format**: Use consistent formatting across templates
- **Flexible Structure**: Design templates to handle various commit types
- **Metadata Inclusion**: Include relevant metadata in changelogs
- **Readable Format**: Ensure changelogs are easy to read and understand

## üîó **Related Recipes**

- [Release Notes](./release-notes.md) - Generate release notes
- [API Documentation](./api-documentation.md) - Generate API documentation
- [README Updates](./readme-updates.md) - Keep README files current

## üìö **Resources**

- [Conventional Commits](https://www.conventionalcommits.org/)
- [GitVan Template Guide](../../docs/templates.md)
- [Changelog Best Practices](../../docs/changelog-best-practices.md)

## ü§ù **Contributors**

- **Author**: GitVan Team
- **Last Updated**: 2024-09-16
- **Version**: 1.0.0

---

**Next Recipe**: [API Documentation](./api-documentation.md)
