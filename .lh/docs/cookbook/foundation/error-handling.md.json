{
    "sourceFile": "docs/cookbook/foundation/error-handling.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758051806647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758051806647,
            "name": "Commit-0",
            "content": "# Error Handling\n\n## 🎯 **Recipe Overview**\n\n**Category**: Foundation  \n**Difficulty**: Intermediate  \n**Time**: 40 minutes  \n**Prerequisites**: Basic GitVan knowledge, error handling experience\n\n## 📋 **Problem**\n\nYou need to implement robust error handling in your GitVan jobs to ensure graceful failures, proper logging, and recovery mechanisms. You want to handle various types of errors including git operations, file system issues, and external service failures.\n\n## 🍳 **Solution**\n\n### **Step 1: Create Error Handling Utilities**\n\n```javascript\n// utils/error-handler.mjs\nexport class GitVanError extends Error {\n  constructor(message, code, context = {}) {\n    super(message);\n    this.name = 'GitVanError';\n    this.code = code;\n    this.context = context;\n    this.timestamp = new Date().toISOString();\n  }\n}\n\nexport class GitOperationError extends GitVanError {\n  constructor(message, gitCommand, context = {}) {\n    super(message, 'GIT_OPERATION_ERROR', { gitCommand, ...context });\n    this.name = 'GitOperationError';\n  }\n}\n\nexport class FileSystemError extends GitVanError {\n  constructor(message, filePath, context = {}) {\n    super(message, 'FILE_SYSTEM_ERROR', { filePath, ...context });\n    this.name = 'FileSystemError';\n  }\n}\n\nexport class ValidationError extends GitVanError {\n  constructor(message, field, value, context = {}) {\n    super(message, 'VALIDATION_ERROR', { field, value, ...context });\n    this.name = 'ValidationError';\n  }\n}\n\nexport class ExternalServiceError extends GitVanError {\n  constructor(message, service, context = {}) {\n    super(message, 'EXTERNAL_SERVICE_ERROR', { service, ...context });\n    this.name = 'ExternalServiceError';\n  }\n}\n\nexport function createErrorHandler(ctx) {\n  return {\n    handleGitError(error, command) {\n      ctx.logger.error(`Git operation failed: ${command}`, error.message);\n      throw new GitOperationError(error.message, command, {\n        originalError: error,\n        stderr: error.stderr,\n        stdout: error.stdout\n      });\n    },\n    \n    handleFileSystemError(error, filePath) {\n      ctx.logger.error(`File system operation failed: ${filePath}`, error.message);\n      throw new FileSystemError(error.message, filePath, {\n        originalError: error,\n        code: error.code\n      });\n    },\n    \n    handleValidationError(message, field, value) {\n      ctx.logger.error(`Validation failed: ${field}`, message);\n      throw new ValidationError(message, field, value);\n    },\n    \n    handleExternalServiceError(error, service) {\n      ctx.logger.error(`External service failed: ${service}`, error.message);\n      throw new ExternalServiceError(error.message, service, {\n        originalError: error,\n        statusCode: error.statusCode,\n        response: error.response\n      });\n    }\n  };\n}\n```\n\n### **Step 2: Create Robust Job with Error Handling**\n\n```javascript\n// jobs/error-handling/robust-job.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { \n  createErrorHandler, \n  GitVanError, \n  GitOperationError, \n  FileSystemError, \n  ValidationError \n} from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate robust error handling patterns in GitVan jobs\",\n    tags: [\"error-handling\", \"robust\", \"patterns\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    const errorHandler = createErrorHandler(ctx);\n    \n    try {\n      // Validate input payload\n      if (!payload || typeof payload !== 'object') {\n        errorHandler.handleValidationError('Payload must be an object', 'payload', payload);\n      }\n      \n      if (payload.requiredField && typeof payload.requiredField !== 'string') {\n        errorHandler.handleValidationError('requiredField must be a string', 'requiredField', payload.requiredField);\n      }\n      \n      ctx.logger.log(\"✅ Input validation passed\");\n      \n      // Safe git operations with error handling\n      let repositoryInfo;\n      try {\n        const head = await git.head();\n        const branch = await git.getCurrentBranch();\n        const isClean = await git.isClean();\n        \n        repositoryInfo = {\n          head: head.substring(0, 8),\n          branch,\n          isClean,\n          timestamp: ctx.nowISO\n        };\n        \n        ctx.logger.log(\"✅ Git operations completed successfully\");\n      } catch (error) {\n        errorHandler.handleGitError(error, 'repository-info');\n      }\n      \n      // Safe file operations with error handling\n      let outputPath;\n      try {\n        const distDir = join(ctx.root, \"dist\");\n        await fs.mkdir(distDir, { recursive: true });\n        \n        outputPath = join(distDir, \"robust-job-output.json\");\n        \n        const outputData = {\n          success: true,\n          repository: repositoryInfo,\n          payload: payload,\n          generatedAt: ctx.nowISO,\n          jobId: ctx.jobId || 'unknown'\n        };\n        \n        await fs.writeFile(outputPath, JSON.stringify(outputData, null, 2));\n        \n        ctx.logger.log(`✅ Output file created: ${outputPath}`);\n      } catch (error) {\n        errorHandler.handleFileSystemError(error, outputPath);\n      }\n      \n      // Safe template operations with error handling\n      let templatePath;\n      try {\n        templatePath = await template.renderToFile(\n          \"robust-job.njk\",\n          \"dist/robust-job-report.html\",\n          {\n            title: \"Robust Job Report\",\n            repository: repositoryInfo,\n            payload: payload,\n            generatedAt: ctx.nowISO,\n            success: true\n          }\n        );\n        \n        ctx.logger.log(`✅ Template rendered: ${templatePath}`);\n      } catch (error) {\n        // Template errors are not critical, log and continue\n        ctx.logger.warn(`⚠️ Template rendering failed: ${error.message}`);\n        templatePath = null;\n      }\n      \n      // Return success result\n      return {\n        ok: true,\n        artifacts: [outputPath, templatePath].filter(Boolean),\n        data: {\n          repository: repositoryInfo,\n          payload: payload,\n          outputPath,\n          templatePath,\n          success: true\n        }\n      };\n      \n    } catch (error) {\n      // Handle any unexpected errors\n      ctx.logger.error(`❌ Job failed with error: ${error.message}`);\n      \n      // Create error report\n      const errorReport = {\n        success: false,\n        error: {\n          name: error.name,\n          message: error.message,\n          code: error.code,\n          context: error.context,\n          timestamp: ctx.nowISO,\n          stack: error.stack\n        },\n        jobId: ctx.jobId || 'unknown',\n        payload: payload\n      };\n      \n      // Try to save error report\n      try {\n        const errorPath = join(ctx.root, \"dist\", \"error-report.json\");\n        await fs.mkdir(join(ctx.root, \"dist\"), { recursive: true });\n        await fs.writeFile(errorPath, JSON.stringify(errorReport, null, 2));\n        \n        ctx.logger.log(`📝 Error report saved: ${errorPath}`);\n        \n        return {\n          ok: false,\n          artifacts: [errorPath],\n          data: errorReport\n        };\n      } catch (saveError) {\n        ctx.logger.error(`❌ Failed to save error report: ${saveError.message}`);\n        \n        // Re-throw original error\n        throw error;\n      }\n    }\n  }\n});\n```\n\n### **Step 3: Create Retry Mechanism**\n\n```javascript\n// jobs/error-handling/retry-job.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { createErrorHandler, ExternalServiceError } from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate retry mechanism for unreliable operations\",\n    tags: [\"error-handling\", \"retry\", \"resilience\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const errorHandler = createErrorHandler(ctx);\n    \n    const maxRetries = payload?.maxRetries || 3;\n    const retryDelay = payload?.retryDelay || 1000;\n    \n    // Simulate unreliable operation\n    const unreliableOperation = async (attempt) => {\n      ctx.logger.log(`🔄 Attempt ${attempt}/${maxRetries}`);\n      \n      // Simulate random failures\n      if (Math.random() < 0.7) {\n        throw new ExternalServiceError(`Simulated failure on attempt ${attempt}`, 'mock-service');\n      }\n      \n      return {\n        success: true,\n        attempt,\n        timestamp: ctx.nowISO\n      };\n    };\n    \n    let lastError;\n    let result;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        result = await unreliableOperation(attempt);\n        ctx.logger.log(`✅ Operation succeeded on attempt ${attempt}`);\n        break;\n      } catch (error) {\n        lastError = error;\n        ctx.logger.warn(`⚠️ Attempt ${attempt} failed: ${error.message}`);\n        \n        if (attempt < maxRetries) {\n          const delay = retryDelay * attempt; // Exponential backoff\n          ctx.logger.log(`⏳ Waiting ${delay}ms before retry...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    \n    if (!result) {\n      ctx.logger.error(`❌ All ${maxRetries} attempts failed`);\n      throw lastError;\n    }\n    \n    return {\n      ok: true,\n      artifacts: [],\n      data: {\n        ...result,\n        totalAttempts: maxRetries,\n        finalAttempt: result.attempt\n      }\n    };\n  }\n});\n```\n\n### **Step 4: Create Circuit Breaker Pattern**\n\n```javascript\n// jobs/error-handling/circuit-breaker-job.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { createErrorHandler, ExternalServiceError } from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate circuit breaker pattern for external services\",\n    tags: [\"error-handling\", \"circuit-breaker\", \"resilience\"]\n  },\n  async run({ ctx, payload }) {\n    const errorHandler = createErrorHandler(ctx);\n    \n    // Circuit breaker state\n    const circuitBreaker = {\n      state: 'CLOSED', // CLOSED, OPEN, HALF_OPEN\n      failureCount: 0,\n      lastFailureTime: null,\n      successCount: 0,\n      threshold: payload?.failureThreshold || 5,\n      timeout: payload?.timeout || 60000, // 1 minute\n      resetTimeout: payload?.resetTimeout || 30000 // 30 seconds\n    };\n    \n    const callExternalService = async () => {\n      // Simulate external service call\n      if (Math.random() < 0.3) {\n        throw new ExternalServiceError('External service unavailable', 'mock-service');\n      }\n      \n      return {\n        data: 'Service response',\n        timestamp: ctx.nowISO\n      };\n    };\n    \n    const executeWithCircuitBreaker = async () => {\n      const now = Date.now();\n      \n      // Check circuit breaker state\n      if (circuitBreaker.state === 'OPEN') {\n        if (now - circuitBreaker.lastFailureTime > circuitBreaker.resetTimeout) {\n          circuitBreaker.state = 'HALF_OPEN';\n          circuitBreaker.successCount = 0;\n          ctx.logger.log('🔄 Circuit breaker: HALF_OPEN');\n        } else {\n          throw new ExternalServiceError('Circuit breaker is OPEN', 'circuit-breaker');\n        }\n      }\n      \n      try {\n        const result = await callExternalService();\n        \n        // Success\n        circuitBreaker.failureCount = 0;\n        circuitBreaker.successCount++;\n        \n        if (circuitBreaker.state === 'HALF_OPEN') {\n          if (circuitBreaker.successCount >= 2) {\n            circuitBreaker.state = 'CLOSED';\n            ctx.logger.log('✅ Circuit breaker: CLOSED');\n          }\n        }\n        \n        return result;\n      } catch (error) {\n        // Failure\n        circuitBreaker.failureCount++;\n        circuitBreaker.lastFailureTime = now;\n        \n        if (circuitBreaker.failureCount >= circuitBreaker.threshold) {\n          circuitBreaker.state = 'OPEN';\n          ctx.logger.warn('⚠️ Circuit breaker: OPEN');\n        }\n        \n        throw error;\n      }\n    };\n    \n    try {\n      const result = await executeWithCircuitBreaker();\n      \n      return {\n        ok: true,\n        artifacts: [],\n        data: {\n          ...result,\n          circuitBreaker: {\n            state: circuitBreaker.state,\n            failureCount: circuitBreaker.failureCount,\n            successCount: circuitBreaker.successCount\n          }\n        }\n      };\n    } catch (error) {\n      ctx.logger.error(`❌ Circuit breaker operation failed: ${error.message}`);\n      \n      return {\n        ok: false,\n        artifacts: [],\n        data: {\n          error: error.message,\n          circuitBreaker: {\n            state: circuitBreaker.state,\n            failureCount: circuitBreaker.failureCount,\n            successCount: circuitBreaker.successCount\n          }\n        }\n      };\n    }\n  }\n});\n```\n\n### **Step 5: Create Error Recovery Job**\n\n```javascript\n// jobs/error-handling/recovery-job.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { createErrorHandler, FileSystemError } from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate error recovery and cleanup patterns\",\n    tags: [\"error-handling\", \"recovery\", \"cleanup\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const errorHandler = createErrorHandler(ctx);\n    \n    let tempFiles = [];\n    let resources = [];\n    \n    try {\n      // Create temporary resources\n      const tempDir = join(ctx.root, \"temp\", `job-${Date.now()}`);\n      await fs.mkdir(tempDir, { recursive: true });\n      resources.push(tempDir);\n      \n      // Create temporary files\n      const tempFile1 = join(tempDir, \"temp1.txt\");\n      const tempFile2 = join(tempDir, \"temp2.txt\");\n      \n      await fs.writeFile(tempFile1, \"Temporary data 1\");\n      await fs.writeFile(tempFile2, \"Temporary data 2\");\n      \n      tempFiles.push(tempFile1, tempFile2);\n      resources.push(tempFile1, tempFile2);\n      \n      ctx.logger.log(\"✅ Temporary resources created\");\n      \n      // Simulate some work that might fail\n      if (payload?.shouldFail) {\n        throw new Error(\"Simulated failure for recovery demonstration\");\n      }\n      \n      // Process the temporary files\n      const results = [];\n      for (const tempFile of tempFiles) {\n        const content = await fs.readFile(tempFile, 'utf-8');\n        results.push({\n          file: tempFile,\n          content,\n          processed: true\n        });\n      }\n      \n      // Create final output\n      const outputPath = join(ctx.root, \"dist\", \"recovery-job-output.json\");\n      await fs.mkdir(join(ctx.root, \"dist\"), { recursive: true });\n      \n      const outputData = {\n        success: true,\n        results,\n        timestamp: ctx.nowISO\n      };\n      \n      await fs.writeFile(outputPath, JSON.stringify(outputData, null, 2));\n      \n      ctx.logger.log(\"✅ Job completed successfully\");\n      \n      return {\n        ok: true,\n        artifacts: [outputPath],\n        data: outputData\n      };\n      \n    } catch (error) {\n      ctx.logger.error(`❌ Job failed: ${error.message}`);\n      \n      // Recovery: try to salvage what we can\n      const recoveryData = {\n        success: false,\n        error: error.message,\n        timestamp: ctx.nowISO,\n        recoveredData: []\n      };\n      \n      // Try to recover data from temporary files\n      for (const tempFile of tempFiles) {\n        try {\n          const content = await fs.readFile(tempFile, 'utf-8');\n          recoveryData.recoveredData.push({\n            file: tempFile,\n            content,\n            recovered: true\n          });\n        } catch (recoveryError) {\n          ctx.logger.warn(`⚠️ Could not recover data from ${tempFile}`);\n        }\n      }\n      \n      // Save recovery data\n      const recoveryPath = join(ctx.root, \"dist\", \"recovery-data.json\");\n      await fs.mkdir(join(ctx.root, \"dist\"), { recursive: true });\n      await fs.writeFile(recoveryPath, JSON.stringify(recoveryData, null, 2));\n      \n      return {\n        ok: false,\n        artifacts: [recoveryPath],\n        data: recoveryData\n      };\n      \n    } finally {\n      // Cleanup: always clean up resources\n      ctx.logger.log(\"🧹 Cleaning up resources...\");\n      \n      for (const resource of resources) {\n        try {\n          const stat = await fs.stat(resource);\n          if (stat.isDirectory()) {\n            await fs.rmdir(resource, { recursive: true });\n          } else {\n            await fs.unlink(resource);\n          }\n          ctx.logger.log(`✅ Cleaned up: ${resource}`);\n        } catch (cleanupError) {\n          ctx.logger.warn(`⚠️ Could not clean up ${resource}: ${cleanupError.message}`);\n        }\n      }\n      \n      ctx.logger.log(\"✅ Cleanup completed\");\n    }\n  }\n});\n```\n\n## 🔍 **Explanation**\n\n### **Error Types**\n\n1. **`GitVanError`**: Base error class with context\n2. **`GitOperationError`**: Git-specific errors\n3. **`FileSystemError`**: File system operation errors\n4. **`ValidationError`**: Input validation errors\n5. **`ExternalServiceError`**: External service failures\n\n### **Error Handling Patterns**\n\n1. **Try-Catch Blocks**: Wrap risky operations\n2. **Error Context**: Provide context for debugging\n3. **Graceful Degradation**: Continue with reduced functionality\n4. **Recovery Mechanisms**: Attempt to recover from failures\n5. **Cleanup**: Always clean up resources\n\n### **Resilience Patterns**\n\n1. **Retry Logic**: Retry failed operations with backoff\n2. **Circuit Breaker**: Prevent cascading failures\n3. **Timeout Handling**: Prevent hanging operations\n4. **Resource Cleanup**: Ensure resources are released\n\n## 🔄 **Variations**\n\n### **Variation 1: Timeout Handling**\n\n```javascript\n// jobs/error-handling/timeout-job.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { createErrorHandler, ExternalServiceError } from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate timeout handling for long-running operations\",\n    tags: [\"error-handling\", \"timeout\", \"async\"]\n  },\n  async run({ ctx, payload }) {\n    const errorHandler = createErrorHandler(ctx);\n    const timeout = payload?.timeout || 5000; // 5 seconds\n    \n    const longRunningOperation = () => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          if (Math.random() < 0.5) {\n            resolve({ success: true, duration: timeout });\n          } else {\n            reject(new ExternalServiceError('Operation timed out', 'timeout-service'));\n          }\n        }, timeout + 1000); // Simulate operation that takes longer than timeout\n      });\n    };\n    \n    try {\n      const result = await Promise.race([\n        longRunningOperation(),\n        new Promise((_, reject) => \n          setTimeout(() => reject(new ExternalServiceError('Operation timeout', 'timeout')), timeout)\n        )\n      ]);\n      \n      return {\n        ok: true,\n        artifacts: [],\n        data: result\n      };\n    } catch (error) {\n      ctx.logger.error(`❌ Operation failed: ${error.message}`);\n      \n      return {\n        ok: false,\n        artifacts: [],\n        data: {\n          error: error.message,\n          timeout\n        }\n      };\n    }\n  }\n});\n```\n\n### **Variation 2: Bulk Operation with Partial Success**\n\n```javascript\n// jobs/error-handling/bulk-operation.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { createErrorHandler } from \"../../utils/error-handler.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Demonstrate handling partial failures in bulk operations\",\n    tags: [\"error-handling\", \"bulk\", \"partial-success\"]\n  },\n  async run({ ctx, payload }) {\n    const errorHandler = createErrorHandler(ctx);\n    const items = payload?.items || ['item1', 'item2', 'item3', 'item4', 'item5'];\n    \n    const results = {\n      successful: [],\n      failed: [],\n      total: items.length\n    };\n    \n    for (const item of items) {\n      try {\n        // Simulate processing that might fail\n        if (Math.random() < 0.3) {\n          throw new Error(`Processing failed for ${item}`);\n        }\n        \n        const result = {\n          item,\n          processed: true,\n          timestamp: ctx.nowISO\n        };\n        \n        results.successful.push(result);\n        ctx.logger.log(`✅ Processed: ${item}`);\n        \n      } catch (error) {\n        const failure = {\n          item,\n          error: error.message,\n          timestamp: ctx.nowISO\n        };\n        \n        results.failed.push(failure);\n        ctx.logger.warn(`⚠️ Failed to process: ${item} - ${error.message}`);\n      }\n    }\n    \n    const successRate = (results.successful.length / results.total) * 100;\n    const isSuccess = successRate >= 50; // Consider success if 50% or more succeed\n    \n    ctx.logger.log(`📊 Bulk operation completed: ${successRate.toFixed(1)}% success rate`);\n    \n    return {\n      ok: isSuccess,\n      artifacts: [],\n      data: {\n        ...results,\n        successRate,\n        isSuccess\n      }\n    };\n  }\n});\n```\n\n## 🎯 **Best Practices**\n\n### **Error Handling**\n- **Specific Error Types**: Use specific error classes for different failure modes\n- **Error Context**: Include context information for debugging\n- **Graceful Degradation**: Continue operation with reduced functionality when possible\n- **Error Recovery**: Implement recovery mechanisms where appropriate\n\n### **Logging**\n- **Structured Logging**: Use consistent log formats\n- **Error Levels**: Use appropriate log levels (error, warn, info, debug)\n- **Context Information**: Include relevant context in log messages\n- **Sensitive Data**: Avoid logging sensitive information\n\n### **Resource Management**\n- **Cleanup**: Always clean up resources in finally blocks\n- **Resource Tracking**: Keep track of created resources\n- **Error Recovery**: Attempt to recover resources on failure\n- **Timeout Handling**: Set appropriate timeouts for operations\n\n### **Testing**\n- **Error Scenarios**: Test error handling paths\n- **Recovery Testing**: Verify recovery mechanisms work\n- **Resource Cleanup**: Ensure resources are properly cleaned up\n- **Edge Cases**: Test edge cases and boundary conditions\n\n## 🔗 **Related Recipes**\n\n- [Basic Job Setup](./basic-job-setup.md) - Getting started with jobs\n- [Configuration Management](./configuration-management.md) - Managing configurations\n- [Template System](./template-system.md) - Advanced template usage\n\n## 📚 **Resources**\n\n- [Error Handling Best Practices](../../docs/error-handling.md)\n- [GitVan Error Types](../../docs/error-types.md)\n- [Resilience Patterns](../../docs/resilience-patterns.md)\n\n## 🤝 **Contributors**\n\n- **Author**: GitVan Team\n- **Last Updated**: 2024-09-16\n- **Version**: 1.0.0\n\n---\n\n**Next Recipe**: [Changelog Generation](../documentation/changelog-generation.md)\n"
        }
    ]
}