# Implementation Guide

This guide provides step-by-step instructions for implementing gitvan v2 features, patterns, and workflows.

## Getting Started

### 1. Project Setup

Initialize a new gitvan v2 project:

```bash
# Create project directory
mkdir my-project && cd my-project
git init

# Install gitvan v2
npm init -y
npm install gitvan nunjucks unctx

# Create basic structure
mkdir -p jobs events templates
```

### 2. Basic Configuration

Create `gitvan.config.js`:

```javascript
import { defineConfig } from 'gitvan/config'

export default defineConfig({
  git: {
    defaultBranch: 'main',
    noteRefs: {
      results: 'refs/notes/gitvan/results',
      locks: 'refs/gitvan/locks'
    }
  },
  daemon: {
    port: 3000,
    logLevel: 'info'
  },
  jobs: {
    timeout: 300000,  // 5 minutes
    retry: 3
  }
})
```

### 3. Your First Job

Create `jobs/hello.mjs`:

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Hello world job' },
  async run() {
    const git = useGit()
    const branch = git.branch()
    console.log(`Hello from ${branch}!`)
    return { ok: true }
  }
})
```

Test it:

```bash
npx gitvan run hello
```

## Job Implementation Patterns

### Atomic Jobs with run() Function

Use for imperative logic:

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit, useExec } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: {
    desc: 'Run tests and generate coverage',
    tags: ['test', 'coverage']
  },
  async run() {
    const exec = useExec()
    const git = useGit()

    // Run tests
    const testResult = exec.cli('npm', ['test'])
    if (!testResult.ok) {
      return { ok: false, error: 'Tests failed' }
    }

    // Generate coverage report
    const coverageResult = exec.cli('npm', ['run', 'coverage'])

    // Commit results to git notes
    git.note('refs/notes/test-results', JSON.stringify({
      branch: git.branch(),
      testsPassed: testResult.ok,
      coverage: coverageResult.stdout
    }))

    return {
      ok: true,
      artifact: 'coverage/lcov-report/index.html',
      meta: { coverage: coverageResult.stdout }
    }
  }
})
```

### Atomic Jobs with action Spec

Use for simple declarative operations:

```javascript
import { defineJob } from 'gitvan/jobs'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Build project' },
  action: {
    exec: 'cli',
    cmd: 'npm',
    args: ['run', 'build'],
    timeoutMs: 300000
  }
})
```

### Composite Jobs - Sequence

Execute steps one after another:

```javascript
import { defineJob } from 'gitvan/jobs'

export default defineJob({
  kind: 'sequence',
  meta: { desc: 'Full deployment pipeline' },
  steps: [
    { exec: 'job', name: 'test' },
    { exec: 'job', name: 'build' },
    { exec: 'cli', cmd: 'docker', args: ['build', '-t', 'myapp:latest', '.'] },
    { exec: 'cli', cmd: 'docker', args: ['push', 'myapp:latest'] },
    { exec: 'job', name: 'deploy:production' }
  ]
})
```

### Composite Jobs - Parallel

Execute steps concurrently:

```javascript
import { defineJob } from 'gitvan/jobs'

export default defineJob({
  kind: 'parallel',
  meta: { desc: 'Run all tests concurrently' },
  steps: [
    { exec: 'cli', cmd: 'npm', args: ['run', 'test:unit'] },
    { exec: 'cli', cmd: 'npm', args: ['run', 'test:integration'] },
    { exec: 'cli', cmd: 'npm', args: ['run', 'test:e2e'] }
  ]
})
```

## Template Implementation

### Basic Template Job

Create `templates/changelog.njk`:

```html
# Changelog

Generated: {{ nowISO }}
Repository: {{ git.root }}
Branch: {{ git.branch() }}

## Recent Commits

{% for commit in commits %}
- {{ commit }}
{% endfor %}

## Statistics

- Total commits: {{ commits.length }}
- Generated by: gitvan v2
```

Create `jobs/changelog.mjs`:

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit, useTemplate } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Generate changelog' },
  async run() {
    const git = useGit()
    const t = useTemplate()

    const commits = git.run('log --oneline -20').split('\n')
    t.renderToFile('changelog.njk', 'CHANGELOG.md', { commits })

    return { ok: true, artifact: 'CHANGELOG.md' }
  }
})
```

### Template with Custom Data and Functions

```javascript
import { defineJob } from 'gitvan/jobs'
import { useTemplate } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Generate API docs' },
  async run() {
    const t = useTemplate()

    // Custom data can include functions
    const data = {
      version: process.env.VERSION || '1.0.0',
      endpoints: getAPIEndpoints(), // Custom function
      formatDate: (date) => new Date(date).toLocaleDateString(),
      isProduction: () => process.env.NODE_ENV === 'production'
    }

    t.renderToFile('api-docs.njk', 'docs/API.md', data)

    return { ok: true, artifact: 'docs/API.md' }
  }
})

function getAPIEndpoints() {
  // Scan code for API endpoints
  return [
    { path: '/users', method: 'GET', desc: 'List users' },
    { path: '/users', method: 'POST', desc: 'Create user' }
  ]
}
```

### Template-Only Job (Declarative)

```javascript
import { defineJob } from 'gitvan/jobs'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Generate daily report' },
  action: {
    exec: 'tmpl',
    template: 'daily-report.njk',
    out: 'reports/{{ nowISO | slug }}.md',
    data: {
      title: 'Daily Development Report',
      commits: ({ git }) => git.run('log --since="24 hours ago" --oneline').split('\n')
    }
  }
})
```

## Event Handler Implementation

### Push Event Handler

Create `events/push-to/main.mjs`:

```javascript
import { useGit, useExec } from 'gitvan/composables'

export default async function({ payload, meta }) {
  const git = useGit()
  const exec = useExec()

  console.log(`Push to main detected: ${meta.commit}`)

  // Run CI/CD pipeline
  const result = exec.cli('npm', ['run', 'ci'])

  if (result.ok) {
    git.note('refs/notes/ci', `CI passed for ${meta.commit}`)
  }

  return result
}
```

### Scheduled Event Handler

Create `events/cron/0_2_*_*_*.mjs` (daily at 2 AM):

```javascript
// Reference existing job
export const job = 'maintenance:daily'

// Or inline handler
export default async function() {
  const exec = useExec()

  // Daily maintenance tasks
  await exec.cli('npm', ['audit'])
  await exec.cli('npm', ['update'])

  return { ok: true }
}
```

### File Change Event Handler

Create `events/path-changed/src/**/*.js.mjs`:

```javascript
import { useExec } from 'gitvan/composables'

export default async function({ payload, meta }) {
  const exec = useExec()

  console.log('JavaScript files changed:', meta.changes)

  // Run linting on changed files
  const changedFiles = meta.changes
    .filter(c => c.path.endsWith('.js'))
    .map(c => c.path)

  if (changedFiles.length > 0) {
    return exec.cli('eslint', changedFiles)
  }

  return { ok: true }
}
```

### Complex Event Logic

Create `events/merge-to/main.mjs`:

```javascript
import { useGit, useTemplate, useExec } from 'gitvan/composables'

export default async function({ payload, meta }) {
  const git = useGit()
  const t = useTemplate()
  const exec = useExec()

  // Get merge information
  const mergeCommit = meta.commit
  const sourceBranch = git.run(`show --format="%s" ${mergeCommit}`).match(/from (.+)/)?.[1]

  // Generate merge report
  const commits = git.run(`log ${sourceBranch}..${mergeCommit} --oneline`).split('\n')
  t.renderToFile('merge-report.njk', 'reports/merge-{{nowISO | slug}}.md', {
    sourceBranch,
    commits,
    author: meta.author
  })

  // Run deployment if it's a release branch
  if (sourceBranch?.startsWith('release/')) {
    console.log('Release branch merged, triggering deployment...')
    return exec.cli('npm', ['run', 'deploy'])
  }

  return { ok: true }
}
```

## Git Integration Patterns

### Working with Git Data

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Analyze repository' },
  async run() {
    const git = useGit()

    // Basic git info
    const branch = git.branch()
    const head = git.head()
    const root = git.root

    // Get commit history
    const recentCommits = git.run('log --oneline -10').split('\n')
    const authors = git.run('shortlog -sn').split('\n')

    // Get changed files
    const changedFiles = git.run('diff --name-only HEAD~1').split('\n')

    // Work with branches
    const allBranches = git.run('branch -a').split('\n')
    const remoteBranches = git.run('branch -r').split('\n')

    // Tags
    const tags = git.run('tag -l').split('\n')
    const latestTag = git.run('describe --tags --abbrev=0')

    console.log('Repository Analysis:', {
      branch,
      head,
      recentCommits: recentCommits.length,
      authors: authors.length,
      changedFiles: changedFiles.length,
      branches: allBranches.length,
      tags: tags.length,
      latestTag
    })

    return { ok: true }
  }
})
```

### Using Git Notes

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Manage git notes' },
  async run() {
    const git = useGit()
    const commit = git.head()

    // Add a note
    git.note('refs/notes/deploy', JSON.stringify({
      deployedAt: new Date().toISOString(),
      environment: 'production',
      version: '1.2.3'
    }), commit)

    // Append to existing note
    git.appendNote('refs/notes/deploy', JSON.stringify({
      healthCheck: 'passed',
      checkedAt: new Date().toISOString()
    }), commit)

    // Read notes (via git command)
    const notes = git.run(`notes --ref=refs/notes/deploy show ${commit}`)
    console.log('Deploy notes:', notes)

    return { ok: true }
  }
})
```

### Managing Git References

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Manage custom refs' },
  async run() {
    const git = useGit()
    const head = git.head()

    // Create custom reference
    git.setRef('refs/gitvan/last-deploy', head)

    // List references
    const deployRefs = git.listRefs('refs/gitvan/')
    console.log('Gitvan refs:', deployRefs)

    // Clean up old references
    const oldRefs = git.listRefs('refs/gitvan/temp/')
    oldRefs.forEach(ref => git.delRef(ref))

    return { ok: true }
  }
})
```

## Advanced Patterns

### Multi-Step Workflow with Error Handling

```javascript
import { defineJob } from 'gitvan/jobs'
import { useExec, useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Complex deployment workflow' },
  async run() {
    const exec = useExec()
    const git = useGit()

    try {
      // Step 1: Pre-deployment checks
      console.log('Running pre-deployment checks...')
      const checksResult = exec.cli('npm', ['run', 'pre-deploy-check'])
      if (!checksResult.ok) {
        throw new Error('Pre-deployment checks failed')
      }

      // Step 2: Build
      console.log('Building application...')
      const buildResult = exec.cli('npm', ['run', 'build'])
      if (!buildResult.ok) {
        throw new Error('Build failed')
      }

      // Step 3: Run tests on build
      console.log('Testing build...')
      const testResult = exec.cli('npm', ['run', 'test:build'])
      if (!testResult.ok) {
        throw new Error('Build tests failed')
      }

      // Step 4: Deploy
      console.log('Deploying...')
      const deployResult = exec.cli('npm', ['run', 'deploy:production'])
      if (!deployResult.ok) {
        throw new Error('Deployment failed')
      }

      // Step 5: Post-deployment verification
      console.log('Verifying deployment...')
      const verifyResult = exec.cli('npm', ['run', 'verify-deploy'])
      if (!verifyResult.ok) {
        console.warn('Post-deployment verification failed, but deployment succeeded')
      }

      // Record successful deployment
      git.note('refs/notes/deployments', JSON.stringify({
        deployedAt: new Date().toISOString(),
        commit: git.head(),
        branch: git.branch(),
        status: 'success'
      }))

      return {
        ok: true,
        meta: {
          deployed: true,
          verificationPassed: verifyResult.ok
        }
      }

    } catch (error) {
      // Record failed deployment
      git.note('refs/notes/deployments', JSON.stringify({
        deployedAt: new Date().toISOString(),
        commit: git.head(),
        branch: git.branch(),
        status: 'failed',
        error: error.message
      }))

      return { ok: false, error: error.message }
    }
  }
})
```

### Dynamic Job Generation

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit, useExec } from 'gitvan/composables'
import fs from 'fs'
import path from 'path'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Test all packages in monorepo' },
  async run() {
    const git = useGit()
    const exec = useExec()
    const root = git.root

    // Find all packages
    const packagesDir = path.join(root, 'packages')
    const packages = fs.readdirSync(packagesDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name)

    console.log(`Found ${packages.length} packages:`, packages)

    // Test each package
    const results = []
    for (const pkg of packages) {
      console.log(`Testing package: ${pkg}`)

      const result = exec.cli('npm', ['test'], {
        cwd: path.join(packagesDir, pkg)
      })

      results.push({
        package: pkg,
        success: result.ok,
        output: result.stdout,
        error: result.stderr
      })
    }

    // Generate test report
    const passed = results.filter(r => r.success).length
    const failed = results.filter(r => !r.success).length

    console.log(`Test Results: ${passed} passed, ${failed} failed`)

    // Write detailed report
    const report = {
      timestamp: new Date().toISOString(),
      commit: git.head(),
      branch: git.branch(),
      summary: { total: packages.length, passed, failed },
      details: results
    }

    fs.writeFileSync(
      path.join(root, 'test-results.json'),
      JSON.stringify(report, null, 2)
    )

    return {
      ok: failed === 0,
      meta: {
        packagesTotal: packages.length,
        packagesPassed: passed,
        packagesFailed: failed
      },
      artifact: 'test-results.json'
    }
  }
})
```

### Custom Composable

Create reusable functionality:

```javascript
// composables/useDocker.mjs
import { useExec, useGit } from 'gitvan/composables'

export function useDocker() {
  const exec = useExec()
  const git = useGit()

  function build(tag, dockerfile = 'Dockerfile') {
    return exec.cli('docker', ['build', '-f', dockerfile, '-t', tag, '.'])
  }

  function push(tag) {
    return exec.cli('docker', ['push', tag])
  }

  function run(image, options = []) {
    return exec.cli('docker', ['run', ...options, image])
  }

  function getTag(prefix = 'myapp') {
    const commit = git.head().substring(0, 8)
    const branch = git.branch().replace(/[^a-zA-Z0-9]/g, '-')
    return `${prefix}:${branch}-${commit}`
  }

  return { build, push, run, getTag }
}
```

Use in jobs:

```javascript
import { defineJob } from 'gitvan/jobs'
import { useDocker } from '../composables/useDocker.mjs'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Build and push Docker image' },
  async run() {
    const docker = useDocker()

    const tag = docker.getTag()
    console.log(`Building Docker image: ${tag}`)

    const buildResult = docker.build(tag)
    if (!buildResult.ok) {
      return { ok: false, error: 'Docker build failed' }
    }

    const pushResult = docker.push(tag)
    if (!pushResult.ok) {
      return { ok: false, error: 'Docker push failed' }
    }

    return {
      ok: true,
      meta: { image: tag },
      artifact: `docker:${tag}`
    }
  }
})
```

## Testing Jobs

### Unit Testing Jobs

```javascript
// jobs/example.test.mjs
import { test, expect } from 'vitest'
import { withGitVan } from 'gitvan/runtime'
import exampleJob from './example.mjs'

test('example job executes successfully', async () => {
  const mockContext = {
    root: '/tmp/test-repo',
    head: 'abc123',
    branch: 'main',
    env: {},
    jobs: new Map()
  }

  const result = await withGitVan(mockContext, async () => {
    return await exampleJob.run()
  })

  expect(result.ok).toBe(true)
  expect(result.artifact).toBeDefined()
})
```

### Integration Testing

```javascript
// test/integration/deployment.test.mjs
import { test, expect, beforeEach, afterEach } from 'vitest'
import { execSync } from 'child_process'
import fs from 'fs'
import path from 'path'

let testRepo

beforeEach(async () => {
  // Create test git repository
  testRepo = '/tmp/gitvan-test-' + Date.now()
  fs.mkdirSync(testRepo)
  execSync('git init', { cwd: testRepo })
  execSync('git config user.email "test@example.com"', { cwd: testRepo })
  execSync('git config user.name "Test User"', { cwd: testRepo })

  // Create test job
  const jobsDir = path.join(testRepo, 'jobs')
  fs.mkdirSync(jobsDir)
  fs.writeFileSync(path.join(jobsDir, 'test.mjs'), `
    import { defineJob } from 'gitvan/jobs'
    export default defineJob({
      kind: 'atomic',
      async run() {
        return { ok: true, message: 'Test job executed' }
      }
    })
  `)

  execSync('git add .', { cwd: testRepo })
  execSync('git commit -m "Initial commit"', { cwd: testRepo })
})

afterEach(() => {
  // Cleanup test repository
  if (testRepo && fs.existsSync(testRepo)) {
    fs.rmSync(testRepo, { recursive: true, force: true })
  }
})

test('job execution in real git repository', async () => {
  // Run gitvan job in test repository
  const result = execSync('npx gitvan run test', {
    cwd: testRepo,
    encoding: 'utf-8'
  })

  expect(result).toContain('Test job executed')
})
```

## Debugging and Monitoring

### Adding Debug Logging

```javascript
import { defineJob } from 'gitvan/jobs'
import { useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Debug example' },
  async run() {
    const git = useGit()

    console.log('=== Debug Info ===')
    console.log('Repository root:', git.root)
    console.log('Current branch:', git.branch())
    console.log('HEAD commit:', git.head())
    console.log('Environment:', process.env.NODE_ENV)

    // Add timestamps
    console.time('git-operations')
    const commits = git.run('log --oneline -100')
    console.timeEnd('git-operations')

    console.log('Recent commits count:', commits.split('\n').length)

    return { ok: true }
  }
})
```

### Performance Monitoring

```javascript
import { defineJob } from 'gitvan/jobs'
import { useExec, useGit } from 'gitvan/composables'

export default defineJob({
  kind: 'atomic',
  meta: { desc: 'Performance monitoring example' },
  async run() {
    const exec = useExec()
    const git = useGit()

    const startTime = Date.now()
    const startMemory = process.memoryUsage()

    try {
      // Your job logic here
      const result = exec.cli('npm', ['test'])

      const endTime = Date.now()
      const endMemory = process.memoryUsage()

      const metrics = {
        duration: endTime - startTime,
        memoryDelta: {
          rss: endMemory.rss - startMemory.rss,
          heapUsed: endMemory.heapUsed - startMemory.heapUsed
        }
      }

      // Store metrics in git notes
      git.note('refs/notes/performance', JSON.stringify({
        job: 'performance-example',
        timestamp: new Date().toISOString(),
        metrics
      }))

      console.log('Performance metrics:', metrics)

      return {
        ok: result.ok,
        meta: { performance: metrics }
      }

    } catch (error) {
      const endTime = Date.now()
      console.error('Job failed after', endTime - startTime, 'ms')
      return { ok: false, error: error.message }
    }
  }
})
```

This implementation guide covers the core patterns and practices for building effective gitvan v2 workflows. Each example is production-ready and follows the architecture decisions outlined in the ADRs.