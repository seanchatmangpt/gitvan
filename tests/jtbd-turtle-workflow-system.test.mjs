// tests/jtbd-turtle-workflow-system.test.mjs
// JTBD (Jobs To Be Done) comprehensive test for Turtle Workflow System
// Validates that the workflow system meets production quality standards

import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdirSync, rmSync, writeFileSync, readFileSync, existsSync } from "node:fs";
import { join } from "node:path";
import { execSync } from "node:child_process";
import { withMemFSTestEnvironment } from "../src/composables/test-environment.mjs";
import { StepRunner } from "../src/workflow/StepRunner.mjs";
import { ContextManager } from "../src/workflow/ContextManager.mjs";
import { useTemplate } from "../src/composables/template.mjs";
import { readFile } from "node:fs/promises";

describe("JTBD Turtle Workflow System - Production Quality Validation", () => {
  let testDir;
  let reportsDir;

  beforeEach(async () => {
    testDir = join(process.cwd(), "test-jtbd-turtle-workflow");
    mkdirSync(testDir, { recursive: true });

    reportsDir = join(testDir, "reports");
    mkdirSync(reportsDir, { recursive: true });

    // Initialize git repository in test directory
    execSync("git init", { stdio: "pipe", cwd: testDir });
    execSync("git config user.email 'test@example.com'", {
      stdio: "pipe",
      cwd: testDir,
    });
    execSync("git config user.name 'Test User'", {
      stdio: "pipe",
      cwd: testDir,
    });
  });

  afterEach(async () => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe("JTBD: Core Development Workflows", () => {
    it("should handle code generation and documentation workflows", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "README.md": "# Code Generation Test\n",
            "package.json": `{
              "name": "test-project",
              "version": "1.0.0",
              "dependencies": {
                "react": "^18.0.0",
                "typescript": "^5.0.0"
              }
            }`,
          },
        },
        async (env) => {
          // JTBD: Generate comprehensive project documentation
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "code-generation-workflow",
            inputs: {
              projectName: "Test Project",
              version: "1.0.0",
              dependencies: [
                { name: "react", version: "^18.0.0" },
                { name: "typescript", version: "^5.0.0" }
              ],
              features: [
                "Component-based architecture",
                "TypeScript support",
                "Modern React patterns"
              ]
            },
            startTime: Date.now(),
          });

          // Step 1: Generate project documentation
          const docStep = {
            id: "generate-docs",
            type: "template",
            config: {
              template: `# {{ projectName }} v{{ version }}

## Overview
This project implements a modern React application with TypeScript support.

## Features
{% for feature in features %}
- {{ feature }}
{% endfor %}

## Dependencies
{% for dep in dependencies %}
- **{{ dep.name }}**: {{ dep.version }}
{% endfor %}

## Getting Started
1. Install dependencies: \`npm install\`
2. Start development server: \`npm start\`
3. Build for production: \`npm run build\`

## Architecture
- **Framework**: React {{ dependencies[0].version }}
- **Language**: TypeScript {{ dependencies[1].version }}
- **Build Tool**: Modern bundling with hot reload

---
*Generated by GitVan Workflow System*`,
              filePath: "./docs/PROJECT_OVERVIEW.md",
            },
          };

          const docResult = await stepRunner.executeStep(
            docStep,
            contextManager,
            null,
            null
          );

          expect(docResult.success).toBe(true);
          const docContent = docResult.outputs.content;
          expect(docContent).toContain("# Test Project v1.0.0");
          expect(docContent).toContain("Component-based architecture");
          expect(docContent).toContain("**react**: ^18.0.0");
          expect(docContent).toContain("**typescript**: ^5.0.0");

          // Step 2: Generate API documentation
          const apiStep = {
            id: "generate-api-docs",
            type: "file",
            config: {
              filePath: "./docs/API_REFERENCE.md",
              operation: "write",
              content: `# API Reference

## Components

### Main Components
{% for feature in features %}
- **{{ feature | title }}**: {{ feature }}
{% endfor %}

## Configuration
- **Project**: {{ projectName }}
- **Version**: {{ version }}
- **Dependencies**: {{ dependencies | length }}

## Usage Examples
\`\`\`typescript
import React from 'react';

const {{ projectName | slug }}: React.FC = () => {
  return <div>Hello {{ projectName }}!</div>;
};

export default {{ projectName | slug }};
\`\`\`

---
*Generated by GitVan Workflow System*`,
            },
          };

          const apiResult = await stepRunner.executeStep(
            apiStep,
            contextManager,
            null,
            null
          );

          expect(apiResult.success).toBe(true);

          // Validate files were created
          const docFile = await readFile("./docs/PROJECT_OVERVIEW.md", "utf8");
          const apiFile = await readFile("./docs/API_REFERENCE.md", "utf8");

          expect(docFile).toBe(docContent);
          expect(apiFile).toContain("# API Reference");
          expect(apiFile).toContain("**Component-Based Architecture**: Component-based architecture");
          expect(apiFile).toContain("**Dependencies**: 2");

          console.log("✅ JTBD: Code generation and documentation workflows work");
        }
      );
    });

    it("should handle automated testing and quality assurance workflows", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "README.md": "# Quality Assurance Test\n",
            "src/components/Button.tsx": `import React from 'react';

interface ButtonProps {
  label: string;
  onClick: () => void;
}

export const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};`,
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "qa-workflow",
            inputs: {
              componentName: "Button",
              testCases: [
                { name: "renders correctly", type: "unit" },
                { name: "handles click events", type: "interaction" },
                { name: "accessibility compliance", type: "a11y" }
              ],
              coverage: { lines: 95, functions: 90, branches: 85 }
            },
            startTime: Date.now(),
          });

          // Generate test files
          const testStep = {
            id: "generate-tests",
            type: "template",
            config: {
              template: `import { render, screen, fireEvent } from '@testing-library/react';
import { {{ componentName }} } from '../{{ componentName }}';

describe('{{ componentName }} Component', () => {
{% for testCase in testCases %}
  it('{{ testCase.name }}', () => {
    // {{ testCase.type | title }} test
    const mockOnClick = jest.fn();
    render(<{{ componentName }} label="Test" onClick={mockOnClick} />);
    
    {% if testCase.type == "unit" %}
    expect(screen.getByText('Test')).toBeInTheDocument();
    {% elif testCase.type == "interaction" %}
    fireEvent.click(screen.getByText('Test'));
    expect(mockOnClick).toHaveBeenCalledTimes(1);
    {% elif testCase.type == "a11y" %}
    expect(screen.getByRole('button')).toBeInTheDocument();
    {% endif %}
  });
{% endfor %}
});

// Coverage Report
// Lines: {{ coverage.lines }}%
// Functions: {{ coverage.functions }}%
// Branches: {{ coverage.branches }}%`,
              filePath: "./tests/{{ componentName }}.test.tsx",
            },
          };

          const testResult = await stepRunner.executeStep(
            testStep,
            contextManager,
            null,
            null
          );

          expect(testResult.success).toBe(true);
          const testContent = testResult.outputs.content;
          expect(testContent).toContain("describe('Button Component'");
          expect(testContent).toContain("renders correctly");
          expect(testContent).toContain("handles click events");
          expect(testContent).toContain("accessibility compliance");
          expect(testContent).toContain("Lines: 95%");

          console.log("✅ JTBD: Automated testing and QA workflows work");
        }
      );
    });
  });

  describe("JTBD: Infrastructure and DevOps Workflows", () => {
    it("should handle deployment and configuration management", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "README.md": "# Infrastructure Test\n",
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "infrastructure-workflow",
            inputs: {
              environment: "production",
              services: [
                { name: "web", port: 3000, replicas: 3 },
                { name: "api", port: 8080, replicas: 2 },
                { name: "database", port: 5432, replicas: 1 }
              ],
              config: {
                region: "us-west-2",
                cluster: "production-cluster",
                namespace: "default"
              }
            },
            startTime: Date.now(),
          });

          // Generate Kubernetes deployment manifests
          const k8sStep = {
            id: "generate-k8s",
            type: "template",
            config: {
              template: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ service.name }}-deployment
  namespace: {{ config.namespace }}
spec:
  replicas: {{ service.replicas }}
  selector:
    matchLabels:
      app: {{ service.name }}
  template:
    metadata:
      labels:
        app: {{ service.name }}
    spec:
      containers:
      - name: {{ service.name }}
        image: {{ service.name }}:latest
        ports:
        - containerPort: {{ service.port }}
        env:
        - name: ENVIRONMENT
          value: "{{ environment }}"
        - name: REGION
          value: "{{ config.region }}"
---
apiVersion: v1
kind: Service
metadata:
  name: {{ service.name }}-service
  namespace: {{ config.namespace }}
spec:
  selector:
    app: {{ service.name }}
  ports:
  - port: {{ service.port }}
    targetPort: {{ service.port }}
  type: ClusterIP`,
              filePath: "./k8s/{{ service.name }}-deployment.yaml",
            },
          };

          // Generate deployment for each service
          for (const service of contextManager.getInputs().services) {
            contextManager.setOutput("service", service);
            
            const result = await stepRunner.executeStep(
              k8sStep,
              contextManager,
              null,
              null
            );

            expect(result.success).toBe(true);
            const content = result.outputs.content;
            expect(content).toContain(`name: ${service.name}-deployment`);
            expect(content).toContain(`replicas: ${service.replicas}`);
            expect(content).toContain(`containerPort: ${service.port}`);
          }

          console.log("✅ JTBD: Infrastructure and DevOps workflows work");
        }
      );
    });
  });

  describe("JTBD: Business Intelligence and Reporting", () => {
    it("should handle data analysis and report generation", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "README.md": "# Business Intelligence Test\n",
            "data/sales.json": `{
              "sales": [
                {"product": "Widget A", "revenue": 15000, "units": 100, "region": "North"},
                {"product": "Widget B", "revenue": 22000, "units": 80, "region": "South"},
                {"product": "Widget C", "revenue": 18000, "units": 120, "region": "East"},
                {"product": "Widget A", "revenue": 12000, "units": 75, "region": "West"}
              ],
              "period": "Q1 2024"
            }`,
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "bi-workflow",
            inputs: {
              reportTitle: "Q1 2024 Sales Analysis",
              dataFile: "./data/sales.json"
            },
            startTime: Date.now(),
          });

          // Step 1: Read sales data
          const readStep = {
            id: "read-sales-data",
            type: "file",
            config: {
              filePath: "./data/sales.json",
              operation: "read"
            }
          };

          const readResult = await stepRunner.executeStep(
            readStep,
            contextManager,
            null,
            null
          );

          expect(readResult.success).toBe(true);
          const salesData = JSON.parse(readResult.outputs.content);
          expect(salesData.sales).toHaveLength(4);

          // Step 2: Generate comprehensive sales report
          const reportStep = {
            id: "generate-sales-report",
            type: "template",
            config: {
              template: `# {{ reportTitle }}

**Period**: {{ period }}
**Generated**: {{ "now" | date("YYYY-MM-DD HH:mm:ss") }}

## Executive Summary
- **Total Revenue**: ${{ sales | sum(attribute='revenue') | int }}
- **Total Units Sold**: {{ sales | sum(attribute='units') }}
- **Average Revenue per Unit**: ${{ (sales | sum(attribute='revenue') / sales | sum(attribute='units')) | round(2) }}
- **Number of Products**: {{ sales | map(attribute='product') | unique | length }}

## Product Performance
{% for product in sales | groupby('product') %}
### {{ product.key }}
- **Total Revenue**: ${{ product.list | sum(attribute='revenue') | int }}
- **Total Units**: {{ product.list | sum(attribute='units') }}
- **Average Price**: ${{ (product.list | sum(attribute='revenue') / product.list | sum(attribute='units')) | round(2) }}
- **Regions**: {{ product.list | map(attribute='region') | unique | join(', ') }}
{% endfor %}

## Regional Analysis
{% for region in sales | groupby('region') %}
### {{ region.key }} Region
- **Revenue**: ${{ region.list | sum(attribute='revenue') | int }}
- **Units**: {{ region.list | sum(attribute='units') }}
- **Products**: {{ region.list | map(attribute='product') | unique | join(', ') }}
{% endfor %}

## Top Performers
- **Highest Revenue Product**: {{ sales | max(attribute='revenue') | attr('product') }} (${{ sales | max(attribute='revenue') | attr('revenue') | int }})
- **Most Units Sold**: {{ sales | max(attribute='units') | attr('product') }} ({{ sales | max(attribute='units') | attr('units') }} units)
- **Best Region**: {{ sales | groupby('region') | map('list') | map('sum', 'revenue') | max | attr('region') }}

---
*Report generated by GitVan Business Intelligence Workflow*`,
              filePath: "./reports/{{ reportTitle | slug }}-{{ 'now' | date('YYYY-MM-DD') }}.md"
            }
          };

          contextManager.setOutput("sales", salesData.sales);
          contextManager.setOutput("period", salesData.period);

          const reportResult = await stepRunner.executeStep(
            reportStep,
            contextManager,
            null,
            null
          );

          expect(reportResult.success).toBe(true);
          const reportContent = reportResult.outputs.content;
          expect(reportContent).toContain("# Q1 2024 Sales Analysis");
          expect(reportContent).toContain("Total Revenue: $67000");
          expect(reportContent).toContain("Total Units Sold: 375");
          expect(reportContent).toContain("Number of Products: 3");

          // Step 3: Generate executive dashboard data
          const dashboardStep = {
            id: "generate-dashboard",
            type: "file",
            config: {
              filePath: "./reports/dashboard-data.json",
              operation: "write",
              content: `{
                "dashboard": {
                  "title": "{{ reportTitle }}",
                  "period": "{{ period }}",
                  "generated": "{{ 'now' | date('YYYY-MM-DDTHH:mm:ssZ') }}",
                  "metrics": {
                    "totalRevenue": {{ sales | sum(attribute='revenue') }},
                    "totalUnits": {{ sales | sum(attribute='units') }},
                    "avgRevenuePerUnit": {{ (sales | sum(attribute='revenue') / sales | sum(attribute='units')) | round(2) }},
                    "productCount": {{ sales | map(attribute='product') | unique | length }},
                    "regionCount": {{ sales | map(attribute='region') | unique | length }}
                  },
                  "topProducts": {{ sales | groupby('product') | map('list') | map('sum', 'revenue') | sort(true) | slice(0, 3) | tojson }},
                  "regionalBreakdown": {{ sales | groupby('region') | tojson }}
                }
              }`
            }
          };

          const dashboardResult = await stepRunner.executeStep(
            dashboardStep,
            contextManager,
            null,
            null
          );

          expect(dashboardResult.success).toBe(true);

          // Validate all files were created
          const reportFile = await readFile("./reports/q1-2024-sales-analysis-2024-01-15.md", "utf8");
          const dashboardFile = await readFile("./reports/dashboard-data.json", "utf8");

          expect(reportFile).toBe(reportContent);
          expect(dashboardFile).toContain('"totalRevenue": 67000');
          expect(dashboardFile).toContain('"totalUnits": 375');
          expect(dashboardFile).toContain('"productCount": 3');

          console.log("✅ JTBD: Business Intelligence and reporting workflows work");
        }
      );
    });
  });

  describe("JTBD: Quality Assurance and Validation", () => {
    it("should validate production-quality workflow execution", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "README.md": "# Quality Validation Test\n",
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "quality-validation",
            inputs: {
              testSuite: "comprehensive",
              scenarios: [
                { name: "template-rendering", status: "passed", duration: 45 },
                { name: "file-operations", status: "passed", duration: 23 },
                { name: "data-processing", status: "passed", duration: 67 },
                { name: "error-handling", status: "passed", duration: 12 }
              ],
              coverage: { statements: 98, branches: 95, functions: 97, lines: 98 }
            },
            startTime: Date.now(),
          });

          // Generate quality assurance report
          const qaStep = {
            id: "generate-qa-report",
            type: "template",
            config: {
              template: `# Quality Assurance Report

**Test Suite**: {{ testSuite | title }}
**Generated**: {{ "now" | date("YYYY-MM-DD HH:mm:ss") }}

## Test Results Summary
- **Total Scenarios**: {{ scenarios | length }}
- **Passed**: {{ scenarios | selectattr('status', 'equalto', 'passed') | list | length }}
- **Failed**: {{ scenarios | selectattr('status', 'equalto', 'failed') | list | length }}
- **Total Duration**: {{ scenarios | sum(attribute='duration') }}ms
- **Average Duration**: {{ (scenarios | sum(attribute='duration') / scenarios | length) | round(1) }}ms

## Coverage Metrics
- **Statements**: {{ coverage.statements }}%
- **Branches**: {{ coverage.branches }}%
- **Functions**: {{ coverage.functions }}%
- **Lines**: {{ coverage.lines }}%

## Test Scenarios
{% for scenario in scenarios %}
### {{ scenario.name | title }}
- **Status**: {% if scenario.status == 'passed' %}✅ Passed{% else %}❌ Failed{% endif %}
- **Duration**: {{ scenario.duration }}ms
- **Performance**: {% if scenario.duration < 30 %}🚀 Excellent{% elif scenario.duration < 60 %}⚡ Good{% else %}🐌 Slow{% endif %}
{% endfor %}

## Quality Assessment
- **Overall Status**: {% if scenarios | selectattr('status', 'equalto', 'passed') | list | length == scenarios | length %}✅ All Tests Passed{% else %}❌ Some Tests Failed{% endif %}
- **Coverage Status**: {% if coverage.lines >= 95 %}✅ Excellent Coverage{% elif coverage.lines >= 90 %}⚡ Good Coverage{% else %}⚠️ Needs Improvement{% endif %}
- **Performance Status**: {% if (scenarios | sum(attribute='duration') / scenarios | length) < 50 %}🚀 Excellent Performance{% elif (scenarios | sum(attribute='duration') / scenarios | length) < 100 %}⚡ Good Performance{% else %}🐌 Needs Optimization{% endif %}

---
*Quality report generated by GitVan Workflow System*`,
              filePath: "./reports/quality-assurance-report.md"
            }
          };

          const qaResult = await stepRunner.executeStep(
            qaStep,
            contextManager,
            null,
            null
          );

          expect(qaResult.success).toBe(true);
          const qaContent = qaResult.outputs.content;
          expect(qaContent).toContain("# Quality Assurance Report");
          expect(qaContent).toContain("Total Scenarios: 4");
          expect(qaContent).toContain("Passed: 4");
          expect(qaContent).toContain("Failed: 0");
          expect(qaContent).toContain("Total Duration: 147ms");
          expect(qaContent).toContain("Average Duration: 36.8ms");
          expect(qaContent).toContain("Statements: 98%");
          expect(qaContent).toContain("✅ All Tests Passed");
          expect(qaContent).toContain("✅ Excellent Coverage");
          expect(qaContent).toContain("🚀 Excellent Performance");

          console.log("✅ JTBD: Quality assurance and validation workflows work");
        }
      );
    });
  });
});
