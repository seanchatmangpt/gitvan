{
    "sourceFile": "src/jobs/events.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758048967773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758090285401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n // src/jobs/events.mjs\n // GitVan v2 — Event-Driven Job System\n // Git-native event predicates and triggers\n \n-import { getEventJobs } from \"./scan.mjs\";\n+import { scanJobs } from \"./scan.mjs\";\n import { JobRunner } from \"./runner.mjs\";\n import { loadOptions } from \"../config/loader.mjs\";\n import { useGit } from \"../composables/git.mjs\";\n \n@@ -50,9 +50,9 @@\n    * Evaluate logical predicates (any/all)\n    */\n   async evaluateLogicalPredicate(operator, predicates, context) {\n     const results = await Promise.all(\n-      predicates.map((pred) => this.evaluatePredicates(pred, context)),\n+      predicates.map((pred) => this.evaluatePredicates(pred, context))\n     );\n \n     if (operator === \"any\") {\n       return results.some((result) => this.isPredicateTrue(result));\n@@ -77,9 +77,9 @@\n         return result.all === true;\n       }\n       // For other objects, check if any property is true\n       return Object.values(result).some((value) =>\n-        typeof value === \"boolean\" ? value : this.isPredicateTrue(value),\n+        typeof value === \"boolean\" ? value : this.isPredicateTrue(value)\n       );\n     }\n     return false;\n   }\n@@ -230,9 +230,9 @@\n       ]);\n \n       const files = changedFiles.split(\"\\n\").filter(Boolean);\n       return patterns.some((pattern) =>\n-        files.some((file) => this.matchesPattern(file, pattern)),\n+        files.some((file) => this.matchesPattern(file, pattern))\n       );\n     } catch {\n       return false;\n     }\n@@ -254,9 +254,9 @@\n       ]);\n \n       const files = addedFiles.split(\"\\n\").filter(Boolean);\n       return patterns.some((pattern) =>\n-        files.some((file) => this.matchesPattern(file, pattern)),\n+        files.some((file) => this.matchesPattern(file, pattern))\n       );\n     } catch {\n       return false;\n     }\n@@ -278,9 +278,9 @@\n       ]);\n \n       const files = modifiedFiles.split(\"\\n\").filter(Boolean);\n       return patterns.some((pattern) =>\n-        files.some((file) => this.matchesPattern(file, pattern)),\n+        files.some((file) => this.matchesPattern(file, pattern))\n       );\n     } catch {\n       return false;\n     }\n@@ -386,9 +386,9 @@\n    * Load event-driven jobs\n    */\n   async loadEventJobs() {\n     await this.init();\n-    const jobs = await getEventJobs({ cwd: this.config.rootDir });\n+    const jobs = await scanJobs({ cwd: this.config.rootDir });\n \n     this.eventJobs.clear();\n \n     for (const job of jobs) {\n@@ -407,18 +407,18 @@\n     for (const [jobId, job] of this.eventJobs) {\n       try {\n         const results = await this.evaluator.evaluatePredicates(\n           job.on,\n-          context,\n+          context\n         );\n \n         if (this.evaluator.isPredicateTrue(results)) {\n           jobsToRun.push(job);\n         }\n       } catch (error) {\n         console.warn(\n           `Failed to evaluate predicates for job ${jobId}:`,\n-          error.message,\n+          error.message\n         );\n       }\n     }\n \n@@ -469,9 +469,9 @@\n     for (const [jobId, job] of this.eventJobs) {\n       try {\n         const results = await this.evaluator.evaluatePredicates(\n           job.on,\n-          context,\n+          context\n         );\n         jobResults[jobId] = results;\n \n         if (this.evaluator.isPredicateTrue(results)) {\n"
                }
            ],
            "date": 1758048967773,
            "name": "Commit-0",
            "content": "// src/jobs/events.mjs\n// GitVan v2 — Event-Driven Job System\n// Git-native event predicates and triggers\n\nimport { getEventJobs } from \"./scan.mjs\";\nimport { JobRunner } from \"./runner.mjs\";\nimport { loadOptions } from \"../config/loader.mjs\";\nimport { useGit } from \"../composables/git.mjs\";\n\n/**\n * Event predicate evaluator\n */\nexport class EventEvaluator {\n  constructor(options = {}) {\n    this.options = options;\n    this.config = null;\n    this.runner = null;\n    this.git = null;\n  }\n\n  async init() {\n    this.config = await loadOptions();\n    this.runner = new JobRunner({\n      receiptsRef: this.config.receipts.ref,\n      hooks: this.config.hooks,\n    });\n    this.git = useGit();\n  }\n\n  /**\n   * Evaluate event predicates against git state\n   */\n  async evaluatePredicates(predicates, context = {}) {\n    const results = {};\n\n    for (const [key, value] of Object.entries(predicates)) {\n      if (key === \"any\" || key === \"all\") {\n        // Handle logical operators\n        results[key] = await this.evaluateLogicalPredicate(key, value, context);\n      } else {\n        // Handle individual predicates\n        results[key] = await this.evaluateSinglePredicate(key, value, context);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate logical predicates (any/all)\n   */\n  async evaluateLogicalPredicate(operator, predicates, context) {\n    const results = await Promise.all(\n      predicates.map((pred) => this.evaluatePredicates(pred, context)),\n    );\n\n    if (operator === \"any\") {\n      return results.some((result) => this.isPredicateTrue(result));\n    } else if (operator === \"all\") {\n      return results.every((result) => this.isPredicateTrue(result));\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if a predicate result is true\n   */\n  isPredicateTrue(result) {\n    if (typeof result === \"boolean\") return result;\n    if (typeof result === \"object\" && result !== null) {\n      // For logical operators, check the specific key\n      if (result.any !== undefined) {\n        return result.any === true;\n      }\n      if (result.all !== undefined) {\n        return result.all === true;\n      }\n      // For other objects, check if any property is true\n      return Object.values(result).some((value) =>\n        typeof value === \"boolean\" ? value : this.isPredicateTrue(value),\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Evaluate a single predicate\n   */\n  async evaluateSinglePredicate(type, value, context) {\n    switch (type) {\n      case \"tagCreate\":\n        return await this.evaluateTagCreate(value, context);\n      case \"semverTag\":\n        return await this.evaluateSemverTag(value, context);\n      case \"mergeTo\":\n        return await this.evaluateMergeTo(value, context);\n      case \"pushTo\":\n        return await this.evaluatePushTo(value, context);\n      case \"pathChanged\":\n        return await this.evaluatePathChanged(value, context);\n      case \"pathAdded\":\n        return await this.evaluatePathAdded(value, context);\n      case \"pathModified\":\n        return await this.evaluatePathModified(value, context);\n      case \"message\":\n        return await this.evaluateMessage(value, context);\n      case \"authorEmail\":\n        return await this.evaluateAuthorEmail(value, context);\n      case \"signed\":\n        return await this.evaluateSigned(value, context);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Evaluate tag creation predicate\n   */\n  async evaluateTagCreate(pattern, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      // Get the latest tag\n      const latestTag = await this.git.run([\n        \"describe\",\n        \"--tags\",\n        \"--abbrev=0\",\n        commit,\n      ]);\n      if (!latestTag) return false;\n\n      // Check if tag matches pattern\n      return this.matchesPattern(latestTag.trim(), pattern);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate semver tag predicate\n   */\n  async evaluateSemverTag(required, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      const latestTag = await this.git.run([\n        \"describe\",\n        \"--tags\",\n        \"--abbrev=0\",\n        commit,\n      ]);\n      if (!latestTag) return false;\n\n      // Check if tag follows semver pattern\n      const semverPattern =\n        /^v?(\\d+)\\.(\\d+)\\.(\\d+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?$/;\n      const isSemver = semverPattern.test(latestTag.trim());\n\n      return required ? isSemver : !isSemver;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate merge to branch predicate\n   */\n  async evaluateMergeTo(branch, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      // Check if this is a merge commit\n      const isMerge = await this.git.run([\n        \"rev-list\",\n        \"--merges\",\n        \"-n\",\n        \"1\",\n        commit,\n      ]);\n      if (!isMerge) return false;\n\n      // Get the merge target branch\n      const mergeTarget = await this.git.run([\n        \"log\",\n        \"--merges\",\n        \"-n\",\n        \"1\",\n        \"--pretty=%s\",\n        commit,\n      ]);\n\n      return (\n        mergeTarget.includes(`Merge branch '${branch}'`) ||\n        mergeTarget.includes(`Merge pull request`) ||\n        mergeTarget.includes(`into ${branch}`)\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate push to branch predicate\n   */\n  async evaluatePushTo(branch, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      // Get current branch\n      const currentBranch = await this.git.getCurrentBranch();\n      return currentBranch === branch;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate path changed predicate\n   */\n  async evaluatePathChanged(patterns, context) {\n    const { commit = \"HEAD\", previousCommit = \"HEAD~1\" } = context;\n\n    try {\n      const changedFiles = await this.git.run([\n        \"diff\",\n        \"--name-only\",\n        previousCommit,\n        commit,\n      ]);\n\n      const files = changedFiles.split(\"\\n\").filter(Boolean);\n      return patterns.some((pattern) =>\n        files.some((file) => this.matchesPattern(file, pattern)),\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate path added predicate\n   */\n  async evaluatePathAdded(patterns, context) {\n    const { commit = \"HEAD\", previousCommit = \"HEAD~1\" } = context;\n\n    try {\n      const addedFiles = await this.git.run([\n        \"diff\",\n        \"--name-only\",\n        \"--diff-filter=A\",\n        previousCommit,\n        commit,\n      ]);\n\n      const files = addedFiles.split(\"\\n\").filter(Boolean);\n      return patterns.some((pattern) =>\n        files.some((file) => this.matchesPattern(file, pattern)),\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate path modified predicate\n   */\n  async evaluatePathModified(patterns, context) {\n    const { commit = \"HEAD\", previousCommit = \"HEAD~1\" } = context;\n\n    try {\n      const modifiedFiles = await this.git.run([\n        \"diff\",\n        \"--name-only\",\n        \"--diff-filter=M\",\n        previousCommit,\n        commit,\n      ]);\n\n      const files = modifiedFiles.split(\"\\n\").filter(Boolean);\n      return patterns.some((pattern) =>\n        files.some((file) => this.matchesPattern(file, pattern)),\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate commit message predicate\n   */\n  async evaluateMessage(pattern, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      const message = await this.git.run([\n        \"log\",\n        \"-n\",\n        \"1\",\n        \"--pretty=%s\",\n        commit,\n      ]);\n\n      return this.matchesPattern(message.trim(), pattern);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate author email predicate\n   */\n  async evaluateAuthorEmail(pattern, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      const email = await this.git.run([\n        \"log\",\n        \"-n\",\n        \"1\",\n        \"--pretty=%ae\",\n        commit,\n      ]);\n\n      return this.matchesPattern(email.trim(), pattern);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate signed commit predicate\n   */\n  async evaluateSigned(required, context) {\n    const { commit = \"HEAD\" } = context;\n\n    try {\n      const signature = await this.git.run([\n        \"show\",\n        \"--show-signature\",\n        commit,\n      ]);\n\n      const isSigned = signature.includes(\"Good signature\");\n      return required ? isSigned : !isSigned;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Simple pattern matching (supports * wildcards)\n   */\n  matchesPattern(text, pattern) {\n    if (pattern.includes(\"*\")) {\n      const regex = new RegExp(\"^\" + pattern.replace(/\\*/g, \".*\") + \"$\");\n      return regex.test(text);\n    }\n    return text === pattern;\n  }\n}\n\n/**\n * Event-driven job runner\n */\nexport class EventJobRunner {\n  constructor(options = {}) {\n    this.options = options;\n    this.config = null;\n    this.runner = null;\n    this.evaluator = null;\n    this.eventJobs = new Map();\n  }\n\n  async init() {\n    this.config = await loadOptions();\n    this.runner = new JobRunner({\n      receiptsRef: this.config.receipts.ref,\n      hooks: this.config.hooks,\n    });\n    this.evaluator = new EventEvaluator();\n    await this.evaluator.init();\n  }\n\n  /**\n   * Load event-driven jobs\n   */\n  async loadEventJobs() {\n    await this.init();\n    const jobs = await getEventJobs({ cwd: this.config.rootDir });\n\n    this.eventJobs.clear();\n\n    for (const job of jobs) {\n      this.eventJobs.set(job.id, job);\n    }\n\n    console.log(`Loaded ${this.eventJobs.size} event-driven jobs`);\n  }\n\n  /**\n   * Check events and run matching jobs\n   */\n  async checkAndRunEventJobs(context = {}) {\n    const jobsToRun = [];\n\n    for (const [jobId, job] of this.eventJobs) {\n      try {\n        const results = await this.evaluator.evaluatePredicates(\n          job.on,\n          context,\n        );\n\n        if (this.evaluator.isPredicateTrue(results)) {\n          jobsToRun.push(job);\n        }\n      } catch (error) {\n        console.warn(\n          `Failed to evaluate predicates for job ${jobId}:`,\n          error.message,\n        );\n      }\n    }\n\n    if (jobsToRun.length === 0) {\n      return;\n    }\n\n    console.log(`Running ${jobsToRun.length} event-driven jobs`);\n\n    // Run jobs in parallel\n    const promises = jobsToRun.map(async (job) => {\n      try {\n        const result = await this.runner.runJob(job, {\n          trigger: {\n            kind: \"event\",\n            fingerprint: `event-${Date.now()}`,\n            data: {\n              predicates: job.on,\n              context,\n              triggeredAt: new Date().toISOString(),\n            },\n          },\n        });\n        console.log(`✅ Event job ${job.id} completed successfully`);\n        return result;\n      } catch (error) {\n        console.error(`❌ Event job ${job.id} failed:`, error.message);\n        throw error;\n      }\n    });\n\n    try {\n      await Promise.all(promises);\n    } catch (error) {\n      console.error(\"Some event jobs failed:\", error.message);\n    }\n  }\n\n  /**\n   * Dry run: show which jobs would run for given context\n   */\n  async dryRun(context = {}) {\n    await this.loadEventJobs();\n\n    const jobsToRun = [];\n    const jobResults = {};\n\n    for (const [jobId, job] of this.eventJobs) {\n      try {\n        const results = await this.evaluator.evaluatePredicates(\n          job.on,\n          context,\n        );\n        jobResults[jobId] = results;\n\n        if (this.evaluator.isPredicateTrue(results)) {\n          jobsToRun.push({\n            id: job.id,\n            predicates: job.on,\n            description: job.meta?.desc || \"No description\",\n          });\n        }\n      } catch (error) {\n        jobResults[jobId] = { error: error.message };\n      }\n    }\n\n    return {\n      context,\n      jobsToRun,\n      totalJobs: jobsToRun.length,\n      allResults: jobResults,\n    };\n  }\n\n  /**\n   * List all event jobs with their predicates\n   */\n  async listEventJobs() {\n    await this.loadEventJobs();\n\n    const jobs = [];\n\n    for (const [jobId, job] of this.eventJobs) {\n      jobs.push({\n        id: job.id,\n        predicates: job.on,\n        description: job.meta?.desc || \"No description\",\n        file: job.filePath,\n      });\n    }\n\n    return jobs;\n  }\n}\n\n/**\n * CLI for event operations\n */\nexport class EventCLI {\n  constructor() {\n    this.runner = null;\n  }\n\n  async init() {\n    this.runner = new EventJobRunner();\n    await this.runner.init();\n  }\n\n  /**\n   * List event jobs\n   */\n  async list() {\n    await this.init();\n    const jobs = await this.runner.listEventJobs();\n\n    if (jobs.length === 0) {\n      console.log(\"No event-driven jobs found\");\n      return;\n    }\n\n    console.log(\"Event-Driven Jobs:\");\n    console.log(\"ID\".padEnd(20) + \"PREDICATES\".padEnd(40) + \"DESCRIPTION\");\n    console.log(\"-\".repeat(80));\n\n    for (const job of jobs) {\n      const id = job.id.padEnd(20);\n      const predicates = JSON.stringify(job.predicates).padEnd(40);\n      const desc = job.description;\n      console.log(`${id}${predicates}${desc}`);\n    }\n  }\n\n  /**\n   * Dry run event jobs\n   */\n  async dryRun(context = {}) {\n    await this.init();\n    const result = await this.runner.dryRun(context);\n\n    console.log(`Event dry run:`);\n    console.log(`Context: ${JSON.stringify(result.context, null, 2)}`);\n\n    if (result.jobsToRun.length === 0) {\n      console.log(\"No jobs would run for this context\");\n      return;\n    }\n\n    console.log(`Would run ${result.totalJobs} jobs:`);\n    result.jobsToRun.forEach((job) => {\n      console.log(`  - ${job.id} - ${job.description}`);\n    });\n  }\n\n  /**\n   * Check and run event jobs\n   */\n  async check(context = {}) {\n    await this.init();\n    await this.runner.loadEventJobs();\n    await this.runner.checkAndRunEventJobs(context);\n  }\n}\n"
        }
    ]
}