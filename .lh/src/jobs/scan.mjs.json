{
    "sourceFile": "src/jobs/scan.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758048492138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758048492138,
            "name": "Commit-0",
            "content": "// src/jobs/scan.mjs\n// GitVan v2 â€” Job Discovery and Scanning\n// Discovers job files and creates job definitions\n\nimport { promises as fs } from \"node:fs\";\nimport { join, relative, resolve } from \"pathe\";\nimport { glob } from \"tinyglobby\";\nimport { createJobDefinition } from \"./define.mjs\";\n\n/**\n * Default job file patterns\n */\nconst DEFAULT_PATTERNS = [\"jobs/**/*.mjs\", \"jobs/**/*.js\", \"jobs/**/*.ts\"];\n\n/**\n * Job discovery options\n */\nconst DEFAULT_OPTIONS = {\n  patterns: DEFAULT_PATTERNS,\n  jobsDir: \"jobs\",\n  cwd: process.cwd(),\n  ignore: [\"**/node_modules/**\", \"**/.git/**\"],\n};\n\n/**\n * Scan for job files and create definitions\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of job definitions\n */\nexport async function scanJobs(options = {}) {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const jobs = [];\n\n  try {\n    // Find all job files\n    const files = await glob(opts.patterns, {\n      cwd: opts.cwd,\n      ignore: opts.ignore,\n      absolute: true,\n    });\n\n    // Process each file\n    for (const filePath of files) {\n      try {\n        const jobDef = await loadJobFromFile(filePath, opts);\n        if (jobDef) {\n          jobs.push(jobDef);\n        }\n      } catch (error) {\n        console.warn(`Failed to load job from ${filePath}:`, error.message);\n      }\n    }\n\n    // Sort by ID for consistent ordering\n    jobs.sort((a, b) => a.id.localeCompare(b.id));\n\n    return jobs;\n  } catch (error) {\n    throw new Error(`Job scanning failed: ${error.message}`);\n  }\n}\n\n/**\n * Load a single job from a file\n * @param {string} filePath - Full path to job file\n * @param {Object} options - Loading options\n * @returns {Promise<Object|null>} Job definition or null if invalid\n */\nasync function loadJobFromFile(filePath, options) {\n  try {\n    // Dynamic import the job file\n    const module = await import(filePath);\n\n    if (!module.default) {\n      throw new Error(\"Job file must export a default definition\");\n    }\n\n    const definition = module.default;\n\n    if (typeof definition !== \"object\" || definition === null) {\n      throw new Error(\"Job definition must be an object\");\n    }\n\n    if (typeof definition.run !== \"function\") {\n      throw new Error(\"Job definition must have a run function\");\n    }\n\n    // Create job definition with inferred properties\n    const jobDef = createJobDefinition(definition, filePath, options.jobsDir);\n\n    return jobDef;\n  } catch (error) {\n    throw new Error(`Failed to load job from ${filePath}: ${error.message}`);\n  }\n}\n\n/**\n * Get job by ID\n * @param {string} id - Job ID\n * @param {Object} options - Scanning options\n * @returns {Promise<Object|null>} Job definition or null if not found\n */\nexport async function getJobById(id, options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.find((job) => job.id === id) || null;\n}\n\n/**\n * Get jobs by mode\n * @param {string} mode - Job mode (on-demand, cron, event)\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of job definitions\n */\nexport async function getJobsByMode(mode, options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.mode === mode);\n}\n\n/**\n * Get jobs with cron schedules\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of cron job definitions\n */\nexport async function getCronJobs(options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.cron);\n}\n\n/**\n * Get event-driven jobs\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of event job definitions\n */\nexport async function getEventJobs(options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.on);\n}\n\n/**\n * Validate job definitions\n * @param {Object[]} jobs - Array of job definitions\n * @returns {Object} Validation result\n */\nexport function validateJobs(jobs) {\n  const errors = [];\n  const warnings = [];\n  const ids = new Set();\n\n  for (const job of jobs) {\n    // Check for duplicate IDs\n    if (ids.has(job.id)) {\n      errors.push(`Duplicate job ID: ${job.id}`);\n    }\n    ids.add(job.id);\n\n    // Check for required fields\n    if (!job.id) {\n      errors.push(`Job missing ID: ${job.filePath}`);\n    }\n\n    if (!job.run || typeof job.run !== \"function\") {\n      errors.push(`Job missing run function: ${job.id}`);\n    }\n\n    // Check mode consistency\n    if (job.mode === \"cron\" && !job.cron) {\n      warnings.push(`Cron job missing cron expression: ${job.id}`);\n    }\n\n    if (job.mode === \"event\" && !job.on) {\n      warnings.push(`Event job missing event predicates: ${job.id}`);\n    }\n\n    // Check for conflicting modes\n    if (job.cron && job.on) {\n      warnings.push(`Job has both cron and event triggers: ${job.id}`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n    count: jobs.length,\n  };\n}\n\n/**\n * Get job statistics\n * @param {Object[]} jobs - Array of job definitions\n * @returns {Object} Job statistics\n */\nexport function getJobStats(jobs) {\n  const stats = {\n    total: jobs.length,\n    byMode: {\n      \"on-demand\": 0,\n      cron: 0,\n      event: 0,\n    },\n    byKind: {\n      atomic: 0,\n      batch: 0,\n      daemon: 0,\n    },\n    withCron: 0,\n    withEvents: 0,\n    withMeta: 0,\n  };\n\n  for (const job of jobs) {\n    stats.byMode[job.mode]++;\n    stats.byKind[job.kind]++;\n\n    if (job.cron) stats.withCron++;\n    if (job.on) stats.withEvents++;\n    if (job.meta && Object.keys(job.meta).length > 0) stats.withMeta++;\n  }\n\n  return stats;\n}\n\n/**\n * List jobs in a formatted way\n * @param {Object[]} jobs - Array of job definitions\n * @param {Object} options - Formatting options\n * @returns {string} Formatted job list\n */\nexport function listJobs(jobs, options = {}) {\n  const { format = \"table\", showMeta = false } = options;\n\n  if (format === \"json\") {\n    return JSON.stringify(jobs, null, 2);\n  }\n\n  if (format === \"table\") {\n    const lines = [];\n    lines.push(\n      \"ID\".padEnd(20) +\n        \"MODE\".padEnd(12) +\n        \"KIND\".padEnd(8) +\n        \"CRON\".padEnd(15) +\n        \"DESCRIPTION\",\n    );\n    lines.push(\"-\".repeat(80));\n\n    for (const job of jobs) {\n      const id = job.id.padEnd(20);\n      const mode = job.mode.padEnd(12);\n      const kind = job.kind.padEnd(8);\n      const cron = (job.cron || \"\").padEnd(15);\n      const desc = job.meta?.desc || \"\";\n\n      lines.push(`${id}${mode}${kind}${cron}${desc}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  if (format === \"simple\") {\n    return jobs.map((job) => `${job.id} (${job.mode})`).join(\"\\n\");\n  }\n\n  throw new Error(`Unknown format: ${format}`);\n}\n"
        }
    ]
}