{
    "sourceFile": "src/utils/crypto.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1758072785037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758074170396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,61 +1,23 @@\n-/**\n- * GitVan v2 Crypto Utilities - Content hashing and fingerprinting\n- * Provides deterministic hashing for receipts and content verification\n- */\n+// src/utils/crypto.mjs\n+// Cryptographic utilities for hashing and fingerprinting\n \n-import { createHash } from \"node:crypto\";\n+import { createHash } from 'node:crypto';\n \n /**\n- * Generate SHA256 hash as hex string\n+ * Creates a SHA256 hex digest of a string or buffer.\n  * @param {string|Buffer} input - Input to hash\n- * @returns {string} SHA256 hash as hex\n+ * @returns {string} SHA256 hex digest\n  */\n export function sha256Hex(input) {\n-  return createHash(\"sha256\").update(input).digest(\"hex\");\n+  return createHash('sha256').update(String(input)).digest('hex');\n }\n \n /**\n- * Generate content fingerprint for deterministic identification\n+ * Creates a short, stable fingerprint of an object.\n  * @param {object} obj - Object to fingerprint\n- * @returns {string} Short fingerprint with fp_ prefix\n+ * @returns {string} Short fingerprint prefixed with 'fp_'\n  */\n export function fingerprint(obj) {\n-  const stable = JSON.stringify(obj, Object.keys(obj).sort());\n-  return \"fp_\" + sha256Hex(stable).slice(0, 16);\n-}\n-\n-/**\n- * Generate receipt hash for verification\n- * @param {object} receipt - Receipt object\n- * @returns {string} Receipt hash\n- */\n-export function receiptHash(receipt) {\n-  const { kind, id, status, ts, commit, action, env, outputHash, artifacts } = receipt;\n-  const content = JSON.stringify({\n-    kind, id, status, ts, commit, action, env, outputHash, artifacts\n-  });\n-  return sha256Hex(content);\n-}\n-\n-/**\n- * Generate job fingerprint for caching and identification\n- * @param {object} job - Job definition\n- * @returns {string} Job fingerprint\n- */\n-export function jobFingerprint(job) {\n-  const { id, kind, cron, meta, on, mode, filename, version } = job;\n-  return fingerprint({ id, kind, cron, meta, on, mode, filename, version });\n-}\n-\n-/**\n- * Generate deterministic seed for reproducible operations\n- * @param {string} base - Base string for seed\n- * @param {object} context - Additional context\n- * @returns {number} Deterministic seed\n- */\n-export function generateSeed(base, context = {}) {\n-  const content = JSON.stringify({ base, context });\n-  const hash = sha256Hex(content);\n-  return parseInt(hash.slice(0, 8), 16);\n-}\n-\n+  const stableString = JSON.stringify(obj, Object.keys(obj).sort());\n+  return `fp_${sha256Hex(stableString).slice(0, 16)}`;\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1758074170420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,282 @@\n-// src/utils/crypto.mjs\n-// Cryptographic utilities for hashing and fingerprinting\n+/**\n+ * GitVan v2 Crypto Utilities - Cryptographic operations and key management\n+ * Provides Ed25519 signing, verification, and secure key storage\n+ */\n \n-import { createHash } from 'node:crypto';\n+import {\n+  generateKeyPairSync,\n+  sign,\n+  verify,\n+  createHash,\n+  randomBytes\n+} from 'node:crypto';\n+import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'node:fs';\n+import { join } from 'node:path';\n \n /**\n- * Creates a SHA256 hex digest of a string or buffer.\n+ * Generate SHA256 hash as hex string\n  * @param {string|Buffer} input - Input to hash\n- * @returns {string} SHA256 hex digest\n\\ No newline at end of file\n+ * @returns {string} SHA256 hash as hex\n  */\n export function sha256Hex(input) {\n-  return createHash('sha256').update(String(input)).digest('hex');\n+  return createHash(\"sha256\").update(input).digest(\"hex\");\n }\n \n /**\n- * Creates a short, stable fingerprint of an object.\n+ * Generate content fingerprint for deterministic identification\n  * @param {object} obj - Object to fingerprint\n- * @returns {string} Short fingerprint prefixed with 'fp_'\n+ * @returns {string} Short fingerprint with fp_ prefix\n  */\n export function fingerprint(obj) {\n-  const stableString = JSON.stringify(obj, Object.keys(obj).sort());\n-  return `fp_${sha256Hex(stableString).slice(0, 16)}`;\n-}\n+  const stable = JSON.stringify(obj, Object.keys(obj).sort());\n+  return \"fp_\" + sha256Hex(stable).slice(0, 16);\n+}\n+\n+/**\n+ * Generate receipt hash for verification\n+ * @param {object} receipt - Receipt object\n+ * @returns {string} Receipt hash\n+ */\n+export function receiptHash(receipt) {\n+  const { kind, id, status, ts, commit, action, env, outputHash, artifacts } =\n+    receipt;\n+  const content = JSON.stringify({\n+    kind,\n+    id,\n+    status,\n+    ts,\n+    commit,\n+    action,\n+    env,\n+    outputHash,\n+    artifacts,\n+  });\n+  return sha256Hex(content);\n+}\n+\n+/**\n+ * Generate job fingerprint for caching and identification\n+ * @param {object} job - Job definition\n+ * @returns {string} Job fingerprint\n+ */\n+export function jobFingerprint(job) {\n+  const { id, kind, cron, meta, on, mode, filename, version } = job;\n+  return fingerprint({ id, kind, cron, meta, on, mode, filename, version });\n+}\n+\n+/**\n+ * Generate deterministic seed for reproducible operations\n+ * @param {string} base - Base string for seed\n+ * @param {object} context - Additional context\n+ * @returns {number} Deterministic seed\n+ */\n+export function generateSeed(base, context = {}) {\n+  const content = JSON.stringify({ base, context });\n+  const hash = sha256Hex(content);\n+  return parseInt(hash.slice(0, 8), 16);\n+}\n+\n+/**\n+ * Cryptographic utilities for GitVan\n+ * Provides Ed25519 key generation, signing, and verification\n+ */\n+export class CryptoManager {\n+  constructor(gitvanDir = '.gitvan') {\n+    this.gitvanDir = gitvanDir;\n+    this.keysDir = join(gitvanDir, 'keys');\n+    this.privateKeyPath = join(this.keysDir, 'private.pem');\n+    this.publicKeyPath = join(this.keysDir, 'public.pem');\n+\n+    // Ensure keys directory exists\n+    this.ensureKeysDirectory();\n+  }\n+\n+  /**\n+   * Generate Ed25519 key pair and store securely\n+   */\n+  generateKeyPair() {\n+    try {\n+      const { publicKey, privateKey } = generateKeyPairSync('ed25519', {\n+        publicKeyEncoding: {\n+          type: 'spki',\n+          format: 'pem'\n+        },\n+        privateKeyEncoding: {\n+          type: 'pkcs8',\n+          format: 'pem'\n+        }\n+      });\n+\n+      // Store keys securely\n+      writeFileSync(this.privateKeyPath, privateKey, { mode: 0o600 });\n+      writeFileSync(this.publicKeyPath, publicKey, { mode: 0o644 });\n+\n+      return {\n+        publicKey,\n+        privateKey,\n+        publicKeyPath: this.publicKeyPath,\n+        privateKeyPath: this.privateKeyPath\n+      };\n+    } catch (error) {\n+      throw new Error(`Failed to generate key pair: ${error.message}`);\n+    }\n+  }\n+\n+  /**\n+   * Load existing key pair from disk\n+   */\n+  loadKeyPair() {\n+    try {\n+      if (!this.hasKeyPair()) {\n+        throw new Error('No key pair found. Generate one first with generateKeyPair()');\n+      }\n+\n+      const privateKey = readFileSync(this.privateKeyPath, 'utf8');\n+      const publicKey = readFileSync(this.publicKeyPath, 'utf8');\n+\n+      return {\n+        publicKey,\n+        privateKey,\n+        publicKeyPath: this.publicKeyPath,\n+        privateKeyPath: this.privateKeyPath\n+      };\n+    } catch (error) {\n+      throw new Error(`Failed to load key pair: ${error.message}`);\n+    }\n+  }\n+\n+  /**\n+   * Check if key pair exists\n+   */\n+  hasKeyPair() {\n+    return existsSync(this.privateKeyPath) && existsSync(this.publicKeyPath);\n+  }\n+\n+  /**\n+   * Sign data using Ed25519 private key\n+   * @param {Object|string} data - Data to sign\n+   * @param {string} [privateKey] - Optional private key, uses stored if not provided\n+   */\n+  sign(data, privateKey = null) {\n+    try {\n+      const keyToUse = privateKey || this.loadKeyPair().privateKey;\n+\n+      // Convert object to canonical JSON string\n+      const dataString = typeof data === 'object' ?\n+        JSON.stringify(this.sortObject(data)) :\n+        String(data);\n+\n+      // Create signature\n+      const signature = sign(null, Buffer.from(dataString, 'utf8'), keyToUse);\n+\n+      return {\n+        algorithm: 'Ed25519',\n+        signature: signature.toString('base64'),\n+        timestamp: new Date().toISOString(),\n+        dataHash: createHash('sha256').update(dataString).digest('hex')\n+      };\n+    } catch (error) {\n+      throw new Error(`Failed to sign data: ${error.message}`);\n+    }\n+  }\n+\n+  /**\n+   * Verify signature using Ed25519 public key\n+   * @param {Object|string} data - Original data that was signed\n+   * @param {Object} signatureInfo - Signature information from sign()\n+   * @param {string} [publicKey] - Optional public key, uses stored if not provided\n+   */\n+  verify(data, signatureInfo, publicKey = null) {\n+    try {\n+      if (!signatureInfo || signatureInfo.algorithm !== 'Ed25519') {\n+        return false;\n+      }\n+\n+      const keyToUse = publicKey || this.loadKeyPair().publicKey;\n+\n+      // Convert object to canonical JSON string (same as signing)\n+      const dataString = typeof data === 'object' ?\n+        JSON.stringify(this.sortObject(data)) :\n+        String(data);\n+\n+      // Verify data hash matches\n+      const computedHash = createHash('sha256').update(dataString).digest('hex');\n+      if (computedHash !== signatureInfo.dataHash) {\n+        return false;\n+      }\n+\n+      // Verify signature\n+      const signatureBuffer = Buffer.from(signatureInfo.signature, 'base64');\n+      return verify(null, Buffer.from(dataString, 'utf8'), keyToUse, signatureBuffer);\n+    } catch (error) {\n+      // Verification failures should return false, not throw\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Generate secure random nonce\n+   */\n+  generateNonce(length = 32) {\n+    return randomBytes(length).toString('hex');\n+  }\n+\n+  /**\n+   * Hash data using SHA-256\n+   */\n+  hash(data) {\n+    const dataString = typeof data === 'object' ?\n+      JSON.stringify(this.sortObject(data)) :\n+      String(data);\n+    return createHash('sha256').update(dataString, 'utf8').digest('hex');\n+  }\n+\n+  /**\n+   * Sort object keys recursively for canonical representation\n+   */\n+  sortObject(obj) {\n+    if (Array.isArray(obj)) {\n+      return obj.map(item => this.sortObject(item));\n+    }\n+\n+    if (obj && typeof obj === 'object' && obj !== null) {\n+      const sorted = {};\n+      const keys = Object.keys(obj).sort();\n+      for (const key of keys) {\n+        sorted[key] = this.sortObject(obj[key]);\n+      }\n+      return sorted;\n+    }\n+\n+    return obj;\n+  }\n+\n+  /**\n+   * Ensure keys directory exists with proper permissions\n+   */\n+  ensureKeysDirectory() {\n+    try {\n+      if (!existsSync(this.gitvanDir)) {\n+        mkdirSync(this.gitvanDir, { recursive: true, mode: 0o755 });\n+      }\n+\n+      if (!existsSync(this.keysDir)) {\n+        mkdirSync(this.keysDir, { recursive: true, mode: 0o700 });\n+      }\n+    } catch (error) {\n+      throw new Error(`Failed to create keys directory: ${error.message}`);\n+    }\n+  }\n+\n+  /**\n+   * Get public key fingerprint for identification\n+   */\n+  getPublicKeyFingerprint(publicKey = null) {\n+    try {\n+      const keyToUse = publicKey || this.loadKeyPair().publicKey;\n+      return createHash('sha256').update(keyToUse).digest('hex').slice(0, 16);\n+    } catch (error) {\n+      throw new Error(`Failed to generate fingerprint: ${error.message}`);\n+    }\n+  }\n+}\n"
                }
            ],
            "date": 1758072785037,
            "name": "Commit-0",
            "content": "/**\n * GitVan v2 Crypto Utilities - Content hashing and fingerprinting\n * Provides deterministic hashing for receipts and content verification\n */\n\nimport { createHash } from \"node:crypto\";\n\n/**\n * Generate SHA256 hash as hex string\n * @param {string|Buffer} input - Input to hash\n * @returns {string} SHA256 hash as hex\n */\nexport function sha256Hex(input) {\n  return createHash(\"sha256\").update(input).digest(\"hex\");\n}\n\n/**\n * Generate content fingerprint for deterministic identification\n * @param {object} obj - Object to fingerprint\n * @returns {string} Short fingerprint with fp_ prefix\n */\nexport function fingerprint(obj) {\n  const stable = JSON.stringify(obj, Object.keys(obj).sort());\n  return \"fp_\" + sha256Hex(stable).slice(0, 16);\n}\n\n/**\n * Generate receipt hash for verification\n * @param {object} receipt - Receipt object\n * @returns {string} Receipt hash\n */\nexport function receiptHash(receipt) {\n  const { kind, id, status, ts, commit, action, env, outputHash, artifacts } = receipt;\n  const content = JSON.stringify({\n    kind, id, status, ts, commit, action, env, outputHash, artifacts\n  });\n  return sha256Hex(content);\n}\n\n/**\n * Generate job fingerprint for caching and identification\n * @param {object} job - Job definition\n * @returns {string} Job fingerprint\n */\nexport function jobFingerprint(job) {\n  const { id, kind, cron, meta, on, mode, filename, version } = job;\n  return fingerprint({ id, kind, cron, meta, on, mode, filename, version });\n}\n\n/**\n * Generate deterministic seed for reproducible operations\n * @param {string} base - Base string for seed\n * @param {object} context - Additional context\n * @returns {number} Deterministic seed\n */\nexport function generateSeed(base, context = {}) {\n  const content = JSON.stringify({ base, context });\n  const hash = sha256Hex(content);\n  return parseInt(hash.slice(0, 8), 16);\n}\n\n"
        }
    ]
}