{
    "sourceFile": "src/runtime/jobs.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758072822242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758072822242,
            "name": "Commit-0",
            "content": "import { readdirSync, statSync } from 'node:fs'\nimport { join, extname, resolve } from 'pathe'\n\n/**\n * Discovers jobs by scanning the jobs/ directory\n * Maps filesystem paths to job definitions and metadata\n */\nexport function discoverJobs(jobsDir) {\n  const jobs = []\n\n  if (!jobsDir) return jobs\n\n  // Check if jobs directory exists and is accessible\n  try {\n    const stat = statSync(jobsDir)\n    if (!stat.isDirectory()) return jobs\n  } catch {\n    return jobs\n  }\n\n  try {\n    scanDirectory(jobsDir, '', jobs)\n  } catch (err) {\n    // Jobs directory doesn't exist or isn't readable\n    return jobs\n  }\n\n  return jobs\n}\n\nfunction scanDirectory(baseDir, relativePath, jobs) {\n  const fullPath = join(baseDir, relativePath)\n  \n  try {\n    const entries = readdirSync(fullPath)\n    \n    for (const entry of entries) {\n      const entryPath = join(fullPath, entry)\n      const relativeEntryPath = join(relativePath, entry)\n      \n      try {\n        const stat = statSync(entryPath)\n        \n        if (stat.isDirectory()) {\n          // Recursively scan subdirectories\n          scanDirectory(baseDir, relativeEntryPath, jobs)\n        } else if (stat.isFile() && extname(entry) === '.mjs') {\n          // Found a job file\n          const jobId = relativeEntryPath.replace(/\\.mjs$/, '').replace(/\\\\/g, '/')\n          jobs.push({\n            id: jobId,\n            file: entryPath,\n            relativePath: relativeEntryPath,\n            name: entry.replace(/\\.mjs$/, ''),\n            directory: relativePath || '.'\n          })\n        }\n      } catch {\n        // Skip inaccessible files\n        continue\n      }\n    }\n  } catch {\n    // Directory not readable\n    return\n  }\n}\n\n/**\n * Find a specific job file by name\n */\nexport function findJobFile(jobsDir, jobName) {\n  const jobs = discoverJobs(jobsDir)\n  \n  // Try exact match first\n  let job = jobs.find(j => j.id === jobName || j.name === jobName)\n  \n  if (job) return job.file\n  \n  // Try partial matches\n  job = jobs.find(j => \n    j.id.includes(jobName) || \n    j.name.includes(jobName) ||\n    j.id.endsWith(`/${jobName}`)\n  )\n  \n  return job?.file || null\n}\n\n/**\n * Find all jobs in a directory\n */\nexport function findAllJobs(jobsDir) {\n  const jobs = discoverJobs(jobsDir)\n  return jobs.map(j => j.id)\n}\n\n/**\n * Load job definition from file\n */\nexport async function loadJobDefinition(jobFile) {\n  try {\n    const jobMod = await import(`file://${jobFile}`)\n    \n    // Job modules can export either:\n    // 1. A default function\n    // 2. A named export with metadata\n    // 3. Both\n    \n    if (jobMod.default && typeof jobMod.default === 'function') {\n      return {\n        run: jobMod.default,\n        meta: jobMod.meta || {},\n        ...jobMod\n      }\n    }\n    \n    // Look for common job export patterns\n    if (jobMod.run && typeof jobMod.run === 'function') {\n      return jobMod\n    }\n    \n    if (jobMod.job && typeof jobMod.job === 'function') {\n      return {\n        run: jobMod.job,\n        meta: jobMod.meta || {},\n        ...jobMod\n      }\n    }\n    \n    // If no clear run function, return the module as-is\n    return jobMod\n    \n  } catch (err) {\n    console.warn(`Failed to load job from ${jobFile}:`, err.message)\n    return null\n  }\n}\n\n/**\n * Get job metadata without loading the full module\n */\nexport function getJobMetadata(jobFile) {\n  try {\n    const stat = statSync(jobFile)\n    return {\n      file: jobFile,\n      size: stat.size,\n      modified: stat.mtime,\n      created: stat.birthtime\n    }\n  } catch {\n    return null\n  }\n}\n\n/**\n * Validate job definition structure\n */\nexport function validateJobDefinition(jobDef) {\n  if (!jobDef) return false\n  \n  // Must have a run function\n  if (typeof jobDef.run !== 'function') {\n    return false\n  }\n  \n  // Optional metadata validation\n  if (jobDef.meta) {\n    if (typeof jobDef.meta !== 'object') {\n      return false\n    }\n  }\n  \n  return true\n}\n\n"
        }
    ]
}