{
    "sourceFile": "docs/cookbook/foundation/configuration-management.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758051806635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758091414868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,9 +484,9 @@\n - [Error Handling](./error-handling.md) - Robust error handling patterns\n \n ## üìö **Resources**\n \n-- [GitVan Configuration Guide](../../docs/configuration.md)\n+- [GitVan Configuration Guide](../../reference/configuration.md)\n - [Environment Variables](../../docs/environment-variables.md)\n - [Security Best Practices](../../docs/security.md)\n \n ## ü§ù **Contributors**\n"
                }
            ],
            "date": 1758051806635,
            "name": "Commit-0",
            "content": "# Configuration Management\n\n## üéØ **Recipe Overview**\n\n**Category**: Foundation  \n**Difficulty**: Intermediate  \n**Time**: 30 minutes  \n**Prerequisites**: Basic GitVan knowledge, environment management experience\n\n## üìã **Problem**\n\nYou need to manage different configurations for development, staging, and production environments. You want a flexible system that allows environment-specific settings while maintaining consistency across deployments.\n\n## üç≥ **Solution**\n\n### **Step 1: Create Environment-Specific Configurations**\n\n```javascript\n// config/development.js\nexport default {\n  root: process.cwd(),\n  jobs: { dir: \"jobs\" },\n  templates: { \n    engine: \"nunjucks\", \n    dirs: [\"templates\"],\n    noCache: true  // Disable caching for development\n  },\n  receipts: { ref: \"refs/notes/gitvan/results\" },\n  hooks: {\n    \"job:before\"({ id, payload }) {\n      console.log(`üöÄ [DEV] Starting job: ${id}`);\n      if (payload && Object.keys(payload).length > 0) {\n        console.log(`üì¶ [DEV] Payload:`, payload);\n      }\n    },\n    \"job:after\"({ id, result }) {\n      console.log(`‚úÖ [DEV] Job completed: ${id} (${result.ok ? \"SUCCESS\" : \"FAILED\"})`);\n    },\n    \"job:error\"({ id, error }) {\n      console.error(`‚ùå [DEV] Job failed: ${id}`, error.message);\n    }\n  },\n  runtimeConfig: {\n    app: {\n      name: \"GitVan Development\",\n      environment: \"development\",\n      debug: true\n    },\n    gitvan: {\n      notesRef: \"refs/notes/gitvan/results\",\n      logLevel: \"debug\"\n    }\n  }\n};\n```\n\n```javascript\n// config/production.js\nexport default {\n  root: process.cwd(),\n  jobs: { dir: \"jobs\" },\n  templates: { \n    engine: \"nunjucks\", \n    dirs: [\"templates\"],\n    noCache: false  // Enable caching for production\n  },\n  receipts: { ref: \"refs/notes/gitvan/results\" },\n  hooks: {\n    \"job:before\"({ id, payload }) {\n      // Log to production logging system\n      logger.info(`Job started: ${id}`, { \n        payload: payload || {},\n        timestamp: new Date().toISOString()\n      });\n    },\n    \"job:after\"({ id, result }) {\n      // Log to production logging system\n      logger.info(`Job completed: ${id}`, { \n        success: result.ok,\n        artifacts: result.artifacts?.length || 0,\n        timestamp: new Date().toISOString()\n      });\n    },\n    \"job:error\"({ id, error }) {\n      // Log to production logging system\n      logger.error(`Job failed: ${id}`, { \n        error: error.message,\n        stack: error.stack,\n        timestamp: new Date().toISOString()\n      });\n    }\n  },\n  runtimeConfig: {\n    app: {\n      name: \"GitVan Production\",\n      environment: \"production\",\n      debug: false\n    },\n    gitvan: {\n      notesRef: \"refs/notes/gitvan/results\",\n      logLevel: \"info\"\n    }\n  }\n};\n```\n\n### **Step 2: Create Configuration Loader**\n\n```javascript\n// config/loader.mjs\nimport { loadOptions } from \"gitvan/config/loader\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport async function loadEnvironmentConfig(environment = \"development\") {\n  const configPath = join(process.cwd(), \"config\", `${environment}.js`);\n  \n  try {\n    // Check if environment-specific config exists\n    await fs.access(configPath);\n    \n    // Load environment-specific config\n    const envConfig = await import(configPath);\n    const baseConfig = await loadOptions();\n    \n    // Merge configurations\n    return {\n      ...baseConfig,\n      ...envConfig.default,\n      runtimeConfig: {\n        ...baseConfig.runtimeConfig,\n        ...envConfig.default.runtimeConfig\n      }\n    };\n  } catch (error) {\n    console.warn(`Environment config not found: ${configPath}`);\n    \n    // Fall back to base config\n    return await loadOptions();\n  }\n}\n\nexport function getEnvironment() {\n  return process.env.NODE_ENV || process.env.GITVAN_ENV || \"development\";\n}\n\nexport function isProduction() {\n  return getEnvironment() === \"production\";\n}\n\nexport function isDevelopment() {\n  return getEnvironment() === \"development\";\n}\n```\n\n### **Step 3: Create Environment-Aware Job**\n\n```javascript\n// jobs/config/environment-info.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { loadEnvironmentConfig, getEnvironment, isProduction } from \"../../config/loader.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Display environment configuration and information\",\n    tags: [\"config\", \"environment\", \"info\"]\n  },\n  async run({ ctx }) {\n    const git = useGit();\n    const environment = getEnvironment();\n    const config = await loadEnvironmentConfig(environment);\n    \n    // Get repository information\n    const head = await git.head();\n    const branch = await git.getCurrentBranch();\n    \n    // Create environment report\n    const report = {\n      environment,\n      timestamp: ctx.nowISO,\n      repository: {\n        head: head.substring(0, 8),\n        branch,\n        isClean: await git.isClean()\n      },\n      configuration: {\n        app: config.runtimeConfig.app,\n        gitvan: config.runtimeConfig.gitvan,\n        templates: {\n          engine: config.templates.engine,\n          noCache: config.templates.noCache\n        },\n        receipts: {\n          ref: config.receipts.ref\n        }\n      },\n      system: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        isProduction: isProduction(),\n        environmentVariables: {\n          NODE_ENV: process.env.NODE_ENV,\n          GITVAN_ENV: process.env.GITVAN_ENV\n        }\n      }\n    };\n    \n    // Log environment information\n    ctx.logger.log(`üåç Environment: ${environment}`);\n    ctx.logger.log(`üì¶ App: ${config.runtimeConfig.app.name}`);\n    ctx.logger.log(`üîß Debug: ${config.runtimeConfig.app.debug}`);\n    ctx.logger.log(`üìù Log Level: ${config.runtimeConfig.gitvan.logLevel}`);\n    \n    return {\n      ok: true,\n      artifacts: [],\n      data: report\n    };\n  }\n});\n```\n\n### **Step 4: Create Configuration Validation Job**\n\n```javascript\n// jobs/config/validate-config.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { loadEnvironmentConfig, getEnvironment } from \"../../config/loader.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Validate configuration for current environment\",\n    tags: [\"config\", \"validation\", \"environment\"]\n  },\n  async run({ ctx }) {\n    const environment = getEnvironment();\n    const config = await loadEnvironmentConfig(environment);\n    \n    const validation = {\n      environment,\n      timestamp: ctx.nowISO,\n      checks: []\n    };\n    \n    // Validate required configuration\n    const requiredFields = [\n      'root',\n      'jobs.dir',\n      'templates.engine',\n      'receipts.ref',\n      'runtimeConfig.app.name',\n      'runtimeConfig.gitvan.notesRef'\n    ];\n    \n    for (const field of requiredFields) {\n      const value = field.split('.').reduce((obj, key) => obj?.[key], config);\n      validation.checks.push({\n        field,\n        required: true,\n        present: value !== undefined,\n        value: value\n      });\n    }\n    \n    // Validate environment-specific settings\n    if (environment === \"production\") {\n      validation.checks.push({\n        field: \"templates.noCache\",\n        required: false,\n        present: true,\n        value: config.templates.noCache,\n        recommendation: config.templates.noCache ? \"Consider enabling caching for production\" : \"Good\"\n      });\n    }\n    \n    if (environment === \"development\") {\n      validation.checks.push({\n        field: \"templates.noCache\",\n        required: false,\n        present: true,\n        value: config.templates.noCache,\n        recommendation: config.templates.noCache ? \"Good for development\" : \"Consider disabling caching for development\"\n      });\n    }\n    \n    // Calculate validation results\n    const passed = validation.checks.filter(check => check.present).length;\n    const total = validation.checks.length;\n    const isValid = validation.checks.every(check => check.present);\n    \n    validation.summary = {\n      passed,\n      total,\n      isValid,\n      score: Math.round((passed / total) * 100)\n    };\n    \n    // Log validation results\n    ctx.logger.log(`üîç Configuration validation: ${isValid ? \"PASSED\" : \"FAILED\"}`);\n    ctx.logger.log(`üìä Score: ${validation.summary.score}% (${passed}/${total})`);\n    \n    if (!isValid) {\n      const failed = validation.checks.filter(check => !check.present);\n      ctx.logger.error(\"‚ùå Missing required configuration:\");\n      failed.forEach(check => {\n        ctx.logger.error(`  - ${check.field}`);\n      });\n    }\n    \n    return {\n      ok: isValid,\n      artifacts: [],\n      data: validation\n    };\n  }\n});\n```\n\n## üîç **Explanation**\n\n### **Configuration Hierarchy**\n\n1. **Base Configuration**: Default GitVan settings\n2. **Environment Configuration**: Environment-specific overrides\n3. **Runtime Configuration**: Dynamic configuration at runtime\n4. **Environment Variables**: System-level configuration\n\n### **Environment Detection**\n\n- **`NODE_ENV`**: Standard Node.js environment variable\n- **`GITVAN_ENV`**: GitVan-specific environment variable\n- **Fallback**: Defaults to \"development\"\n\n### **Configuration Merging**\n\n- **Base config**: Loaded first as foundation\n- **Environment config**: Merged on top for overrides\n- **Runtime config**: Merged for dynamic settings\n\n## üîÑ **Variations**\n\n### **Variation 1: Multi-Environment Deployment**\n\n```javascript\n// config/staging.js\nexport default {\n  root: process.cwd(),\n  jobs: { dir: \"jobs\" },\n  templates: { \n    engine: \"nunjucks\", \n    dirs: [\"templates\"],\n    noCache: false\n  },\n  receipts: { ref: \"refs/notes/gitvan/results\" },\n  hooks: {\n    \"job:before\"({ id }) {\n      console.log(`üöÄ [STAGING] Starting job: ${id}`);\n    },\n    \"job:after\"({ id, result }) {\n      console.log(`‚úÖ [STAGING] Job completed: ${id}`);\n    }\n  },\n  runtimeConfig: {\n    app: {\n      name: \"GitVan Staging\",\n      environment: \"staging\",\n      debug: false\n    },\n    gitvan: {\n      notesRef: \"refs/notes/gitvan/results\",\n      logLevel: \"warn\"\n    }\n  }\n};\n```\n\n### **Variation 2: Feature Flags**\n\n```javascript\n// config/feature-flags.js\nexport default {\n  runtimeConfig: {\n    app: {\n      features: {\n        enableAdvancedLogging: process.env.ENABLE_ADVANCED_LOGGING === \"true\",\n        enableMetrics: process.env.ENABLE_METRICS === \"true\",\n        enableDebugMode: process.env.ENABLE_DEBUG_MODE === \"true\"\n      }\n    }\n  }\n};\n```\n\n### **Variation 3: Dynamic Configuration**\n\n```javascript\n// jobs/config/dynamic-config.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { loadEnvironmentConfig } from \"../../config/loader.mjs\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Update configuration dynamically based on environment\",\n    tags: [\"config\", \"dynamic\", \"environment\"]\n  },\n  async run({ ctx }) {\n    const config = await loadEnvironmentConfig();\n    \n    // Dynamic configuration based on environment\n    if (config.runtimeConfig.app.environment === \"production\") {\n      // Production-specific settings\n      config.templates.noCache = false;\n      config.runtimeConfig.gitvan.logLevel = \"info\";\n    } else if (config.runtimeConfig.app.environment === \"development\") {\n      // Development-specific settings\n      config.templates.noCache = true;\n      config.runtimeConfig.gitvan.logLevel = \"debug\";\n    }\n    \n    // Apply dynamic configuration\n    const updatedConfig = {\n      ...config,\n      templates: {\n        ...config.templates,\n        noCache: config.templates.noCache\n      },\n      runtimeConfig: {\n        ...config.runtimeConfig,\n        gitvan: {\n          ...config.runtimeConfig.gitvan,\n          logLevel: config.runtimeConfig.gitvan.logLevel\n        }\n      }\n    };\n    \n    ctx.logger.log(\"üîß Dynamic configuration applied\");\n    ctx.logger.log(`üìù Cache enabled: ${!updatedConfig.templates.noCache}`);\n    ctx.logger.log(`üìä Log level: ${updatedConfig.runtimeConfig.gitvan.logLevel}`);\n    \n    return {\n      ok: true,\n      artifacts: [],\n      data: {\n        originalConfig: config,\n        updatedConfig,\n        changes: {\n          noCache: config.templates.noCache !== updatedConfig.templates.noCache,\n          logLevel: config.runtimeConfig.gitvan.logLevel !== updatedConfig.runtimeConfig.gitvan.logLevel\n        }\n      }\n    };\n  }\n});\n```\n\n## üéØ **Best Practices**\n\n### **Configuration Management**\n- **Environment separation**: Keep configurations separate by environment\n- **Validation**: Always validate configuration before use\n- **Defaults**: Provide sensible defaults for all settings\n- **Documentation**: Document all configuration options\n\n### **Security**\n- **Secrets management**: Never commit secrets to configuration files\n- **Environment variables**: Use environment variables for sensitive data\n- **Access control**: Restrict access to production configurations\n\n### **Performance**\n- **Caching**: Enable caching in production, disable in development\n- **Logging levels**: Use appropriate logging levels per environment\n- **Resource limits**: Set appropriate resource limits per environment\n\n### **Maintenance**\n- **Version control**: Keep configurations in version control\n- **Change tracking**: Track configuration changes\n- **Rollback capability**: Maintain ability to rollback configurations\n\n## üîó **Related Recipes**\n\n- [Basic Job Setup](./basic-job-setup.md) - Getting started with jobs\n- [Template System](./template-system.md) - Advanced template usage\n- [Error Handling](./error-handling.md) - Robust error handling patterns\n\n## üìö **Resources**\n\n- [GitVan Configuration Guide](../../docs/configuration.md)\n- [Environment Variables](../../docs/environment-variables.md)\n- [Security Best Practices](../../docs/security.md)\n\n## ü§ù **Contributors**\n\n- **Author**: GitVan Team\n- **Last Updated**: 2024-09-16\n- **Version**: 1.0.0\n\n---\n\n**Next Recipe**: [Template System](./template-system.md)\n"
        }
    ]
}