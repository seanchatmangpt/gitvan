{
    "sourceFile": "src/jobs/scan.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758048492138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758072825325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,265 +1,80 @@\n-// src/jobs/scan.mjs\n-// GitVan v2 — Job Discovery and Scanning\n-// Discovers job files and creates job definitions\n-\n-import { promises as fs } from \"node:fs\";\n-import { join, relative, resolve } from \"pathe\";\n-import { glob } from \"tinyglobby\";\n-import { createJobDefinition } from \"./define.mjs\";\n-\n /**\n- * Default job file patterns\n+ * GitVan v2 Job Scanner - Job discovery and scanning utilities\n+ * Provides functions for discovering and scanning jobs across the filesystem\n  */\n-const DEFAULT_PATTERNS = [\"jobs/**/*.mjs\", \"jobs/**/*.js\", \"jobs/**/*.ts\"];\n \n-/**\n- * Job discovery options\n- */\n-const DEFAULT_OPTIONS = {\n-  patterns: DEFAULT_PATTERNS,\n-  jobsDir: \"jobs\",\n-  cwd: process.cwd(),\n-  ignore: [\"**/node_modules/**\", \"**/.git/**\"],\n-};\n+import { discoverJobs, loadJobDefinition } from \"../runtime/jobs.mjs\";\n+import { createLogger } from \"../utils/logger.mjs\";\n+import { join } from \"pathe\";\n \n+const logger = createLogger(\"job-scanner\");\n+\n /**\n- * Scan for job files and create definitions\n- * @param {Object} options - Scanning options\n- * @returns {Promise<Object[]>} Array of job definitions\n+ * Scan jobs in a directory\n+ * @param {object} options - Scan options\n+ * @returns {Promise<Array>} Array of job definitions\n  */\n export async function scanJobs(options = {}) {\n-  const opts = { ...DEFAULT_OPTIONS, ...options };\n-  const jobs = [];\n+  const { cwd = process.cwd() } = options;\n+  const jobsDir = join(cwd, \"jobs\");\n+  \n+  const allJobs = discoverJobs(jobsDir);\n+  const scannedJobs = [];\n \n-  try {\n-    // Find all job files\n-    const files = await glob(opts.patterns, {\n-      cwd: opts.cwd,\n-      ignore: opts.ignore,\n-      absolute: true,\n-    });\n-\n-    // Process each file\n-    for (const filePath of files) {\n-      try {\n-        const jobDef = await loadJobFromFile(filePath, opts);\n-        if (jobDef) {\n-          jobs.push(jobDef);\n-        }\n-      } catch (error) {\n-        console.warn(`Failed to load job from ${filePath}:`, error.message);\n+  for (const jobInfo of allJobs) {\n+    try {\n+      const jobDef = await loadJobDefinition(jobInfo.file);\n+      if (jobDef) {\n+        scannedJobs.push({\n+          ...jobInfo,\n+          definition: jobDef,\n+          cron: jobDef.cron,\n+          meta: jobDef.meta || {},\n+          hasRun: typeof jobDef.run === 'function'\n+        });\n       }\n+    } catch (error) {\n+      logger.warn(`Failed to scan job ${jobInfo.id}:`, error.message);\n     }\n-\n-    // Sort by ID for consistent ordering\n-    jobs.sort((a, b) => a.id.localeCompare(b.id));\n-\n-    return jobs;\n-  } catch (error) {\n-    throw new Error(`Job scanning failed: ${error.message}`);\n   }\n-}\n \n-/**\n- * Load a single job from a file\n- * @param {string} filePath - Full path to job file\n- * @param {Object} options - Loading options\n- * @returns {Promise<Object|null>} Job definition or null if invalid\n- */\n-async function loadJobFromFile(filePath, options) {\n-  try {\n-    // Dynamic import the job file\n-    const module = await import(filePath);\n-\n-    if (!module.default) {\n-      throw new Error(\"Job file must export a default definition\");\n-    }\n-\n-    const definition = module.default;\n-\n-    if (typeof definition !== \"object\" || definition === null) {\n-      throw new Error(\"Job definition must be an object\");\n-    }\n-\n-    if (typeof definition.run !== \"function\") {\n-      throw new Error(\"Job definition must have a run function\");\n-    }\n-\n-    // Create job definition with inferred properties\n-    const jobDef = createJobDefinition(definition, filePath, options.jobsDir);\n-\n-    return jobDef;\n-  } catch (error) {\n-    throw new Error(`Failed to load job from ${filePath}: ${error.message}`);\n-  }\n+  return scannedJobs;\n }\n \n /**\n- * Get job by ID\n- * @param {string} id - Job ID\n- * @param {Object} options - Scanning options\n- * @returns {Promise<Object|null>} Job definition or null if not found\n+ * Scan jobs with specific criteria\n+ * @param {object} options - Scan options\n+ * @param {object} criteria - Filter criteria\n+ * @returns {Promise<Array>} Filtered array of jobs\n  */\n-export async function getJobById(id, options = {}) {\n-  const jobs = await scanJobs(options);\n-  return jobs.find((job) => job.id === id) || null;\n-}\n-\n-/**\n- * Get jobs by mode\n- * @param {string} mode - Job mode (on-demand, cron, event)\n- * @param {Object} options - Scanning options\n- * @returns {Promise<Object[]>} Array of job definitions\n- */\n-export async function getJobsByMode(mode, options = {}) {\n-  const jobs = await scanJobs(options);\n-  return jobs.filter((job) => job.mode === mode);\n-}\n-\n-/**\n- * Get jobs with cron schedules\n- * @param {Object} options - Scanning options\n- * @returns {Promise<Object[]>} Array of cron job definitions\n- */\n-export async function getCronJobs(options = {}) {\n-  const jobs = await scanJobs(options);\n-  return jobs.filter((job) => job.cron);\n-}\n-\n-/**\n- * Get event-driven jobs\n- * @param {Object} options - Scanning options\n- * @returns {Promise<Object[]>} Array of event job definitions\n- */\n-export async function getEventJobs(options = {}) {\n-  const jobs = await scanJobs(options);\n-  return jobs.filter((job) => job.on);\n-}\n-\n-/**\n- * Validate job definitions\n- * @param {Object[]} jobs - Array of job definitions\n- * @returns {Object} Validation result\n- */\n-export function validateJobs(jobs) {\n-  const errors = [];\n-  const warnings = [];\n-  const ids = new Set();\n-\n-  for (const job of jobs) {\n-    // Check for duplicate IDs\n-    if (ids.has(job.id)) {\n-      errors.push(`Duplicate job ID: ${job.id}`);\n+export async function scanJobsWithCriteria(options = {}, criteria = {}) {\n+  const allJobs = await scanJobs(options);\n+  \n+  return allJobs.filter(job => {\n+    if (criteria.cron && !job.cron) return false;\n+    if (criteria.hasRun && !job.hasRun) return false;\n+    if (criteria.meta && criteria.meta.key) {\n+      if (!job.meta || !job.meta[criteria.meta.key]) return false;\n     }\n-    ids.add(job.id);\n-\n-    // Check for required fields\n-    if (!job.id) {\n-      errors.push(`Job missing ID: ${job.filePath}`);\n-    }\n-\n-    if (!job.run || typeof job.run !== \"function\") {\n-      errors.push(`Job missing run function: ${job.id}`);\n-    }\n-\n-    // Check mode consistency\n-    if (job.mode === \"cron\" && !job.cron) {\n-      warnings.push(`Cron job missing cron expression: ${job.id}`);\n-    }\n-\n-    if (job.mode === \"event\" && !job.on) {\n-      warnings.push(`Event job missing event predicates: ${job.id}`);\n-    }\n-\n-    // Check for conflicting modes\n-    if (job.cron && job.on) {\n-      warnings.push(`Job has both cron and event triggers: ${job.id}`);\n-    }\n-  }\n-\n-  return {\n-    valid: errors.length === 0,\n-    errors,\n-    warnings,\n-    count: jobs.length,\n-  };\n+    return true;\n+  });\n }\n \n /**\n  * Get job statistics\n- * @param {Object[]} jobs - Array of job definitions\n- * @returns {Object} Job statistics\n+ * @param {object} options - Scan options\n+ * @returns {Promise<object>} Job statistics\n  */\n-export function getJobStats(jobs) {\n+export async function getJobStats(options = {}) {\n+  const jobs = await scanJobs(options);\n+  \n   const stats = {\n     total: jobs.length,\n-    byMode: {\n-      \"on-demand\": 0,\n-      cron: 0,\n-      event: 0,\n-    },\n-    byKind: {\n-      atomic: 0,\n-      batch: 0,\n-      daemon: 0,\n-    },\n-    withCron: 0,\n-    withEvents: 0,\n-    withMeta: 0,\n+    withCron: jobs.filter(j => j.cron).length,\n+    withMeta: jobs.filter(j => j.meta && Object.keys(j.meta).length > 0).length,\n+    valid: jobs.filter(j => j.hasRun).length,\n+    invalid: jobs.filter(j => !j.hasRun).length\n   };\n \n-  for (const job of jobs) {\n-    stats.byMode[job.mode]++;\n-    stats.byKind[job.kind]++;\n-\n-    if (job.cron) stats.withCron++;\n-    if (job.on) stats.withEvents++;\n-    if (job.meta && Object.keys(job.meta).length > 0) stats.withMeta++;\n-  }\n-\n   return stats;\n-}\n-\n-/**\n- * List jobs in a formatted way\n- * @param {Object[]} jobs - Array of job definitions\n- * @param {Object} options - Formatting options\n- * @returns {string} Formatted job list\n- */\n-export function listJobs(jobs, options = {}) {\n-  const { format = \"table\", showMeta = false } = options;\n-\n-  if (format === \"json\") {\n-    return JSON.stringify(jobs, null, 2);\n-  }\n-\n-  if (format === \"table\") {\n-    const lines = [];\n-    lines.push(\n-      \"ID\".padEnd(20) +\n-        \"MODE\".padEnd(12) +\n-        \"KIND\".padEnd(8) +\n-        \"CRON\".padEnd(15) +\n-        \"DESCRIPTION\",\n-    );\n-    lines.push(\"-\".repeat(80));\n-\n-    for (const job of jobs) {\n-      const id = job.id.padEnd(20);\n-      const mode = job.mode.padEnd(12);\n-      const kind = job.kind.padEnd(8);\n-      const cron = (job.cron || \"\").padEnd(15);\n-      const desc = job.meta?.desc || \"\";\n-\n-      lines.push(`${id}${mode}${kind}${cron}${desc}`);\n-    }\n-\n-    return lines.join(\"\\n\");\n-  }\n-\n-  if (format === \"simple\") {\n-    return jobs.map((job) => `${job.id} (${job.mode})`).join(\"\\n\");\n-  }\n-\n-  throw new Error(`Unknown format: ${format}`);\n-}\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1758048492138,
            "name": "Commit-0",
            "content": "// src/jobs/scan.mjs\n// GitVan v2 — Job Discovery and Scanning\n// Discovers job files and creates job definitions\n\nimport { promises as fs } from \"node:fs\";\nimport { join, relative, resolve } from \"pathe\";\nimport { glob } from \"tinyglobby\";\nimport { createJobDefinition } from \"./define.mjs\";\n\n/**\n * Default job file patterns\n */\nconst DEFAULT_PATTERNS = [\"jobs/**/*.mjs\", \"jobs/**/*.js\", \"jobs/**/*.ts\"];\n\n/**\n * Job discovery options\n */\nconst DEFAULT_OPTIONS = {\n  patterns: DEFAULT_PATTERNS,\n  jobsDir: \"jobs\",\n  cwd: process.cwd(),\n  ignore: [\"**/node_modules/**\", \"**/.git/**\"],\n};\n\n/**\n * Scan for job files and create definitions\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of job definitions\n */\nexport async function scanJobs(options = {}) {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const jobs = [];\n\n  try {\n    // Find all job files\n    const files = await glob(opts.patterns, {\n      cwd: opts.cwd,\n      ignore: opts.ignore,\n      absolute: true,\n    });\n\n    // Process each file\n    for (const filePath of files) {\n      try {\n        const jobDef = await loadJobFromFile(filePath, opts);\n        if (jobDef) {\n          jobs.push(jobDef);\n        }\n      } catch (error) {\n        console.warn(`Failed to load job from ${filePath}:`, error.message);\n      }\n    }\n\n    // Sort by ID for consistent ordering\n    jobs.sort((a, b) => a.id.localeCompare(b.id));\n\n    return jobs;\n  } catch (error) {\n    throw new Error(`Job scanning failed: ${error.message}`);\n  }\n}\n\n/**\n * Load a single job from a file\n * @param {string} filePath - Full path to job file\n * @param {Object} options - Loading options\n * @returns {Promise<Object|null>} Job definition or null if invalid\n */\nasync function loadJobFromFile(filePath, options) {\n  try {\n    // Dynamic import the job file\n    const module = await import(filePath);\n\n    if (!module.default) {\n      throw new Error(\"Job file must export a default definition\");\n    }\n\n    const definition = module.default;\n\n    if (typeof definition !== \"object\" || definition === null) {\n      throw new Error(\"Job definition must be an object\");\n    }\n\n    if (typeof definition.run !== \"function\") {\n      throw new Error(\"Job definition must have a run function\");\n    }\n\n    // Create job definition with inferred properties\n    const jobDef = createJobDefinition(definition, filePath, options.jobsDir);\n\n    return jobDef;\n  } catch (error) {\n    throw new Error(`Failed to load job from ${filePath}: ${error.message}`);\n  }\n}\n\n/**\n * Get job by ID\n * @param {string} id - Job ID\n * @param {Object} options - Scanning options\n * @returns {Promise<Object|null>} Job definition or null if not found\n */\nexport async function getJobById(id, options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.find((job) => job.id === id) || null;\n}\n\n/**\n * Get jobs by mode\n * @param {string} mode - Job mode (on-demand, cron, event)\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of job definitions\n */\nexport async function getJobsByMode(mode, options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.mode === mode);\n}\n\n/**\n * Get jobs with cron schedules\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of cron job definitions\n */\nexport async function getCronJobs(options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.cron);\n}\n\n/**\n * Get event-driven jobs\n * @param {Object} options - Scanning options\n * @returns {Promise<Object[]>} Array of event job definitions\n */\nexport async function getEventJobs(options = {}) {\n  const jobs = await scanJobs(options);\n  return jobs.filter((job) => job.on);\n}\n\n/**\n * Validate job definitions\n * @param {Object[]} jobs - Array of job definitions\n * @returns {Object} Validation result\n */\nexport function validateJobs(jobs) {\n  const errors = [];\n  const warnings = [];\n  const ids = new Set();\n\n  for (const job of jobs) {\n    // Check for duplicate IDs\n    if (ids.has(job.id)) {\n      errors.push(`Duplicate job ID: ${job.id}`);\n    }\n    ids.add(job.id);\n\n    // Check for required fields\n    if (!job.id) {\n      errors.push(`Job missing ID: ${job.filePath}`);\n    }\n\n    if (!job.run || typeof job.run !== \"function\") {\n      errors.push(`Job missing run function: ${job.id}`);\n    }\n\n    // Check mode consistency\n    if (job.mode === \"cron\" && !job.cron) {\n      warnings.push(`Cron job missing cron expression: ${job.id}`);\n    }\n\n    if (job.mode === \"event\" && !job.on) {\n      warnings.push(`Event job missing event predicates: ${job.id}`);\n    }\n\n    // Check for conflicting modes\n    if (job.cron && job.on) {\n      warnings.push(`Job has both cron and event triggers: ${job.id}`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n    count: jobs.length,\n  };\n}\n\n/**\n * Get job statistics\n * @param {Object[]} jobs - Array of job definitions\n * @returns {Object} Job statistics\n */\nexport function getJobStats(jobs) {\n  const stats = {\n    total: jobs.length,\n    byMode: {\n      \"on-demand\": 0,\n      cron: 0,\n      event: 0,\n    },\n    byKind: {\n      atomic: 0,\n      batch: 0,\n      daemon: 0,\n    },\n    withCron: 0,\n    withEvents: 0,\n    withMeta: 0,\n  };\n\n  for (const job of jobs) {\n    stats.byMode[job.mode]++;\n    stats.byKind[job.kind]++;\n\n    if (job.cron) stats.withCron++;\n    if (job.on) stats.withEvents++;\n    if (job.meta && Object.keys(job.meta).length > 0) stats.withMeta++;\n  }\n\n  return stats;\n}\n\n/**\n * List jobs in a formatted way\n * @param {Object[]} jobs - Array of job definitions\n * @param {Object} options - Formatting options\n * @returns {string} Formatted job list\n */\nexport function listJobs(jobs, options = {}) {\n  const { format = \"table\", showMeta = false } = options;\n\n  if (format === \"json\") {\n    return JSON.stringify(jobs, null, 2);\n  }\n\n  if (format === \"table\") {\n    const lines = [];\n    lines.push(\n      \"ID\".padEnd(20) +\n        \"MODE\".padEnd(12) +\n        \"KIND\".padEnd(8) +\n        \"CRON\".padEnd(15) +\n        \"DESCRIPTION\",\n    );\n    lines.push(\"-\".repeat(80));\n\n    for (const job of jobs) {\n      const id = job.id.padEnd(20);\n      const mode = job.mode.padEnd(12);\n      const kind = job.kind.padEnd(8);\n      const cron = (job.cron || \"\").padEnd(15);\n      const desc = job.meta?.desc || \"\";\n\n      lines.push(`${id}${mode}${kind}${cron}${desc}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  if (format === \"simple\") {\n    return jobs.map((job) => `${job.id} (${job.mode})`).join(\"\\n\");\n  }\n\n  throw new Error(`Unknown format: ${format}`);\n}\n"
        }
    ]
}