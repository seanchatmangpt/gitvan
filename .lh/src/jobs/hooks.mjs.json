{
    "sourceFile": "src/jobs/hooks.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758048967774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758048967774,
            "name": "Commit-0",
            "content": "// src/jobs/hooks.mjs\n// GitVan v2 ‚Äî Job Hooks System\n// Lifecycle hooks for job execution\n\nimport { createHooks } from \"hookable\";\n\n/**\n * Job hooks system\n * Provides lifecycle hooks for job execution\n */\nexport class JobHooks {\n  constructor() {\n    this.hooks = createHooks();\n    this.hookCounts = new Map();\n  }\n\n  /**\n   * Add a hook\n   */\n  hook(name, fn) {\n    this.hooks.hook(name, fn);\n    this.hookCounts.set(name, (this.hookCounts.get(name) || 0) + 1);\n  }\n\n  /**\n   * Remove a hook\n   */\n  unhook(name, fn) {\n    this.hooks.removeHook(name, fn);\n    const count = this.hookCounts.get(name) || 0;\n    if (count > 0) {\n      this.hookCounts.set(name, count - 1);\n    }\n  }\n\n  /**\n   * Call hooks\n   */\n  async callHook(name, ...args) {\n    return await this.hooks.callHook(name, ...args);\n  }\n\n  /**\n   * Call hooks in parallel\n   */\n  async callHookParallel(name, ...args) {\n    return await this.hooks.callHookParallel(name, ...args);\n  }\n\n  /**\n   * Get hook statistics\n   */\n  getStats() {\n    return {\n      totalHooks: Array.from(this.hookCounts.values()).reduce(\n        (a, b) => a + b,\n        0,\n      ),\n      hookCounts: Object.fromEntries(this.hookCounts),\n    };\n  }\n\n  /**\n   * List all registered hooks\n   */\n  listHooks() {\n    return Array.from(this.hookCounts.keys());\n  }\n}\n\n/**\n * Built-in job hooks\n */\nexport const JOB_HOOKS = {\n  // Job lifecycle hooks\n  \"job:before\": \"Called before job execution starts\",\n  \"job:after\": \"Called after job execution completes successfully\",\n  \"job:error\": \"Called when job execution fails\",\n\n  // Daemon hooks\n  \"daemon:start\": \"Called when daemon starts\",\n  \"daemon:stop\": \"Called when daemon stops\",\n  \"daemon:tick\": \"Called on each daemon tick\",\n\n  // Event hooks\n  \"event:detected\": \"Called when a git event is detected\",\n  \"event:processed\": \"Called after event jobs are processed\",\n\n  // Cron hooks\n  \"cron:schedule\": \"Called when cron jobs are scheduled\",\n  \"cron:execute\": \"Called when cron jobs are executed\",\n\n  // Receipt hooks\n  \"receipt:write\": \"Called when a job receipt is written\",\n  \"receipt:read\": \"Called when a job receipt is read\",\n\n  // Lock hooks\n  \"lock:acquire\": \"Called when a job lock is acquired\",\n  \"lock:release\": \"Called when a job lock is released\",\n  \"lock:fail\": \"Called when a job lock acquisition fails\",\n};\n\n/**\n * Default hook implementations\n */\nexport const DEFAULT_HOOKS = {\n  /**\n   * Log job execution\n   */\n  \"job:before\": async ({ id, payload, ctx }) => {\n    console.log(`üöÄ Starting job: ${id}`);\n    if (payload && Object.keys(payload).length > 0) {\n      console.log(`   Payload: ${JSON.stringify(payload)}`);\n    }\n  },\n\n  \"job:after\": async ({ id, result, ctx }) => {\n    console.log(`‚úÖ Job completed: ${id} (${result.duration}ms)`);\n    if (result.artifacts && result.artifacts.length > 0) {\n      console.log(`   Artifacts: ${result.artifacts.length}`);\n    }\n  },\n\n  \"job:error\": async ({ id, error, ctx }) => {\n    console.error(`‚ùå Job failed: ${id}`);\n    console.error(`   Error: ${error.message}`);\n  },\n\n  /**\n   * Log daemon events\n   */\n  \"daemon:start\": async () => {\n    console.log(\"üîÑ Daemon started\");\n  },\n\n  \"daemon:stop\": async () => {\n    console.log(\"‚èπÔ∏è Daemon stopped\");\n  },\n\n  \"event:detected\": async ({ from, to }) => {\n    console.log(`üì° Git event detected: ${from} ‚Üí ${to}`);\n  },\n\n  \"cron:execute\": async ({ jobs }) => {\n    console.log(`‚è∞ Executing ${jobs.length} cron jobs`);\n  },\n\n  /**\n   * Receipt logging\n   */\n  \"receipt:write\": async ({ id, note, ref }) => {\n    console.log(`üìù Receipt written for job: ${id}`);\n  },\n\n  /**\n   * Lock management\n   */\n  \"lock:acquire\": async ({ id, fingerprint }) => {\n    console.log(`üîí Lock acquired for job: ${id}`);\n  },\n\n  \"lock:release\": async ({ id }) => {\n    console.log(`üîì Lock released for job: ${id}`);\n  },\n\n  \"lock:fail\": async ({ id, reason }) => {\n    console.warn(`‚ö†Ô∏è Lock acquisition failed for job: ${id} - ${reason}`);\n  },\n};\n\n/**\n * Create a job hooks instance with default hooks\n */\nexport function createJobHooks(options = {}) {\n  const hooks = new JobHooks();\n\n  // Add default hooks if enabled\n  if (options.defaultHooks !== false) {\n    for (const [name, fn] of Object.entries(DEFAULT_HOOKS)) {\n      hooks.hook(name, fn);\n    }\n  }\n\n  // Add custom hooks from options\n  if (options.hooks) {\n    for (const [name, fn] of Object.entries(options.hooks)) {\n      hooks.hook(name, fn);\n    }\n  }\n\n  return hooks;\n}\n\n/**\n * Hook middleware for job execution\n */\nexport class JobHookMiddleware {\n  constructor(hooks) {\n    this.hooks = hooks;\n  }\n\n  /**\n   * Wrap job execution with hooks\n   */\n  async executeWithHooks(jobDef, executeFn, options = {}) {\n    const { payload = {}, ctx = {} } = options;\n\n    // Call before hook\n    await this.hooks.callHook(\"job:before\", {\n      id: jobDef.id,\n      payload,\n      ctx,\n    });\n\n    let result;\n    try {\n      // Execute the job\n      result = await executeFn();\n\n      // Call after hook\n      await this.hooks.callHook(\"job:after\", {\n        id: jobDef.id,\n        result,\n        ctx,\n      });\n\n      return result;\n    } catch (error) {\n      // Call error hook\n      await this.hooks.callHook(\"job:error\", {\n        id: jobDef.id,\n        error,\n        ctx,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Wrap daemon operations with hooks\n   */\n  async daemonWithHooks(operation, ...args) {\n    switch (operation) {\n      case \"start\":\n        await this.hooks.callHook(\"daemon:start\");\n        break;\n      case \"stop\":\n        await this.hooks.callHook(\"daemon:stop\");\n        break;\n      case \"tick\":\n        await this.hooks.callHook(\"daemon:tick\");\n        break;\n    }\n  }\n\n  /**\n   * Wrap event operations with hooks\n   */\n  async eventWithHooks(operation, data) {\n    switch (operation) {\n      case \"detected\":\n        await this.hooks.callHook(\"event:detected\", data);\n        break;\n      case \"processed\":\n        await this.hooks.callHook(\"event:processed\", data);\n        break;\n    }\n  }\n\n  /**\n   * Wrap cron operations with hooks\n   */\n  async cronWithHooks(operation, data) {\n    switch (operation) {\n      case \"schedule\":\n        await this.hooks.callHook(\"cron:schedule\", data);\n        break;\n      case \"execute\":\n        await this.hooks.callHook(\"cron:execute\", data);\n        break;\n    }\n  }\n\n  /**\n   * Wrap receipt operations with hooks\n   */\n  async receiptWithHooks(operation, data) {\n    switch (operation) {\n      case \"write\":\n        await this.hooks.callHook(\"receipt:write\", data);\n        break;\n      case \"read\":\n        await this.hooks.callHook(\"receipt:read\", data);\n        break;\n    }\n  }\n\n  /**\n   * Wrap lock operations with hooks\n   */\n  async lockWithHooks(operation, data) {\n    switch (operation) {\n      case \"acquire\":\n        await this.hooks.callHook(\"lock:acquire\", data);\n        break;\n      case \"release\":\n        await this.hooks.callHook(\"lock:release\", data);\n        break;\n      case \"fail\":\n        await this.hooks.callHook(\"lock:fail\", data);\n        break;\n    }\n  }\n}\n\n/**\n * CLI for hook management\n */\nexport class HookCLI {\n  constructor() {\n    this.hooks = createJobHooks();\n  }\n\n  /**\n   * List available hooks\n   */\n  list() {\n    console.log(\"Available Job Hooks:\");\n    console.log(\"=\".repeat(50));\n\n    for (const [name, description] of Object.entries(JOB_HOOKS)) {\n      const count = this.hooks.hookCounts.get(name) || 0;\n      console.log(`${name.padEnd(20)} - ${description} (${count} handlers)`);\n    }\n  }\n\n  /**\n   * Show hook statistics\n   */\n  stats() {\n    const stats = this.hooks.getStats();\n\n    console.log(\"Hook Statistics:\");\n    console.log(`  Total hooks: ${stats.totalHooks}`);\n    console.log(`  Hook types: ${Object.keys(stats.hookCounts).length}`);\n\n    if (Object.keys(stats.hookCounts).length > 0) {\n      console.log(\"\\nHook counts:\");\n      for (const [name, count] of Object.entries(stats.hookCounts)) {\n        console.log(`  ${name}: ${count}`);\n      }\n    }\n  }\n\n  /**\n   * Test a hook\n   */\n  async test(hookName, data = {}) {\n    if (!JOB_HOOKS[hookName]) {\n      console.error(`Unknown hook: ${hookName}`);\n      return;\n    }\n\n    console.log(`Testing hook: ${hookName}`);\n    console.log(`Data: ${JSON.stringify(data, null, 2)}`);\n\n    try {\n      await this.hooks.callHook(hookName, data);\n      console.log(\"‚úÖ Hook executed successfully\");\n    } catch (error) {\n      console.error(\"‚ùå Hook failed:\", error.message);\n    }\n  }\n}\n"
        }
    ]
}