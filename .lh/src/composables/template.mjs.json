{
    "sourceFile": "src/composables/template.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1758045809012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758046012307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,15 +2,12 @@\n // GitVan v2 â€” useTemplate() with inflection filters and config discovery\n \n import { promises as fs } from \"node:fs\";\n import { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\n-import nunjucks from \"nunjucks\";\n-import * as inflection from \"inflection\";\n import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n import { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n+import { getCachedEnvironment, envKey } from \"../utils/nunjucks-config.mjs\";\n \n-const _envCache = new Map(); // key -> nunjucks.Environment\n-\n /**\n  * Bind context and resolve template configuration\n  * Integrates with config discovery for robust template path resolution\n  */\n@@ -71,94 +68,8 @@\n   return { root, paths, autoescape, noCache, nowISO, ctx };\n }\n \n /**\n- * Generate cache key for environment instances\n- */\n-function envKey({ paths, autoescape, noCache }) {\n-  return JSON.stringify({ paths, autoescape, noCache });\n-}\n-\n-/**\n- * Create Nunjucks environment with all filters and guards\n- */\n-function createEnv({ paths, autoescape, noCache }) {\n-  const loader = new nunjucks.FileSystemLoader(paths, { noCache });\n-  const env = new nunjucks.Environment(loader, {\n-    autoescape,\n-    throwOnUndefined: true,\n-  });\n-\n-  // Determinism guards - prevent non-deterministic operations\n-  env.addGlobal(\"now\", () => {\n-    throw new Error(\"Templates must not call now(); inject a value.\");\n-  });\n-  env.addGlobal(\"random\", () => {\n-    throw new Error(\"Templates must not use random(); inject values.\");\n-  });\n-\n-  // Built-in pure filters\n-  env.addFilter(\"json\", (v, space = 0) => JSON.stringify(v, null, space));\n-  env.addFilter(\"slug\", (s) =>\n-    String(s)\n-      .toLowerCase()\n-      .replace(/[^a-z0-9]+/g, \"-\")\n-      .replace(/(^-|-$)/g, \"\"),\n-  );\n-  env.addFilter(\"upper\", (s) => String(s).toUpperCase());\n-  env.addFilter(\"lower\", (s) => String(s).toLowerCase());\n-  env.addFilter(\"pad\", (s, n = 2, ch = \"0\") => String(s).padStart(n, ch));\n-\n-  // Inflection filters (direct passthrough to inflection library)\n-  env.addFilter(\"pluralize\", (s, plural) =>\n-    inflection.pluralize(String(s), plural),\n-  );\n-  env.addFilter(\"singularize\", (s, singular) =>\n-    inflection.singularize(String(s), singular),\n-  );\n-  env.addFilter(\"inflect\", (s, count, singular, plural) =>\n-    inflection.inflect(String(s), Number(count), singular, plural),\n-  );\n-  env.addFilter(\"camelize\", (s, lowFirst = false) =>\n-    inflection.camelize(String(s), !!lowFirst),\n-  );\n-  env.addFilter(\"underscore\", (s, allUpper = false) =>\n-    inflection.underscore(String(s), !!allUpper),\n-  );\n-  env.addFilter(\"humanize\", (s, lowFirst = false) =>\n-    inflection.humanize(String(s), !!lowFirst),\n-  );\n-  env.addFilter(\"capitalize\", (s) => inflection.capitalize(String(s)));\n-  env.addFilter(\"dasherize\", (s) => inflection.dasherize(String(s)));\n-  env.addFilter(\"titleize\", (s) => inflection.titleize(String(s)));\n-  env.addFilter(\"demodulize\", (s) => inflection.demodulize(String(s)));\n-  env.addFilter(\"tableize\", (s) => inflection.tableize(String(s)));\n-  env.addFilter(\"classify\", (s) => inflection.classify(String(s)));\n-  env.addFilter(\"foreign_key\", (s, dropIdUBar = false) =>\n-    inflection.foreign_key(String(s), !!dropIdUBar),\n-  );\n-  env.addFilter(\"ordinalize\", (s) => inflection.ordinalize(String(s)));\n-  env.addFilter(\"transform\", (s, arr = []) =>\n-    inflection.transform(String(s), Array.isArray(arr) ? arr : [arr]),\n-  );\n-\n-  return env;\n-}\n-\n-/**\n- * Get or create cached environment instance\n- */\n-function getEnv(binding) {\n-  const key = envKey(binding);\n-  let env = _envCache.get(key);\n-  if (!env) {\n-    env = createEnv(binding);\n-    _envCache.set(key, env);\n-  }\n-  return env;\n-}\n-\n-/**\n  * Ensure directory exists for file output\n  */\n async function ensureDir(filePath) {\n   await fs.mkdir(dirname(filePath), { recursive: true });\n@@ -177,9 +88,13 @@\n  * @returns {Object} Template engine instance\n  */\n export async function useTemplate(opts = {}) {\n   const binding = await bindContext(opts);\n-  const env = getEnv(binding);\n+  const env = getCachedEnvironment({\n+    paths: binding.paths,\n+    autoescape: binding.autoescape,\n+    noCache: binding.noCache,\n+  });\n \n   /**\n    * Prepare base data for template rendering\n    * Includes context data and deterministic timestamps\n@@ -291,9 +206,13 @@\n   const nowISO =\n     typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n \n   const binding = { root, paths, autoescape, noCache, nowISO, ctx };\n-  const env = getEnv(binding);\n+  const env = getCachedEnvironment({\n+    paths: binding.paths,\n+    autoescape: binding.autoescape,\n+    noCache: binding.noCache,\n+  });\n \n   function baseData(extra) {\n     const common = {};\n     if (binding.nowISO) common.nowISO = binding.nowISO;\n"
                },
                {
                    "date": 1758046934671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,14 +3,14 @@\n \n import { promises as fs } from \"node:fs\";\n import { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\n import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n-import { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n-import { getCachedEnvironment, envKey } from \"../utils/nunjucks-config.mjs\";\n+import { loadOptions } from \"../config/loader.mjs\";\n+import { getCachedEnvironment } from \"../utils/nunjucks-config.mjs\";\n \n /**\n  * Bind context and resolve template configuration\n- * Integrates with config discovery for robust template path resolution\n+ * Integrates with new config system for robust template path resolution\n  */\n async function bindContext(opts = {}) {\n   let ctx;\n   try {\n@@ -20,53 +20,37 @@\n   }\n \n   const root = (ctx && ctx.cwd) || process.cwd();\n \n-  // Try to discover templates directory from config if not explicitly provided\n+  // Load configuration using new config system\n+  const config = await loadOptions({ rootDir: root });\n+\n+  // Resolve template paths\n   let templatePaths = [];\n   if (Array.isArray(opts.paths) && opts.paths.length) {\n     templatePaths = opts.paths;\n   } else {\n-    // Use config discovery to find templates directory\n-    const templatesResult = await findTemplatesDir(root);\n-    if (templatesResult) {\n-      templatePaths = [templatesResult.templatesDir];\n-\n-      // Merge discovered config with context config\n-      if (templatesResult.config && !ctx?.config) {\n-        ctx = ctx || {};\n-        ctx.config = templatesResult.config;\n-      }\n-    } else {\n-      // Fallback to context config or default\n-      const cfgDirs =\n-        (ctx &&\n-          ctx.config &&\n-          ctx.config.templates &&\n-          ctx.config.templates.dirs) ||\n-        [];\n-      templatePaths = cfgDirs.length ? cfgDirs : [\"templates\"];\n-    }\n+    // Use config templates directories\n+    templatePaths = config.templates.dirs.map((dir) => presolve(root, dir));\n   }\n \n-  // Resolve all paths relative to root\n-  const paths = templatePaths.map((p) => presolve(root, p));\n-\n-  // Configuration options with precedence: opts > ctx.config > defaults\n+  // Configuration options with precedence: opts > config > defaults\n   const autoescape =\n     typeof opts.autoescape === \"boolean\"\n       ? opts.autoescape\n-      : getConfigValue(ctx?.config, \"templates.autoescape\", false);\n+      : config.templates.autoescape;\n \n   const noCache =\n-    typeof opts.noCache === \"boolean\"\n-      ? opts.noCache\n-      : getConfigValue(ctx?.config, \"templates.noCache\", true);\n+    typeof opts.noCache === \"boolean\" ? opts.noCache : config.templates.noCache;\n \n   const nowISO =\n-    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n+    typeof ctx?.now === \"function\"\n+      ? ctx.now()\n+      : typeof config.now === \"function\"\n+        ? config.now()\n+        : process.env.GITVAN_NOW || null;\n \n-  return { root, paths, autoescape, noCache, nowISO, ctx };\n+  return { root, paths: templatePaths, autoescape, noCache, nowISO, ctx };\n }\n \n /**\n  * Ensure directory exists for file output\n@@ -181,28 +165,19 @@\n     ctx = tryUseGitVan?.() || null;\n   }\n \n   const root = (ctx && ctx.cwd) || process.cwd();\n-  const cfgDirs =\n-    (ctx && ctx.config && ctx.config.templates && ctx.config.templates.dirs) ||\n-    [];\n-  const paths = (\n-    Array.isArray(opts.paths) && opts.paths.length\n-      ? opts.paths\n-      : cfgDirs.length\n-        ? cfgDirs\n-        : [\"templates\"]\n-  ).map((p) => presolve(root, p));\n \n+  // Use default template configuration for sync version\n+  const templatePaths =\n+    Array.isArray(opts.paths) && opts.paths.length ? opts.paths : [\"templates\"];\n+\n+  const paths = templatePaths.map((p) => presolve(root, p));\n+\n   const autoescape =\n-    typeof opts.autoescape === \"boolean\"\n-      ? opts.autoescape\n-      : ((ctx && ctx.config?.templates?.autoescape) ?? false);\n+    typeof opts.autoescape === \"boolean\" ? opts.autoescape : false;\n \n-  const noCache =\n-    typeof opts.noCache === \"boolean\"\n-      ? opts.noCache\n-      : ((ctx && ctx.config?.templates?.noCache) ?? true);\n+  const noCache = typeof opts.noCache === \"boolean\" ? opts.noCache : true;\n \n   const nowISO =\n     typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n \n"
                }
            ],
            "date": 1758045809012,
            "name": "Commit-0",
            "content": "// src/composables/template.mjs\n// GitVan v2 â€” useTemplate() with inflection filters and config discovery\n\nimport { promises as fs } from \"node:fs\";\nimport { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\nimport nunjucks from \"nunjucks\";\nimport * as inflection from \"inflection\";\nimport { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\nimport { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n\nconst _envCache = new Map(); // key -> nunjucks.Environment\n\n/**\n * Bind context and resolve template configuration\n * Integrates with config discovery for robust template path resolution\n */\nasync function bindContext(opts = {}) {\n  let ctx;\n  try {\n    ctx = useGitVan();\n  } catch {\n    ctx = tryUseGitVan?.() || null;\n  }\n\n  const root = (ctx && ctx.cwd) || process.cwd();\n\n  // Try to discover templates directory from config if not explicitly provided\n  let templatePaths = [];\n  if (Array.isArray(opts.paths) && opts.paths.length) {\n    templatePaths = opts.paths;\n  } else {\n    // Use config discovery to find templates directory\n    const templatesResult = await findTemplatesDir(root);\n    if (templatesResult) {\n      templatePaths = [templatesResult.templatesDir];\n\n      // Merge discovered config with context config\n      if (templatesResult.config && !ctx?.config) {\n        ctx = ctx || {};\n        ctx.config = templatesResult.config;\n      }\n    } else {\n      // Fallback to context config or default\n      const cfgDirs =\n        (ctx &&\n          ctx.config &&\n          ctx.config.templates &&\n          ctx.config.templates.dirs) ||\n        [];\n      templatePaths = cfgDirs.length ? cfgDirs : [\"templates\"];\n    }\n  }\n\n  // Resolve all paths relative to root\n  const paths = templatePaths.map((p) => presolve(root, p));\n\n  // Configuration options with precedence: opts > ctx.config > defaults\n  const autoescape =\n    typeof opts.autoescape === \"boolean\"\n      ? opts.autoescape\n      : getConfigValue(ctx?.config, \"templates.autoescape\", false);\n\n  const noCache =\n    typeof opts.noCache === \"boolean\"\n      ? opts.noCache\n      : getConfigValue(ctx?.config, \"templates.noCache\", true);\n\n  const nowISO =\n    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n\n  return { root, paths, autoescape, noCache, nowISO, ctx };\n}\n\n/**\n * Generate cache key for environment instances\n */\nfunction envKey({ paths, autoescape, noCache }) {\n  return JSON.stringify({ paths, autoescape, noCache });\n}\n\n/**\n * Create Nunjucks environment with all filters and guards\n */\nfunction createEnv({ paths, autoescape, noCache }) {\n  const loader = new nunjucks.FileSystemLoader(paths, { noCache });\n  const env = new nunjucks.Environment(loader, {\n    autoescape,\n    throwOnUndefined: true,\n  });\n\n  // Determinism guards - prevent non-deterministic operations\n  env.addGlobal(\"now\", () => {\n    throw new Error(\"Templates must not call now(); inject a value.\");\n  });\n  env.addGlobal(\"random\", () => {\n    throw new Error(\"Templates must not use random(); inject values.\");\n  });\n\n  // Built-in pure filters\n  env.addFilter(\"json\", (v, space = 0) => JSON.stringify(v, null, space));\n  env.addFilter(\"slug\", (s) =>\n    String(s)\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"-\")\n      .replace(/(^-|-$)/g, \"\"),\n  );\n  env.addFilter(\"upper\", (s) => String(s).toUpperCase());\n  env.addFilter(\"lower\", (s) => String(s).toLowerCase());\n  env.addFilter(\"pad\", (s, n = 2, ch = \"0\") => String(s).padStart(n, ch));\n\n  // Inflection filters (direct passthrough to inflection library)\n  env.addFilter(\"pluralize\", (s, plural) =>\n    inflection.pluralize(String(s), plural),\n  );\n  env.addFilter(\"singularize\", (s, singular) =>\n    inflection.singularize(String(s), singular),\n  );\n  env.addFilter(\"inflect\", (s, count, singular, plural) =>\n    inflection.inflect(String(s), Number(count), singular, plural),\n  );\n  env.addFilter(\"camelize\", (s, lowFirst = false) =>\n    inflection.camelize(String(s), !!lowFirst),\n  );\n  env.addFilter(\"underscore\", (s, allUpper = false) =>\n    inflection.underscore(String(s), !!allUpper),\n  );\n  env.addFilter(\"humanize\", (s, lowFirst = false) =>\n    inflection.humanize(String(s), !!lowFirst),\n  );\n  env.addFilter(\"capitalize\", (s) => inflection.capitalize(String(s)));\n  env.addFilter(\"dasherize\", (s) => inflection.dasherize(String(s)));\n  env.addFilter(\"titleize\", (s) => inflection.titleize(String(s)));\n  env.addFilter(\"demodulize\", (s) => inflection.demodulize(String(s)));\n  env.addFilter(\"tableize\", (s) => inflection.tableize(String(s)));\n  env.addFilter(\"classify\", (s) => inflection.classify(String(s)));\n  env.addFilter(\"foreign_key\", (s, dropIdUBar = false) =>\n    inflection.foreign_key(String(s), !!dropIdUBar),\n  );\n  env.addFilter(\"ordinalize\", (s) => inflection.ordinalize(String(s)));\n  env.addFilter(\"transform\", (s, arr = []) =>\n    inflection.transform(String(s), Array.isArray(arr) ? arr : [arr]),\n  );\n\n  return env;\n}\n\n/**\n * Get or create cached environment instance\n */\nfunction getEnv(binding) {\n  const key = envKey(binding);\n  let env = _envCache.get(key);\n  if (!env) {\n    env = createEnv(binding);\n    _envCache.set(key, env);\n  }\n  return env;\n}\n\n/**\n * Ensure directory exists for file output\n */\nasync function ensureDir(filePath) {\n  await fs.mkdir(dirname(filePath), { recursive: true });\n}\n\n/**\n * GitVan Template Engine\n *\n * Provides template rendering with inflection filters, config discovery,\n * and deterministic environment for reproducible builds.\n *\n * @param {Object} opts - Template options\n * @param {string[]} opts.paths - Custom template paths (overrides config discovery)\n * @param {boolean} opts.autoescape - Enable HTML auto-escaping\n * @param {boolean} opts.noCache - Disable template caching\n * @returns {Object} Template engine instance\n */\nexport async function useTemplate(opts = {}) {\n  const binding = await bindContext(opts);\n  const env = getEnv(binding);\n\n  /**\n   * Prepare base data for template rendering\n   * Includes context data and deterministic timestamps\n   */\n  function baseData(extra) {\n    const common = {};\n    if (binding.nowISO) common.nowISO = binding.nowISO;\n    if (binding.ctx) common.git = binding.ctx;\n    return { ...common, ...(extra || {}) };\n  }\n\n  return {\n    /**\n     * Render template from file\n     * @param {string} templateName - Template file name\n     * @param {Object} data - Template data\n     * @returns {string} Rendered content\n     */\n    render(templateName, data = {}) {\n      return env.render(String(templateName), baseData(data));\n    },\n\n    /**\n     * Render template from string\n     * @param {string} templateStr - Template string\n     * @param {Object} data - Template data\n     * @returns {string} Rendered content\n     */\n    renderString(templateStr, data = {}) {\n      return env.renderString(String(templateStr), baseData(data));\n    },\n\n    /**\n     * Render template to file\n     * @param {string} templateName - Template file name\n     * @param {string} outPath - Output file path\n     * @param {Object} data - Template data\n     * @returns {Object} { path: string, bytes: number }\n     */\n    async renderToFile(templateName, outPath, data = {}) {\n      const abs = isAbsolute(outPath) ? outPath : join(binding.root, outPath);\n      await ensureDir(abs);\n      const text = env.render(String(templateName), baseData(data));\n      const buf = Buffer.from(text, \"utf8\");\n      await fs.writeFile(abs, buf);\n      return { path: outPath, bytes: buf.length };\n    },\n\n    /**\n     * Get the underlying Nunjucks environment\n     * @returns {nunjucks.Environment}\n     */\n    get env() {\n      return env;\n    },\n\n    /**\n     * Get template paths being used\n     * @returns {string[]}\n     */\n    get paths() {\n      return binding.paths;\n    },\n\n    /**\n     * Get root directory\n     * @returns {string}\n     */\n    get root() {\n      return binding.root;\n    },\n  };\n}\n\n/**\n * Synchronous version for backward compatibility\n * Note: This version cannot use config discovery and relies on context only\n */\nexport function useTemplateSync(opts = {}) {\n  let ctx;\n  try {\n    ctx = useGitVan();\n  } catch {\n    ctx = tryUseGitVan?.() || null;\n  }\n\n  const root = (ctx && ctx.cwd) || process.cwd();\n  const cfgDirs =\n    (ctx && ctx.config && ctx.config.templates && ctx.config.templates.dirs) ||\n    [];\n  const paths = (\n    Array.isArray(opts.paths) && opts.paths.length\n      ? opts.paths\n      : cfgDirs.length\n        ? cfgDirs\n        : [\"templates\"]\n  ).map((p) => presolve(root, p));\n\n  const autoescape =\n    typeof opts.autoescape === \"boolean\"\n      ? opts.autoescape\n      : ((ctx && ctx.config?.templates?.autoescape) ?? false);\n\n  const noCache =\n    typeof opts.noCache === \"boolean\"\n      ? opts.noCache\n      : ((ctx && ctx.config?.templates?.noCache) ?? true);\n\n  const nowISO =\n    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n\n  const binding = { root, paths, autoescape, noCache, nowISO, ctx };\n  const env = getEnv(binding);\n\n  function baseData(extra) {\n    const common = {};\n    if (binding.nowISO) common.nowISO = binding.nowISO;\n    if (binding.ctx) common.git = binding.ctx;\n    return { ...common, ...(extra || {}) };\n  }\n\n  return {\n    render(templateName, data = {}) {\n      return env.render(String(templateName), baseData(data));\n    },\n    renderString(templateStr, data = {}) {\n      return env.renderString(String(templateStr), baseData(data));\n    },\n    async renderToFile(templateName, outPath, data = {}) {\n      const abs = isAbsolute(outPath) ? outPath : join(binding.root, outPath);\n      await ensureDir(abs);\n      const text = env.render(String(templateName), baseData(data));\n      const buf = Buffer.from(text, \"utf8\");\n      await fs.writeFile(abs, buf);\n      return { path: outPath, bytes: buf.length };\n    },\n    get env() {\n      return env;\n    },\n    get paths() {\n      return binding.paths;\n    },\n    get root() {\n      return binding.root;\n    },\n  };\n}\n"
        }
    ]
}