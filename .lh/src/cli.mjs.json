{
    "sourceFile": "src/cli.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758057329115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758057329115,
            "name": "Commit-0",
            "content": "#!/usr/bin/env node\n\nimport { readFileSync, readdirSync, statSync } from \"node:fs\";\nimport { join, extname } from \"pathe\";\nimport { GitVanDaemon, startDaemon } from \"./runtime/daemon.mjs\";\nimport { discoverEvents, loadEventDefinition } from \"./runtime/events.mjs\";\nimport { readReceiptsRange } from \"./runtime/receipt.mjs\";\nimport { useGit } from \"./composables/git.mjs\";\nimport { runJobWithContext } from \"./runtime/boot.mjs\";\nimport { loadConfig } from \"./runtime/config.mjs\";\n\n// Import new CLI commands\nimport { cronCommand } from \"./cli/cron.mjs\";\nimport { daemonCommand } from \"./cli/daemon.mjs\";\nimport { eventCommand } from \"./cli/event.mjs\";\nimport { auditCommand } from \"./cli/audit.mjs\";\nimport { chatCommand } from \"./cli/chat.mjs\";\n\nconst commands = {\n  daemon: handleDaemon,\n  run: handleRun,\n  list: handleList,\n  event: handleEvent,\n  schedule: handleSchedule,\n  worktree: handleWorktree,\n  job: handleJob,\n  help: handleHelp,\n\n  // New v2 commands\n  cron: cronCommand,\n  audit: auditCommand,\n  chat: chatCommand,\n  llm: handleLLM,\n};\n\nasync function main() {\n  const [, , command, ...args] = process.argv;\n\n  if (!command || command === \"help\") {\n    handleHelp();\n    return;\n  }\n\n  const handler = commands[command];\n  if (!handler) {\n    console.error(`Unknown command: ${command}`);\n    handleHelp();\n    process.exit(1);\n  }\n\n  try {\n    await handler(...args);\n  } catch (err) {\n    console.error(\"Error:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function handleDaemon(action = \"start\", ...options) {\n  const worktreePath = process.cwd();\n\n  // Parse options\n  const opts = {};\n  for (let i = 0; i < options.length; i += 2) {\n    const key = options[i]?.replace(/^--/, \"\");\n    const value = options[i + 1];\n    if (key) opts[key] = value;\n  }\n\n  switch (action) {\n    case \"start\":\n      if (opts.worktrees === \"all\") {\n        console.log(\"Starting daemon for all worktrees...\");\n        await startDaemon({ rootDir: worktreePath }, null, \"all\");\n      } else {\n        const daemon = new GitVanDaemon(worktreePath);\n        await daemon.start();\n      }\n      break;\n    case \"stop\":\n      const daemon = new GitVanDaemon(worktreePath);\n      daemon.stop();\n      break;\n    case \"status\":\n      const statusDaemon = new GitVanDaemon(worktreePath);\n      console.log(\n        `Daemon ${statusDaemon.isRunning() ? \"running\" : \"not running\"} for: ${worktreePath}`,\n      );\n      break;\n    default:\n      console.error(`Unknown daemon action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleEvent(action = \"list\", ...args) {\n  // Use new event command handler\n  return await eventCommand(action, parseArgs(args));\n}\n\nfunction parseArgs(args) {\n  const parsed = {};\n  for (let i = 0; i < args.length; i += 2) {\n    const key = args[i]?.replace(/^--/, \"\");\n    const value = args[i + 1];\n    if (key) parsed[key] = value;\n  }\n  return parsed;\n}\n\nasync function handleSchedule(action = \"apply\") {\n  switch (action) {\n    case \"apply\":\n      console.log(\"Schedule management not yet implemented\");\n      // TODO: Implement cron-like scheduling\n      break;\n    default:\n      console.error(`Unknown schedule action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleWorktree(action = \"list\") {\n  switch (action) {\n    case \"list\":\n      try {\n        // We need to create a minimal context for Git operations\n        const ctx = {\n          root: process.cwd(),\n          env: process.env,\n          now: () => new Date().toISOString(),\n        };\n\n        const { withGitVan } = await import(\"./composables/ctx.mjs\");\n        await withGitVan(ctx, async () => {\n          const git = useGit();\n          const worktrees = git.listWorktrees();\n\n          if (worktrees.length === 0) {\n            console.log(\"No worktrees found\");\n            return;\n          }\n\n          console.log(\"\\nWorktrees:\");\n          console.log(\"==========\");\n          for (const wt of worktrees) {\n            console.log(`${wt.path} ${wt.isMain ? \"(main)\" : \"\"}`);\n            console.log(`  Branch: ${wt.branch || \"detached\"}`);\n            if (wt.head) console.log(`  HEAD: ${wt.head.slice(0, 8)}`);\n            console.log();\n          }\n        });\n      } catch (err) {\n        console.error(\"Error listing worktrees:\", err.message);\n      }\n      break;\n    default:\n      console.error(`Unknown worktree action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleJob(action = \"list\", ...args) {\n  switch (action) {\n    case \"list\":\n      console.log(\"Job listing not yet implemented\");\n      // TODO: Discover and list available jobs\n      break;\n    case \"run\":\n      const nameIndex = args.indexOf(\"--name\");\n      if (nameIndex === -1 || !args[nameIndex + 1]) {\n        console.error(\"Job name required: gitvan job run --name <job-name>\");\n        process.exit(1);\n      }\n      const jobName = args[nameIndex + 1];\n      console.log(`Running job: ${jobName}`);\n      // TODO: Implement job execution\n      break;\n    default:\n      console.error(`Unknown job action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleRun(jobName) {\n  if (!jobName) {\n    console.error(\"Job name required\");\n    process.exit(1);\n  }\n\n  const worktreePath = process.cwd();\n  const jobsDir = join(worktreePath, \"jobs\");\n  const jobPath = findJobFile(jobsDir, jobName);\n\n  if (!jobPath) {\n    console.error(`Job not found: ${jobName}`);\n    process.exit(1);\n  }\n\n  const jobMod = await import(`file://${jobPath}`);\n  const ctx = {\n    root: worktreePath,\n    env: process.env,\n    now: () => new Date().toISOString(),\n  };\n\n  console.log(`Running job: ${jobName}`);\n  const result = await runJobWithContext(ctx, jobMod);\n  console.log(\"Result:\", JSON.stringify(result, null, 2));\n}\n\nfunction handleList() {\n  const worktreePath = process.cwd();\n  const jobsDir = join(worktreePath, \"jobs\");\n\n  if (!statSync(jobsDir).isDirectory()) {\n    console.log(\"No jobs directory found\");\n    return;\n  }\n\n  const jobs = findAllJobs(jobsDir);\n  console.log(\"Available jobs:\");\n  jobs.forEach((job) => console.log(`  ${job}`));\n}\n\n// LLM command handler\nasync function handleLLM(subcommand = \"call\", ...args) {\n  const { generateText, checkAIAvailability } = await import(\n    \"./ai/provider.mjs\"\n  );\n  const { loadOptions } = await import(\"./config/loader.mjs\");\n\n  const config = await loadOptions();\n\n  switch (subcommand) {\n    case \"call\":\n      if (!args[0]) {\n        console.error('Prompt required: gitvan llm call \"<prompt>\"');\n        process.exit(1);\n      }\n\n      const prompt = args[0];\n      const model = args.includes(\"--model\")\n        ? args[args.indexOf(\"--model\") + 1]\n        : undefined;\n\n      try {\n        const result = await generateText({ prompt, model, config });\n        console.log(result.output);\n      } catch (error) {\n        console.error(\"LLM call failed:\", error.message);\n        process.exit(1);\n      }\n      break;\n\n    case \"models\":\n      const availability = await checkAIAvailability(config);\n      console.log(`Provider: ${availability.provider}`);\n      console.log(`Model: ${availability.model}`);\n      console.log(`Available: ${availability.available ? \"Yes\" : \"No\"}`);\n      if (!availability.available) {\n        console.log(`Message: ${availability.message}`);\n      }\n      break;\n\n    default:\n      console.error(`Unknown llm subcommand: ${subcommand}`);\n      process.exit(1);\n  }\n}\n\nfunction handleHelp() {\n  console.log(`\nGitVan v2 - AI-powered Git workflow automation\n\nUsage:\n  gitvan daemon [start|stop|status] [--worktrees all]    Manage daemon\n  gitvan job [list|run] [--name <job-name>]              Job management\n  gitvan event [list|simulate|test]                      Event management\n  gitvan cron [list|start|dry-run]                       Cron job management\n  gitvan audit [build|verify|list]                       Receipt audit\n  gitvan chat [draft|generate|explain]                    AI job generation\n  gitvan llm [call|models]                               AI operations\n  gitvan schedule apply                                  Apply scheduled tasks\n  gitvan worktree list                                   List all worktrees\n  gitvan run <job-name>                                  Run a specific job (legacy)\n  gitvan list                                            List available jobs (legacy)\n  gitvan help                                            Show this help\n\nExamples:\n  gitvan daemon start                                    Start daemon for current worktree\n  gitvan cron list                                       List all cron jobs\n  gitvan event simulate --files \"src/**\"                Simulate file change event\n  gitvan chat generate \"Create a changelog job\"         Generate job via AI\n  gitvan llm call \"Summarize recent commits\"            Call AI directly\n  gitvan audit build --out audit.json                  Build audit pack\n`);\n}\n\nfunction findJobFile(jobsDir, jobName) {\n  const possiblePaths = [\n    join(jobsDir, `${jobName}.mjs`),\n    join(jobsDir, `${jobName}.js`),\n    join(jobsDir, jobName, \"index.mjs\"),\n    join(jobsDir, jobName, \"index.js\"),\n  ];\n\n  for (const path of possiblePaths) {\n    try {\n      if (statSync(path).isFile()) {\n        return path;\n      }\n    } catch (err) {\n      // File doesn't exist, continue\n    }\n  }\n\n  return null;\n}\n\nfunction findAllJobs(dir, prefix = \"\") {\n  const jobs = [];\n\n  try {\n    const entries = readdirSync(dir);\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry);\n      const stat = statSync(fullPath);\n\n      if (stat.isDirectory()) {\n        jobs.push(\n          ...findAllJobs(fullPath, prefix ? `${prefix}/${entry}` : entry),\n        );\n      } else if (stat.isFile() && [\".mjs\", \".js\"].includes(extname(entry))) {\n        const jobName = prefix\n          ? `${prefix}/${entry.replace(/\\.(mjs|js)$/, \"\")}`\n          : entry.replace(/\\.(mjs|js)$/, \"\");\n        jobs.push(jobName);\n      }\n    }\n  } catch (err) {\n    // Directory doesn't exist or is not accessible\n  }\n\n  return jobs;\n}\n\nexport { main };\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n"
        }
    ]
}