{
    "sourceFile": "docs/cookbook/cicd/build-automation.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758051806640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758097968785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,10 +41,10 @@\n     const buildType = payload?.buildType || \"production\";\n     const cleanBuild = payload?.cleanBuild !== false;\n     \n     // Get repository information\n-    const head = await git.head();\n-    const branch = await git.getCurrentBranch();\n+    const head = await git.currentHead();\n+    const branch = await git.currentBranch();\n     const isClean = await git.isClean();\n     \n     if (!isClean && !payload?.allowDirty) {\n       throw new Error(\"Repository has uncommitted changes. Build aborted.\");\n@@ -454,9 +454,9 @@\n   async run({ ctx, payload }) {\n     const git = useGit();\n     \n     const imageName = payload?.imageName || \"myapp\";\n-    const tag = payload?.tag || await git.head();\n+    const tag = payload?.tag || await git.currentHead();\n     const environment = payload?.environment || \"production\";\n     \n     const dockerfile = `Dockerfile.${environment}`;\n     \n"
                }
            ],
            "date": 1758051806640,
            "name": "Commit-0",
            "content": "# Build Automation\n\n## üéØ **Recipe Overview**\n\n**Category**: CI/CD  \n**Difficulty**: Intermediate  \n**Time**: 30 minutes  \n**Prerequisites**: Basic GitVan knowledge, build system experience\n\n## üìã **Problem**\n\nYou need to automate your build process with Git-native triggers, environment-specific builds, and comprehensive build reporting. You want a system that can handle different build types and provide detailed build artifacts.\n\n## üç≥ **Solution**\n\n### **Step 1: Create Basic Build Job**\n\n```javascript\n// jobs/cicd/build.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\n\nconst execFileAsync = promisify(execFile);\n\nexport default defineJob({\n  meta: {\n    desc: \"Automated build process with environment-specific configuration\",\n    tags: [\"cicd\", \"build\", \"automation\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get build configuration\n    const environment = payload?.environment || \"development\";\n    const buildType = payload?.buildType || \"production\";\n    const cleanBuild = payload?.cleanBuild !== false;\n    \n    // Get repository information\n    const head = await git.head();\n    const branch = await git.getCurrentBranch();\n    const isClean = await git.isClean();\n    \n    if (!isClean && !payload?.allowDirty) {\n      throw new Error(\"Repository has uncommitted changes. Build aborted.\");\n    }\n    \n    const buildInfo = {\n      environment,\n      buildType,\n      timestamp: ctx.nowISO,\n      repository: {\n        head: head.substring(0, 8),\n        branch,\n        isClean\n      },\n      system: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch\n      }\n    };\n    \n    ctx.logger.log(`üöÄ Starting ${buildType} build for ${environment} environment`);\n    \n    // Clean build directory if requested\n    if (cleanBuild) {\n      const distDir = join(ctx.root, \"dist\");\n      try {\n        await fs.rmdir(distDir, { recursive: true });\n        ctx.logger.log(\"üßπ Cleaned build directory\");\n      } catch (error) {\n        // Directory might not exist, that's okay\n      }\n    }\n    \n    // Create build directory\n    const buildDir = join(ctx.root, \"dist\", \"build\");\n    await fs.mkdir(buildDir, { recursive: true });\n    \n    // Run build commands\n    const buildSteps = [\n      { name: \"Install Dependencies\", command: \"npm\", args: [\"install\"] },\n      { name: \"Lint Code\", command: \"npm\", args: [\"run\", \"lint\"] },\n      { name: \"Run Tests\", command: \"npm\", args: [\"run\", \"test\"] },\n      { name: \"Build Application\", command: \"npm\", args: [\"run\", \"build\"] }\n    ];\n    \n    const buildResults = [];\n    let buildSuccess = true;\n    \n    for (const step of buildSteps) {\n      try {\n        ctx.logger.log(`üì¶ Running: ${step.name}`);\n        const startTime = Date.now();\n        \n        const result = await execFileAsync(step.command, step.args, {\n          cwd: ctx.root,\n          env: {\n            ...process.env,\n            NODE_ENV: environment,\n            BUILD_TYPE: buildType\n          }\n        });\n        \n        const duration = Date.now() - startTime;\n        \n        buildResults.push({\n          step: step.name,\n          command: `${step.command} ${step.args.join(' ')}`,\n          success: true,\n          duration,\n          stdout: result.stdout,\n          stderr: result.stderr\n        });\n        \n        ctx.logger.log(`‚úÖ ${step.name} completed in ${duration}ms`);\n        \n      } catch (error) {\n        const duration = Date.now() - startTime;\n        \n        buildResults.push({\n          step: step.name,\n          command: `${step.command} ${step.args.join(' ')}`,\n          success: false,\n          duration,\n          error: error.message,\n          stdout: error.stdout,\n          stderr: error.stderr\n        });\n        \n        ctx.logger.error(`‚ùå ${step.name} failed: ${error.message}`);\n        \n        if (step.name === \"Run Tests\" || step.name === \"Lint Code\") {\n          buildSuccess = false;\n          break; // Stop on test or lint failures\n        }\n      }\n    }\n    \n    // Generate build report\n    const buildReport = {\n      ...buildInfo,\n      success: buildSuccess,\n      steps: buildResults,\n      summary: {\n        totalSteps: buildSteps.length,\n        successfulSteps: buildResults.filter(r => r.success).length,\n        failedSteps: buildResults.filter(r => !r.success).length,\n        totalDuration: buildResults.reduce((sum, r) => sum + r.duration, 0)\n      }\n    };\n    \n    // Save build report\n    const reportPath = join(buildDir, \"build-report.json\");\n    await fs.writeFile(reportPath, JSON.stringify(buildReport, null, 2));\n    \n    // Generate HTML build report\n    const htmlReportPath = await template.renderToFile(\n      \"build-report.njk\",\n      join(buildDir, \"build-report.html\"),\n      buildReport\n    );\n    \n    ctx.logger.log(`üìä Build ${buildSuccess ? 'completed successfully' : 'failed'}`);\n    ctx.logger.log(`üìù Build report: ${reportPath}`);\n    \n    return {\n      ok: buildSuccess,\n      artifacts: [reportPath, htmlReportPath],\n      data: buildReport\n    };\n  }\n});\n```\n\n### **Step 2: Create Build Report Template**\n\n```njk\n<!-- templates/build-report.njk -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Build Report - {{ environment | titleize }}</title>\n    <style>\n        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }\n        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        .header { background: {{ success ? '#28a745' : '#dc3545' }}; color: white; padding: 20px; border-radius: 8px 8px 0 0; }\n        .content { padding: 20px; }\n        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }\n        .summary-item { background: #f8f9fa; padding: 15px; border-radius: 5px; text-align: center; }\n        .summary-item h3 { margin: 0 0 10px 0; color: #333; }\n        .summary-item .value { font-size: 2em; font-weight: bold; color: {{ success ? '#28a745' : '#dc3545' }}; }\n        .steps { margin-top: 30px; }\n        .step { margin-bottom: 20px; padding: 15px; border-radius: 5px; border-left: 4px solid {{ success ? '#28a745' : '#dc3545' }}; }\n        .step.success { background: #d4edda; border-left-color: #28a745; }\n        .step.failure { background: #f8d7da; border-left-color: #dc3545; }\n        .step-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }\n        .step-name { font-weight: bold; font-size: 1.1em; }\n        .step-duration { color: #666; font-size: 0.9em; }\n        .step-command { background: #e9ecef; padding: 8px; border-radius: 3px; font-family: monospace; font-size: 0.9em; margin: 10px 0; }\n        .step-output { background: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; font-size: 0.8em; max-height: 200px; overflow-y: auto; }\n        .meta { background: #e9ecef; padding: 15px; border-radius: 5px; margin-top: 20px; }\n        .meta-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }\n        .meta-item { display: flex; justify-content: space-between; }\n        .meta-label { font-weight: bold; }\n        .meta-value { color: #666; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Build Report</h1>\n            <p>{{ environment | titleize }} Environment - {{ buildType | titleize }} Build</p>\n            <p>Generated: {{ generatedAt | date(\"YYYY-MM-DD HH:mm:ss\") }}</p>\n        </div>\n        \n        <div class=\"content\">\n            <div class=\"summary\">\n                <div class=\"summary-item\">\n                    <h3>Status</h3>\n                    <div class=\"value\">{{ success ? 'SUCCESS' : 'FAILED' }}</div>\n                </div>\n                <div class=\"summary-item\">\n                    <h3>Total Steps</h3>\n                    <div class=\"value\">{{ summary.totalSteps }}</div>\n                </div>\n                <div class=\"summary-item\">\n                    <h3>Successful</h3>\n                    <div class=\"value\">{{ summary.successfulSteps }}</div>\n                </div>\n                <div class=\"summary-item\">\n                    <h3>Failed</h3>\n                    <div class=\"value\">{{ summary.failedSteps }}</div>\n                </div>\n                <div class=\"summary-item\">\n                    <h3>Duration</h3>\n                    <div class=\"value\">{{ (summary.totalDuration / 1000) | round(2) }}s</div>\n                </div>\n            </div>\n            \n            <div class=\"steps\">\n                <h2>Build Steps</h2>\n                {% for step in steps %}\n                <div class=\"step {{ step.success ? 'success' : 'failure' }}\">\n                    <div class=\"step-header\">\n                        <div class=\"step-name\">{{ step.step }}</div>\n                        <div class=\"step-duration\">{{ (step.duration / 1000) | round(2) }}s</div>\n                    </div>\n                    <div class=\"step-command\">{{ step.command }}</div>\n                    {% if step.stdout %}\n                    <div class=\"step-output\">{{ step.stdout }}</div>\n                    {% endif %}\n                    {% if step.stderr %}\n                    <div class=\"step-output\" style=\"color: #dc3545;\">{{ step.stderr }}</div>\n                    {% endif %}\n                    {% if step.error %}\n                    <div class=\"step-output\" style=\"color: #dc3545;\">Error: {{ step.error }}</div>\n                    {% endif %}\n                </div>\n                {% endfor %}\n            </div>\n            \n            <div class=\"meta\">\n                <h3>Build Information</h3>\n                <div class=\"meta-grid\">\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Repository:</span>\n                        <span class=\"meta-value\">{{ repository.branch }} ({{ repository.head }})</span>\n                    </div>\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Environment:</span>\n                        <span class=\"meta-value\">{{ environment }}</span>\n                    </div>\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Build Type:</span>\n                        <span class=\"meta-value\">{{ buildType }}</span>\n                    </div>\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Node.js:</span>\n                        <span class=\"meta-value\">{{ system.nodeVersion }}</span>\n                    </div>\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Platform:</span>\n                        <span class=\"meta-value\">{{ system.platform }} {{ system.arch }}</span>\n                    </div>\n                    <div class=\"meta-item\">\n                        <span class=\"meta-label\">Clean Repository:</span>\n                        <span class=\"meta-value\">{{ repository.isClean ? 'Yes' : 'No' }}</span>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n### **Step 3: Create Event-Driven Build Job**\n\n```javascript\n// jobs/cicd/event-build.evt.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Trigger builds on specific git events\",\n    tags: [\"cicd\", \"build\", \"event-driven\"]\n  },\n  on: {\n    any: [\n      { mergeTo: \"main\" },\n      { pushTo: \"develop\" },\n      { tagCreate: \"v*.*.*\" }\n    ]\n  },\n  async run({ ctx, trigger }) {\n    const git = useGit();\n    \n    // Determine build environment based on trigger\n    let environment = \"development\";\n    let buildType = \"development\";\n    \n    if (trigger.data?.branch === \"main\") {\n      environment = \"production\";\n      buildType = \"production\";\n    } else if (trigger.data?.branch === \"develop\") {\n      environment = \"staging\";\n      buildType = \"staging\";\n    } else if (trigger.data?.tag) {\n      environment = \"production\";\n      buildType = \"release\";\n    }\n    \n    ctx.logger.log(`üöÄ Event-triggered build: ${environment} (${buildType})`);\n    ctx.logger.log(`üìã Trigger: ${JSON.stringify(trigger.data)}`);\n    \n    // Import and run the build job\n    const { default: buildJob } = await import(\"./build.mjs\");\n    \n    const result = await buildJob.run({\n      ctx,\n      payload: {\n        environment,\n        buildType,\n        trigger: trigger.data,\n        eventDriven: true\n      }\n    });\n    \n    return {\n      ok: result.ok,\n      artifacts: result.artifacts,\n      data: {\n        ...result.data,\n        trigger: trigger.data,\n        eventDriven: true\n      }\n    };\n  }\n});\n```\n\n## üîç **Explanation**\n\n### **Build Process**\n\n1. **Environment Detection**: Determines build environment from payload or git context\n2. **Repository Validation**: Checks repository state before building\n3. **Build Steps**: Executes predefined build steps in sequence\n4. **Error Handling**: Stops on critical failures, continues on non-critical ones\n5. **Reporting**: Generates comprehensive build reports\n\n### **Build Steps**\n\n1. **Install Dependencies**: `npm install`\n2. **Lint Code**: `npm run lint`\n3. **Run Tests**: `npm run test`\n4. **Build Application**: `npm run build`\n\n### **Event Triggers**\n\n- **Merge to main**: Production builds\n- **Push to develop**: Staging builds\n- **Tag creation**: Release builds\n\n## üîÑ **Variations**\n\n### **Variation 1: Multi-Environment Build**\n\n```javascript\n// jobs/cicd/multi-env-build.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Build for multiple environments in parallel\",\n    tags: [\"cicd\", \"build\", \"multi-environment\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const environments = payload?.environments || [\"development\", \"staging\", \"production\"];\n    \n    const buildPromises = environments.map(async (env) => {\n      const { default: buildJob } = await import(\"./build.mjs\");\n      return buildJob.run({\n        ctx,\n        payload: { environment: env, buildType: env }\n      });\n    });\n    \n    const results = await Promise.allSettled(buildPromises);\n    \n    const summary = {\n      total: environments.length,\n      successful: results.filter(r => r.status === 'fulfilled' && r.value.ok).length,\n      failed: results.filter(r => r.status === 'rejected' || !r.value?.ok).length\n    };\n    \n    return {\n      ok: summary.failed === 0,\n      artifacts: results.flatMap(r => r.value?.artifacts || []),\n      data: { summary, results }\n    };\n  }\n});\n```\n\n### **Variation 2: Docker Build**\n\n```javascript\n// jobs/cicd/docker-build.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\n\nconst execFileAsync = promisify(execFile);\n\nexport default defineJob({\n  meta: {\n    desc: \"Build Docker images with Git-native triggers\",\n    tags: [\"cicd\", \"build\", \"docker\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    \n    const imageName = payload?.imageName || \"myapp\";\n    const tag = payload?.tag || await git.head();\n    const environment = payload?.environment || \"production\";\n    \n    const dockerfile = `Dockerfile.${environment}`;\n    \n    try {\n      // Build Docker image\n      const result = await execFileAsync(\"docker\", [\n        \"build\",\n        \"-f\", dockerfile,\n        \"-t\", `${imageName}:${tag}`,\n        \"-t\", `${imageName}:latest`,\n        \".\"\n      ], { cwd: ctx.root });\n      \n      ctx.logger.log(`üê≥ Docker image built: ${imageName}:${tag}`);\n      \n      return {\n        ok: true,\n        artifacts: [],\n        data: {\n          imageName,\n          tag,\n          environment,\n          dockerfile,\n          buildOutput: result.stdout\n        }\n      };\n    } catch (error) {\n      ctx.logger.error(`‚ùå Docker build failed: ${error.message}`);\n      throw error;\n    }\n  }\n});\n```\n\n## üéØ **Best Practices**\n\n### **Build Configuration**\n- **Environment Variables**: Use environment variables for configuration\n- **Build Types**: Define clear build types for different purposes\n- **Clean Builds**: Support clean build options\n- **Parallel Builds**: Use parallel builds when possible\n\n### **Error Handling**\n- **Critical Failures**: Stop on test and lint failures\n- **Non-Critical Failures**: Continue on non-critical failures\n- **Detailed Logging**: Log all build steps and results\n- **Error Recovery**: Implement error recovery mechanisms\n\n### **Build Artifacts**\n- **Comprehensive Reports**: Generate detailed build reports\n- **Multiple Formats**: Support multiple output formats\n- **Artifact Storage**: Store build artifacts appropriately\n- **Version Control**: Track build artifacts in version control\n\n## üîó **Related Recipes**\n\n- [Deployment Pipelines](./deployment-pipelines.md) - Automated deployment\n- [Testing Automation](./testing-automation.md) - Automated testing\n- [Quality Gates](./quality-gates.md) - Automated quality checks\n\n## üìö **Resources**\n\n- [GitVan CI/CD Guide](../../docs/cicd.md)\n- [Build Best Practices](../../docs/build-best-practices.md)\n- [Docker Integration](../../docs/docker-integration.md)\n\n## ü§ù **Contributors**\n\n- **Author**: GitVan Team\n- **Last Updated**: 2024-09-16\n- **Version**: 1.0.0\n\n---\n\n**Next Recipe**: [Deployment Pipelines](./deployment-pipelines.md)\n"
        }
    ]
}