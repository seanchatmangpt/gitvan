{
    "sourceFile": "docs/playground/job-examples.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758051254570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758051254570,
            "name": "Commit-0",
            "content": "# GitVan Playground - Job Examples\n\n## 📋 Complete Job Examples\n\nThis document provides complete, working examples of all job types in the GitVan playground.\n\n## 1. On-Demand Jobs\n\n### Changelog Generation Job\n\n**File**: `jobs/docs/changelog.mjs`\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\n\nexport default defineJob({\n  meta: { desc: \"Render changelog from git log\" },\n  async run({ ctx }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get recent commits\n    const logOutput = await git.log(\"%h%x09%s\", [\"-n\", \"30\"]);\n    const lines = logOutput.split(\"\\n\").filter(Boolean);\n    \n    const commits = lines.map((line) => {\n      const [hash, subject] = line.split(\"\\t\");\n      return { hash, subject };\n    });\n\n    // Render template to file\n    const outputPath = await template.renderToFile(\n      \"changelog.njk\", \n      \"dist/CHANGELOG.md\", \n      { \n        commits,\n        generatedAt: ctx.nowISO,\n        totalCommits: commits.length\n      }\n    );\n\n    return { \n      ok: true, \n      artifacts: [outputPath],\n      data: {\n        commitsProcessed: commits.length,\n        outputPath\n      }\n    };\n  }\n});\n```\n\n### Status Report Job\n\n**File**: `jobs/test/simple.mjs`\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Generate a simple status report\",\n    tags: [\"report\", \"status\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    \n    // Gather repository information\n    const head = await git.head();\n    const branch = await git.getCurrentBranch();\n    const isClean = await git.isClean();\n    const commitCount = await git.getCommitCount();\n    \n    const reportData = {\n      timestamp: ctx.nowISO,\n      repository: {\n        head: head.substring(0, 8),\n        branch,\n        isClean,\n        commitCount\n      },\n      payload: payload || {},\n      environment: {\n        nodeVersion: process.version,\n        platform: process.platform\n      }\n    };\n\n    // Create JSON report\n    const outputPath = join(ctx.root, \"dist\", \"status-report.json\");\n    await fs.mkdir(join(ctx.root, \"dist\"), { recursive: true });\n    await fs.writeFile(outputPath, JSON.stringify(reportData, null, 2));\n\n    return {\n      ok: true,\n      artifacts: [outputPath],\n      data: reportData\n    };\n  }\n});\n```\n\n## 2. Cron Jobs\n\n### Cleanup Job\n\n**File**: `jobs/test/cleanup.cron.mjs`\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Clean up temporary files and old artifacts\",\n    tags: [\"cleanup\", \"maintenance\"]\n  },\n  cron: \"0 2 * * *\", // Run daily at 2 AM\n  async run({ ctx }) {\n    const git = useGit();\n    const artifacts = [];\n    \n    // Clean up dist directory\n    const distDir = join(ctx.root, \"dist\");\n    try {\n      const files = await fs.readdir(distDir);\n      const oldFiles = files.filter((file) => {\n        // Simple heuristic: files older than 7 days\n        return (\n          file.includes(\"old\") ||\n          file.includes(\"temp\") ||\n          file.includes(\"backup\")\n        );\n      });\n      \n      for (const file of oldFiles) {\n        const filePath = join(distDir, file);\n        await fs.unlink(filePath);\n        artifacts.push(`Removed: ${file}`);\n        ctx.logger.log(`Removed old file: ${file}`);\n      }\n      \n      if (oldFiles.length === 0) {\n        artifacts.push(\"No old files found to clean up\");\n        ctx.logger.log(\"No old files found to clean up\");\n      }\n    } catch (error) {\n      if (error.code === \"ENOENT\") {\n        artifacts.push(\"Dist directory does not exist\");\n        ctx.logger.log(\"Dist directory does not exist\");\n      } else {\n        throw error;\n      }\n    }\n\n    return {\n      ok: true,\n      artifacts,\n      data: {\n        cleanedFiles: artifacts.length,\n        timestamp: ctx.nowISO\n      }\n    };\n  }\n});\n```\n\n## 3. Event-Driven Jobs\n\n### Release Notification Job\n\n**File**: `jobs/alerts/release.evt.mjs`\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Notify on new tags or releases\",\n    tags: [\"notification\", \"release\"]\n  },\n  on: {\n    any: [{ tagCreate: \"v*.*.*\" }, { semverTag: true }]\n  },\n  async run({ ctx, trigger }) {\n    const git = useGit();\n    \n    // Get the latest tag (handle case where no tags exist)\n    let latestTag;\n    try {\n      latestTag = await git.run([\"describe\", \"--tags\", \"--abbrev=0\", \"HEAD\"]);\n    } catch (error) {\n      if (error.message.includes(\"No names found\")) {\n        // No tags exist, this is normal for new repositories\n        ctx.logger.log(\"No tags found in repository\");\n        latestTag = \"no-tags\";\n      } else {\n        throw error;\n      }\n    }\n\n    const notification = {\n      type: \"release\",\n      tag: latestTag.trim(),\n      timestamp: ctx.nowISO,\n      trigger: trigger?.data || {},\n      repository: {\n        head: await git.head(),\n        branch: await git.getCurrentBranch()\n      }\n    };\n\n    // Create notification file\n    const outputPath = join(\n      ctx.root,\n      \"dist\",\n      \"notifications\",\n      `${Date.now()}-release.json`\n    );\n    await fs.mkdir(join(ctx.root, \"dist\", \"notifications\"), {\n      recursive: true\n    });\n    await fs.writeFile(outputPath, JSON.stringify(notification, null, 2));\n\n    ctx.logger.log(`Release notification created for tag: ${latestTag}`);\n\n    return {\n      ok: true,\n      artifacts: [outputPath],\n      data: notification\n    };\n  }\n});\n```\n\n## 4. Advanced Job Examples\n\n### Database Migration Job\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Run database migrations\",\n    tags: [\"database\", \"migration\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    \n    // Check if migrations are needed\n    const migrationFiles = await fs.readdir(\"migrations\");\n    const appliedMigrations = await fs.readFile(\"migrations/applied.json\", \"utf-8\")\n      .then(JSON.parse)\n      .catch(() => []);\n    \n    const pendingMigrations = migrationFiles.filter(\n      file => !appliedMigrations.includes(file)\n    );\n    \n    if (pendingMigrations.length === 0) {\n      return {\n        ok: true,\n        artifacts: [],\n        data: { message: \"No migrations to run\" }\n      };\n    }\n    \n    // Run migrations\n    const results = [];\n    for (const migration of pendingMigrations) {\n      try {\n        const migrationPath = join(\"migrations\", migration);\n        const migrationContent = await fs.readFile(migrationPath, \"utf-8\");\n        \n        // Execute migration (simplified)\n        ctx.logger.log(`Running migration: ${migration}`);\n        \n        results.push({\n          migration,\n          status: \"success\",\n          timestamp: ctx.nowISO\n        });\n        \n        // Mark as applied\n        appliedMigrations.push(migration);\n        await fs.writeFile(\n          \"migrations/applied.json\",\n          JSON.stringify(appliedMigrations, null, 2)\n        );\n        \n      } catch (error) {\n        results.push({\n          migration,\n          status: \"failed\",\n          error: error.message,\n          timestamp: ctx.nowISO\n        });\n        throw error;\n      }\n    }\n    \n    return {\n      ok: true,\n      artifacts: [\"migrations/applied.json\"],\n      data: {\n        migrationsRun: results.length,\n        results\n      }\n    };\n  }\n});\n```\n\n### Build and Deploy Job\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Build and deploy application\",\n    tags: [\"build\", \"deploy\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get build information\n    const head = await git.head();\n    const branch = await git.getCurrentBranch();\n    const isClean = await git.isClean();\n    \n    if (!isClean) {\n      throw new Error(\"Repository has uncommitted changes\");\n    }\n    \n    // Build application (simplified)\n    ctx.logger.log(\"Building application...\");\n    const buildStart = Date.now();\n    \n    // Simulate build process\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    const buildTime = Date.now() - buildStart;\n    \n    // Generate build report\n    const buildReport = {\n      version: head.substring(0, 8),\n      branch,\n      buildTime,\n      timestamp: ctx.nowISO,\n      environment: payload.environment || \"production\"\n    };\n    \n    // Render build report template\n    const reportPath = await template.renderToFile(\n      \"build-report.njk\",\n      \"dist/build-report.md\",\n      buildReport\n    );\n    \n    // Create deployment artifact\n    const deploymentArtifact = {\n      version: head.substring(0, 8),\n      timestamp: ctx.nowISO,\n      artifacts: [reportPath],\n      environment: payload.environment || \"production\"\n    };\n    \n    const artifactPath = join(ctx.root, \"dist\", \"deployment.json\");\n    await fs.writeFile(artifactPath, JSON.stringify(deploymentArtifact, null, 2));\n    \n    ctx.logger.log(`Build completed in ${buildTime}ms`);\n    \n    return {\n      ok: true,\n      artifacts: [reportPath, artifactPath],\n      data: buildReport\n    };\n  }\n});\n```\n\n### Test Runner Job\n\n```javascript\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Run test suite and generate coverage report\",\n    tags: [\"test\", \"coverage\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    \n    // Get test configuration\n    const testConfig = {\n      head: await git.head(),\n      branch: await git.getCurrentBranch(),\n      timestamp: ctx.nowISO,\n      ...payload\n    };\n    \n    // Run tests (simplified)\n    ctx.logger.log(\"Running test suite...\");\n    const testStart = Date.now();\n    \n    // Simulate test execution\n    const testResults = {\n      total: 42,\n      passed: 40,\n      failed: 2,\n      skipped: 0,\n      duration: Date.now() - testStart\n    };\n    \n    // Generate coverage report\n    const coverageReport = {\n      lines: { total: 1000, covered: 950, percentage: 95 },\n      functions: { total: 50, covered: 48, percentage: 96 },\n      branches: { total: 200, covered: 190, percentage: 95 },\n      statements: { total: 800, covered: 760, percentage: 95 }\n    };\n    \n    // Create test report\n    const testReport = {\n      ...testConfig,\n      results: testResults,\n      coverage: coverageReport,\n      artifacts: []\n    };\n    \n    // Save test results\n    const resultsPath = join(ctx.root, \"dist\", \"test-results.json\");\n    await fs.writeFile(resultsPath, JSON.stringify(testReport, null, 2));\n    \n    // Save coverage report\n    const coveragePath = join(ctx.root, \"dist\", \"coverage.json\");\n    await fs.writeFile(coveragePath, JSON.stringify(coverageReport, null, 2));\n    \n    ctx.logger.log(`Tests completed: ${testResults.passed}/${testResults.total} passed`);\n    \n    return {\n      ok: testResults.failed === 0,\n      artifacts: [resultsPath, coveragePath],\n      data: testReport\n    };\n  }\n});\n```\n\n## 5. Template Examples\n\n### Changelog Template\n\n**File**: `templates/changelog.njk`\n\n```njk\n# Changelog\n\nGenerated at: {{ generatedAt }}\nTotal commits: {{ totalCommits }}\n\n## Recent Changes\n\n{% for commit in commits -%}\n- **{{ commit.hash }}** {{ commit.subject }}\n{% endfor %}\n\n---\n*Generated by GitVan Jobs System*\n```\n\n### Build Report Template\n\n**File**: `templates/build-report.njk`\n\n```njk\n# Build Report\n\n**Version**: {{ version }}\n**Branch**: {{ branch }}\n**Environment**: {{ environment }}\n**Build Time**: {{ buildTime }}ms\n**Timestamp**: {{ timestamp }}\n\n## Build Details\n\n- **Commit**: {{ version }}\n- **Branch**: {{ branch }}\n- **Environment**: {{ environment }}\n- **Build Duration**: {{ buildTime }}ms\n\n## Artifacts\n\n- Build report generated\n- Deployment artifact created\n\n---\n*Generated by GitVan Jobs System*\n```\n\n### Test Report Template\n\n**File**: `templates/test-report.njk`\n\n```njk\n# Test Report\n\n**Total Tests**: {{ results.total }}\n**Passed**: {{ results.passed }}\n**Failed**: {{ results.failed }}\n**Skipped**: {{ results.skipped }}\n**Duration**: {{ results.duration }}ms\n\n## Coverage Summary\n\n- **Lines**: {{ coverage.lines.percentage }}%\n- **Functions**: {{ coverage.functions.percentage }}%\n- **Branches**: {{ coverage.branches.percentage }}%\n- **Statements**: {{ coverage.statements.percentage }}%\n\n## Test Results\n\n{% if results.failed > 0 -%}\n❌ **{{ results.failed }} tests failed**\n{% else -%}\n✅ **All tests passed**\n{% endif %}\n\n---\n*Generated by GitVan Jobs System*\n```\n\n## 6. Configuration Examples\n\n### Development Configuration\n\n```javascript\nexport default {\n  root: process.cwd(),\n  jobs: { dir: \"jobs\" },\n  templates: { \n    engine: \"nunjucks\", \n    dirs: [\"templates\"],\n    noCache: true  // Disable caching for development\n  },\n  receipts: { ref: \"refs/notes/gitvan/results\" },\n  hooks: {\n    \"job:before\"({ id, payload }) {\n      console.log(`🚀 Starting job: ${id}`);\n    },\n    \"job:after\"({ id, result }) {\n      console.log(`✅ Job completed: ${id}`);\n    },\n    \"job:error\"({ id, error }) {\n      console.error(`❌ Job failed: ${id}`, error.message);\n    }\n  }\n};\n```\n\n### Production Configuration\n\n```javascript\nexport default {\n  root: process.cwd(),\n  jobs: { dir: \"jobs\" },\n  templates: { \n    engine: \"nunjucks\", \n    dirs: [\"templates\"],\n    noCache: false  // Enable caching for production\n  },\n  receipts: { ref: \"refs/notes/gitvan/results\" },\n  hooks: {\n    \"job:before\"({ id, payload }) {\n      // Log to production logging system\n      logger.info(`Job started: ${id}`, { payload });\n    },\n    \"job:after\"({ id, result }) {\n      // Log to production logging system\n      logger.info(`Job completed: ${id}`, { result });\n    },\n    \"job:error\"({ id, error }) {\n      // Log to production logging system\n      logger.error(`Job failed: ${id}`, { error: error.message });\n    }\n  }\n};\n```\n\n## 7. Event Predicate Examples\n\n### Tag-Based Triggers\n\n```javascript\non: {\n  any: [\n    { tagCreate: \"v*.*.*\" },     // Any version tag\n    { tagCreate: \"release-*\" },   // Release tags\n    { semverTag: true }           // Any semver tag\n  ]\n}\n```\n\n### Branch-Based Triggers\n\n```javascript\non: {\n  any: [\n    { mergeTo: \"main\" },         // Merge to main\n    { pushTo: \"develop\" },       // Push to develop\n    { mergeTo: \"release/*\" }     // Merge to release branches\n  ]\n}\n```\n\n### File-Based Triggers\n\n```javascript\non: {\n  any: [\n    { pathChanged: [\"src/**/*.js\"] },      // JavaScript files changed\n    { pathAdded: [\"docs/**/*.md\"] },       // New markdown files\n    { pathModified: [\"*.json\", \"*.yaml\"] }  // Config files modified\n  ]\n}\n```\n\n### Message-Based Triggers\n\n```javascript\non: {\n  any: [\n    { message: \"release\" },                // Commit message contains \"release\"\n    { message: \"hotfix\" },                 // Commit message contains \"hotfix\"\n    { authorEmail: \"*@company.com\" }       // Author email pattern\n  ]\n}\n```\n\n### Complex Predicates\n\n```javascript\non: {\n  all: [  // All conditions must be true\n    { mergeTo: \"main\" },\n    { signed: true }\n  ],\n  any: [  // Any of these conditions can be true\n    { tagCreate: \"v*.*.*\" },\n    { message: \"release\" }\n  ]\n}\n```\n\n## 8. Cron Expression Examples\n\n### Common Schedules\n\n```javascript\ncron: \"0 2 * * *\"        // Daily at 2 AM\ncron: \"0 */6 * * *\"      // Every 6 hours\ncron: \"*/15 * * * *\"     // Every 15 minutes\ncron: \"0 9-17 * * 1-5\"   // Every hour 9-17, weekdays only\ncron: \"0 0 1 * *\"        // First day of every month\ncron: \"0 0 * * 0\"        // Every Sunday at midnight\n```\n\n### Business Hours\n\n```javascript\ncron: \"0 9-17 * * 1-5\"   // Every hour during business hours\ncron: \"0 9 * * 1-5\"      // 9 AM on weekdays\ncron: \"0 17 * * 1-5\"     // 5 PM on weekdays\n```\n\n### Maintenance Windows\n\n```javascript\ncron: \"0 2 * * 0\"        // Sunday at 2 AM (maintenance window)\ncron: \"0 3 * * 1\"        // Monday at 3 AM (after weekend)\n```\n\n## 9. Error Handling Examples\n\n### Graceful Error Handling\n\n```javascript\nasync run({ ctx }) {\n  try {\n    // Risky operation\n    const result = await riskyOperation();\n    return { ok: true, data: result };\n  } catch (error) {\n    // Log error but don't fail the job\n    ctx.logger.warn(`Operation failed: ${error.message}`);\n    return { \n      ok: true, \n      data: { \n        error: error.message,\n        fallback: \"default-value\"\n      }\n    };\n  }\n}\n```\n\n### Retry Logic\n\n```javascript\nasync run({ ctx }) {\n  const maxRetries = 3;\n  let lastError;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const result = await riskyOperation();\n      return { ok: true, data: result };\n    } catch (error) {\n      lastError = error;\n      ctx.logger.warn(`Attempt ${attempt} failed: ${error.message}`);\n      \n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n      }\n    }\n  }\n  \n  throw lastError;\n}\n```\n\n### Validation\n\n```javascript\nasync run({ ctx, payload }) {\n  // Validate payload\n  if (!payload.requiredField) {\n    throw new Error(\"requiredField is required\");\n  }\n  \n  if (typeof payload.requiredField !== \"string\") {\n    throw new Error(\"requiredField must be a string\");\n  }\n  \n  // Continue with job logic\n  return { ok: true, data: payload };\n}\n```\n\n## 10. Performance Optimization Examples\n\n### Caching\n\n```javascript\nasync run({ ctx }) {\n  const cacheKey = `expensive-operation-${ctx.head}`;\n  \n  // Check cache first\n  let result = await getFromCache(cacheKey);\n  if (result) {\n    ctx.logger.log(\"Using cached result\");\n    return { ok: true, data: result };\n  }\n  \n  // Perform expensive operation\n  result = await expensiveOperation();\n  \n  // Cache the result\n  await setCache(cacheKey, result);\n  \n  return { ok: true, data: result };\n}\n```\n\n### Parallel Operations\n\n```javascript\nasync run({ ctx }) {\n  // Run multiple operations in parallel\n  const [result1, result2, result3] = await Promise.all([\n    operation1(),\n    operation2(),\n    operation3()\n  ]);\n  \n  return { \n    ok: true, \n    data: { result1, result2, result3 }\n  };\n}\n```\n\n### Resource Cleanup\n\n```javascript\nasync run({ ctx }) {\n  let tempFile;\n  \n  try {\n    // Create temporary file\n    tempFile = await createTempFile();\n    \n    // Use temporary file\n    const result = await processFile(tempFile);\n    \n    return { ok: true, data: result };\n  } finally {\n    // Always clean up\n    if (tempFile) {\n      await fs.unlink(tempFile).catch(() => {});\n    }\n  }\n}\n```\n\nThese examples demonstrate the full range of GitVan job capabilities and provide practical patterns for common use cases.\n"
        }
    ]
}