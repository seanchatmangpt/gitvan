{
    "sourceFile": "tests/template-comprehensive.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758046176576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758046176576,
            "name": "Commit-0",
            "content": "// GitVan v2 â€” Comprehensive useTemplate() tests\n// Tests template rendering, inflection filters, config discovery, and error handling\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { promises as fs } from 'node:fs';\nimport { join, dirname } from 'pathe';\nimport { useTemplate } from '../composables/template.mjs';\nimport { findGitVanConfig, findTemplatesDir } from '../utils/config-finder.mjs';\n\n// Mock context for testing\nconst mockContext = {\n  cwd: '/test/project',\n  config: {\n    templates: {\n      dirs: ['templates', 'custom-templates'],\n      autoescape: true,\n      noCache: false\n    }\n  },\n  now: () => '2024-01-15T10:30:00.000Z'\n};\n\n// Mock useGitVan and tryUseGitVan\nvi.mock('../core/context.mjs', () => ({\n  useGitVan: vi.fn(() => mockContext),\n  tryUseGitVan: vi.fn(() => mockContext),\n  withGitVan: vi.fn((context, fn) => fn()),\n  bindContext: vi.fn(() => mockContext) // This was missing!\n}));\n\ndescribe('useTemplate', () => {\n  let tempDir;\n  let templatesDir;\n  \n  beforeEach(async () => {\n    // Create temporary directory structure\n    tempDir = join(process.cwd(), 'test-temp');\n    templatesDir = join(tempDir, 'templates');\n    \n    await fs.mkdir(templatesDir, { recursive: true });\n    \n    // Create test templates\n    await fs.writeFile(\n      join(templatesDir, 'test.njk'),\n      'Hello {{ name | capitalize }}! Today is {{ nowISO }}.'\n    );\n    \n    await fs.writeFile(\n      join(templatesDir, 'inflection.njk'),\n      `{{ \"user\" | pluralize }}: {{ count | inflect \"user\" \"users\" }}\n{{ \"user_profile\" | camelize }}: {{ \"userProfile\" | underscore }}\n{{ \"hello_world\" | titleize }}: {{ \"HelloWorld\" | humanize }}\n{{ \"test_string\" | dasherize }}: {{ \"TestString\" | classify }}`\n    );\n    \n    await fs.writeFile(\n      join(templatesDir, 'filters.njk'),\n      `JSON: {{ data | json }}\nSlug: {{ \"Hello World!\" | slug }}\nUpper: {{ \"hello\" | upper }}\nLower: {{ \"HELLO\" | lower }}\nPad: {{ \"5\" | pad 3 \"0\" }}`\n    );\n  });\n  \n  afterEach(async () => {\n    // Clean up temporary directory\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  });\n  \n  describe('basic functionality', () => {\n    it('should render template with basic data', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.render('test.njk', { name: 'john' });\n      \n      expect(result).toBe('Hello John! Today is 2024-01-15T10:30:00.000Z.');\n    });\n    \n    it('should render string template', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('Hello {{ name }}!', { name: 'world' });\n      \n      expect(result).toBe('Hello world!');\n    });\n    \n    it('should render to file', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const outputPath = join(tempDir, 'output.txt');\n      \n      const result = await template.renderToFile('test.njk', outputPath, { name: 'jane' });\n      \n      expect(result.path).toBe(outputPath);\n      expect(result.bytes).toBeGreaterThan(0);\n      \n      const content = await fs.readFile(outputPath, 'utf8');\n      expect(content).toBe('Hello Jane! Today is 2024-01-15T10:30:00.000Z.');\n    });\n  });\n  \n  describe('inflection filters', () => {\n    it('should handle pluralization', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"user\" | pluralize }}', {});\n      expect(result).toBe('users');\n    });\n    \n    it('should handle singularization', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"users\" | singularize }}', {});\n      expect(result).toBe('user');\n    });\n    \n    it('should handle inflect with count', async () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ 1 | inflect \"user\" \"users\" }}', {});\n      const result2 = template.renderString('{{ 2 | inflect \"user\" \"users\" }}', {});\n      \n      expect(result1).toBe('user');\n      expect(result2).toBe('users');\n    });\n    \n    it('should handle camelize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ \"user_profile\" | camelize }}', {});\n      const result2 = template.renderString('{{ \"user_profile\" | camelize true }}', {});\n      \n      expect(result1).toBe('UserProfile');\n      expect(result2).toBe('userProfile');\n    });\n    \n    it('should handle underscore', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ \"UserProfile\" | underscore }}', {});\n      const result2 = template.renderString('{{ \"UserProfile\" | underscore true }}', {});\n      \n      expect(result1).toBe('user_profile');\n      expect(result2).toBe('USER_PROFILE');\n    });\n    \n    it('should handle humanize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ \"user_profile\" | humanize }}', {});\n      const result2 = template.renderString('{{ \"user_profile\" | humanize true }}', {});\n      \n      expect(result1).toBe('User profile');\n      expect(result2).toBe('user profile');\n    });\n    \n    it('should handle capitalize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"hello world\" | capitalize }}', {});\n      expect(result).toBe('Hello world');\n    });\n    \n    it('should handle dasherize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"hello_world\" | dasherize }}', {});\n      expect(result).toBe('hello-world');\n    });\n    \n    it('should handle titleize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"hello world\" | titleize }}', {});\n      expect(result).toBe('Hello World');\n    });\n    \n    it('should handle demodulize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"User::Profile\" | demodulize }}', {});\n      expect(result).toBe('Profile');\n    });\n    \n    it('should handle tableize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"UserProfile\" | tableize }}', {});\n      expect(result).toBe('user_profiles');\n    });\n    \n    it('should handle classify', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"user_profiles\" | classify }}', {});\n      expect(result).toBe('UserProfile');\n    });\n    \n    it('should handle foreign_key', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ \"UserProfile\" | foreign_key }}', {});\n      const result2 = template.renderString('{{ \"UserProfile\" | foreign_key true }}', {});\n      \n      expect(result1).toBe('user_profile_id');\n      expect(result2).toBe('USER_PROFILE_ID');\n    });\n    \n    it('should handle ordinalize', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ 1 | ordinalize }}', {});\n      const result2 = template.renderString('{{ 2 | ordinalize }}', {});\n      const result3 = template.renderString('{{ 3 | ordinalize }}', {});\n      \n      expect(result1).toBe('1st');\n      expect(result2).toBe('2nd');\n      expect(result3).toBe('3rd');\n    });\n    \n    it('should handle transform', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"hello\" | transform [\"upper\", \"slug\"] }}', {});\n      expect(result).toBe('hello');\n    });\n  });\n  \n  describe('built-in filters', () => {\n    it('should handle json filter', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const data = { name: 'test', value: 42 };\n      const result = template.renderString('{{ data | json }}', { data });\n      \n      expect(result).toBe(JSON.stringify(data, null, 0));\n    });\n    \n    it('should handle json filter with spacing', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const data = { name: 'test' };\n      const result = template.renderString('{{ data | json 2 }}', { data });\n      \n      expect(result).toBe(JSON.stringify(data, null, 2));\n    });\n    \n    it('should handle slug filter', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"Hello World!\" | slug }}', {});\n      expect(result).toBe('hello-world');\n    });\n    \n    it('should handle upper filter', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"hello\" | upper }}', {});\n      expect(result).toBe('HELLO');\n    });\n    \n    it('should handle lower filter', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ \"HELLO\" | lower }}', {});\n      expect(result).toBe('hello');\n    });\n    \n    it('should handle pad filter', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result1 = template.renderString('{{ \"5\" | pad 3 }}', {});\n      const result2 = template.renderString('{{ \"5\" | pad 3 \"x\" }}', {});\n      \n      expect(result1).toBe('005');\n      expect(result2).toBe('xx5');\n    });\n  });\n  \n  describe('configuration handling', () => {\n    it('should use config paths when available', () => {\n      const template = useTemplate();\n      expect(template.env.loaders[0].searchPaths).toContain(join(mockContext.cwd, 'templates'));\n      expect(template.env.loaders[0].searchPaths).toContain(join(mockContext.cwd, 'custom-templates'));\n    });\n    \n    it('should use custom paths when provided', () => {\n      const customPaths = ['/custom/path1', '/custom/path2'];\n      const template = useTemplate({ paths: customPaths });\n      \n      expect(template.env.loaders[0].searchPaths).toEqual(customPaths);\n    });\n    \n    it('should handle autoescape setting', () => {\n      const template1 = useTemplate({ autoescape: true });\n      const template2 = useTemplate({ autoescape: false });\n      \n      expect(template1.env.autoescape).toBe(true);\n      expect(template2.env.autoescape).toBe(false);\n    });\n    \n    it('should handle noCache setting', () => {\n      const template1 = useTemplate({ noCache: true });\n      const template2 = useTemplate({ noCache: false });\n      \n      expect(template1.env.loaders[0].noCache).toBe(true);\n      expect(template2.env.loaders[0].noCache).toBe(false);\n    });\n  });\n  \n  describe('error handling', () => {\n    it('should throw error for undefined variables', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      \n      expect(() => {\n        template.renderString('{{ undefined_var }}', {});\n      }).toThrow();\n    });\n    \n    it('should throw error for now() calls', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      \n      expect(() => {\n        template.renderString('{{ now() }}', {});\n      }).toThrow('Templates must not call now()');\n    });\n    \n    it('should throw error for random() calls', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      \n      expect(() => {\n        template.renderString('{{ random() }}', {});\n      }).toThrow('Templates must not use random()');\n    });\n    \n    it('should handle missing template files gracefully', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      \n      expect(() => {\n        template.render('nonexistent.njk', {});\n      }).toThrow();\n    });\n  });\n  \n  describe('context integration', () => {\n    it('should include git context in template data', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ git.cwd }}', {});\n      \n      expect(result).toBe(mockContext.cwd);\n    });\n    \n    it('should include nowISO when available', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ nowISO }}', {});\n      \n      expect(result).toBe('2024-01-15T10:30:00.000Z');\n    });\n    \n    it('should merge additional data with base data', () => {\n      const template = await useTemplate({ paths: [templatesDir] });\n      const result = template.renderString('{{ name }} {{ git.cwd }}', { name: 'test' });\n      \n      expect(result).toBe(`test ${mockContext.cwd}`);\n    });\n  });\n  \n  describe('environment caching', () => {\n    it('should cache environments with same configuration', () => {\n      const template1 = useTemplate({ paths: [templatesDir] });\n      const template2 = useTemplate({ paths: [templatesDir] });\n      \n      expect(template1.env).toBe(template2.env);\n    });\n    \n    it('should create different environments for different configurations', () => {\n      const template1 = useTemplate({ paths: [templatesDir], autoescape: true });\n      const template2 = useTemplate({ paths: [templatesDir], autoescape: false });\n      \n      expect(template1.env).not.toBe(template2.env);\n    });\n  });\n});\n\ndescribe('config-finder utilities', () => {\n  let tempDir: string;\n  \n  beforeEach(async () => {\n    tempDir = join(process.cwd(), 'test-config-temp');\n    await fs.mkdir(tempDir, { recursive: true });\n  });\n  \n  afterEach(async () => {\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  });\n  \n  it('should find config file in current directory', async () => {\n    const configPath = join(tempDir, 'gitvan.config.js');\n    await fs.writeFile(configPath, 'export default { templates: { directory: \"custom-templates\" } };');\n    \n    const result = await findGitVanConfig(tempDir);\n    \n    expect(result).toBeTruthy();\n    expect(result.path).toBe(configPath);\n    expect(result.root).toBe(tempDir);\n    expect(result.config.templates.directory).toBe('custom-templates');\n  });\n  \n  it('should find templates directory from config', async () => {\n    const configPath = join(tempDir, 'gitvan.config.js');\n    const templatesDir = join(tempDir, 'custom-templates');\n    \n    await fs.writeFile(configPath, 'export default { templates: { directory: \"custom-templates\" } };');\n    await fs.mkdir(templatesDir, { recursive: true });\n    \n    const result = await findTemplatesDir(tempDir);\n    \n    expect(result).toBeTruthy();\n    expect(result.templatesDir).toBe(templatesDir);\n    expect(result.config.templates.directory).toBe('custom-templates');\n  });\n  \n  it('should fallback to default templates directory', async () => {\n    const templatesDir = join(tempDir, 'templates');\n    await fs.mkdir(templatesDir, { recursive: true });\n    \n    const result = await findTemplatesDir(tempDir);\n    \n    expect(result).toBeTruthy();\n    expect(result.templatesDir).toBe(templatesDir);\n    expect(result.config).toBeNull();\n  });\n});\n"
        }
    ]
}