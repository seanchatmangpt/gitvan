{
    "sourceFile": "specs/docs/EXECUTABLE_SPECIFICATIONS.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758038949881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758038949881,
            "name": "Commit-0",
            "content": "# Executable Specifications Guide\n\n## Overview\n\nThis document defines how GitVan v2 specifications should be written to be executable and testable, following GitHub's specification-driven development methodology.\n\n## Specification Structure\n\n### 1. Executable Test Scenarios\n\nEach specification must include executable test scenarios that can be run to validate implementation:\n\n```javascript\n// Example: Executable test for job definition\ndescribe('Job Definition System', () => {\n  test('should discover jobs from filesystem', async () => {\n    // Given: A repository with jobs/ directory\n    const repo = await createTestRepo({\n      'jobs/example.mjs': `\n        export default defineJob({\n          kind: 'atomic',\n          meta: { desc: 'Test job' },\n          run: () => ({ ok: true })\n        })\n      `\n    })\n    \n    // When: Scanning for jobs\n    const jobs = await discoverJobs(repo.root)\n    \n    // Then: Job should be discoverable\n    expect(jobs).toHaveLength(1)\n    expect(jobs[0].name).toBe('example')\n    expect(jobs[0].meta.desc).toBe('Test job')\n  })\n})\n```\n\n### 2. Behavior-Driven Specifications\n\nUse Given-When-Then format for clear behavior specification:\n\n```gherkin\nFeature: Job Execution Engine\n  Scenario: Execute atomic job with composables\n    Given a job using useGit() and useTemplate() composables\n    When the job executes within withGitVan context\n    Then all composables should have access to RunContext\n    And useGit() should return properly configured GitAPI instance\n    And useTemplate() should render Nunjucks templates deterministically\n```\n\n### 3. Contract-First API Design\n\nDefine API contracts with executable validation:\n\n```javascript\n// API Contract Definition\nconst GitAPI = {\n  root: 'string',\n  head: '() => string',\n  branch: '() => string',\n  run: '(args: string) => string',\n  note: '(ref: string, msg: string, sha?: string) => void'\n}\n\n// Executable Contract Validation\nfunction validateGitAPI(api) {\n  return Object.entries(GitAPI).every(([key, type]) => {\n    return typeof api[key] === type.replace(/[()]/g, '')\n  })\n}\n```\n\n## Executable Specification Templates\n\n### Core System Specification Template\n\n```markdown\n# [Specification Name]\n\n## Executable Requirements\n\n### Test Suite: [Feature Name]\n```javascript\ndescribe('[Feature Name]', () => {\n  beforeEach(() => {\n    // Setup test environment\n  })\n  \n  test('[specific behavior]', async () => {\n    // Given-When-Then implementation\n  })\n})\n```\n\n### Performance Specifications\n```javascript\n// Performance contract\nconst performanceContract = {\n  'job-execution-time': '< 100ms for simple tasks',\n  'template-rendering-speed': '> 1000 templates/second',\n  'daemon-memory-usage': '< 50MB baseline'\n}\n\n// Executable performance tests\ndescribe('Performance Contracts', () => {\n  test('job execution time', async () => {\n    const start = performance.now()\n    await executeJob('simple-task')\n    const duration = performance.now() - start\n    expect(duration).toBeLessThan(100)\n  })\n})\n```\n\n### Security Specifications\n```javascript\n// Security contract\nconst securityContract = {\n  'no-code-injection': 'Template rendering must escape user input',\n  'signed-commits': 'Must verify commit signatures when required',\n  'command-execution': 'Must validate allowed commands'\n}\n\n// Executable security tests\ndescribe('Security Contracts', () => {\n  test('template injection prevention', () => {\n    const maliciousInput = '{{7*7}}'\n    const result = renderTemplate('test.njk', { input: maliciousInput })\n    expect(result).not.toContain('49')\n  })\n})\n```\n\n## Specification Validation Framework\n\n### Automated Validation Pipeline\n\n```javascript\n// spec-validator.mjs\nexport class SpecificationValidator {\n  async validateSpecification(specPath) {\n    const spec = await import(specPath)\n    \n    return {\n      executableTests: await this.runExecutableTests(spec),\n      contractValidation: await this.validateContracts(spec),\n      performanceValidation: await this.validatePerformance(spec),\n      securityValidation: await this.validateSecurity(spec)\n    }\n  }\n  \n  async runExecutableTests(spec) {\n    // Run all test scenarios defined in specification\n  }\n  \n  async validateContracts(spec) {\n    // Validate API contracts are met\n  }\n}\n```\n\n### Continuous Validation\n\n```yaml\n# .github/workflows/spec-validation.yml\nname: Specification Validation\non: [push, pull_request]\n\njobs:\n  validate-specs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Validate Executable Specifications\n        run: |\n          npm run spec:validate\n      - name: Run Contract Tests\n        run: |\n          npm run spec:contracts\n      - name: Performance Validation\n        run: |\n          npm run spec:performance\n```\n\n## Integration with GitHub Spec Kit\n\n### Spec Kit Configuration\n\n```json\n{\n  \"specKit\": {\n    \"executableSpecs\": true,\n    \"contractValidation\": true,\n    \"performanceMonitoring\": true,\n    \"securityScanning\": true,\n    \"aiIntegration\": {\n      \"copilot\": true,\n      \"claude\": true,\n      \"validation\": true\n    }\n  }\n}\n```\n\n### AI-Assisted Specification Development\n\n```javascript\n// AI integration for spec development\nexport const specKitIntegration = {\n  async generateExecutableTests(specification) {\n    // Use AI to generate test scenarios from natural language specs\n  },\n  \n  async validateImplementation(specification, code) {\n    // Use AI to validate code matches specification\n  },\n  \n  async generateDocumentation(specification) {\n    // Use AI to generate comprehensive documentation\n  }\n}\n```\n\n## Best Practices\n\n### 1. Write Specifications Before Implementation\n- Define WHAT and WHY, not HOW\n- Include executable test scenarios\n- Validate contracts before coding\n\n### 2. Make Specifications Executable\n- Every requirement should have a test\n- Use Given-When-Then format\n- Include performance and security contracts\n\n### 3. Continuous Validation\n- Run specifications on every commit\n- Validate contracts in CI/CD\n- Monitor performance continuously\n\n### 4. Stakeholder Collaboration\n- Use natural language for business requirements\n- Include examples and scenarios\n- Make specifications reviewable\n\n### 5. AI Integration\n- Use AI tools to generate test scenarios\n- Validate implementation against specifications\n- Generate documentation automatically\n\n## Tools and Frameworks\n\n### Required Tools\n- **Jest**: Test framework for executable specifications\n- **Cucumber**: BDD framework for Given-When-Then scenarios\n- **Contract Testing**: Pact or similar for API contract validation\n- **Performance Testing**: Artillery or k6 for performance contracts\n- **Security Testing**: OWASP ZAP or similar for security validation\n\n### GitHub Integration\n- **Spec Kit**: GitHub's specification toolkit\n- **Copilot**: AI-assisted specification development\n- **Actions**: Automated validation pipelines\n- **Issues**: Specification tracking and collaboration\n\n## Example: Complete Executable Specification\n\n```markdown\n# Job Definition System\n\n## Executable Requirements\n\n### Test Suite: Job Discovery\n```javascript\ndescribe('Job Discovery', () => {\n  test('should discover jobs from filesystem', async () => {\n    // Given: Repository with jobs\n    const repo = await createTestRepo({\n      'jobs/example.mjs': `\n        export default defineJob({\n          kind: 'atomic',\n          meta: { desc: 'Test job' },\n          run: () => ({ ok: true })\n        })\n      `\n    })\n    \n    // When: Scanning for jobs\n    const jobs = await discoverJobs(repo.root)\n    \n    // Then: Job should be discoverable\n    expect(jobs).toHaveLength(1)\n    expect(jobs[0].name).toBe('example')\n  })\n})\n```\n\n### Performance Contract\n- Job discovery scan: < 500ms for 1000 jobs\n- Context initialization: < 50ms\n- Lock acquisition: < 100ms under contention\n\n### Security Contract\n- No code injection in job definitions\n- Validate job metadata before execution\n- Sanitize all user inputs\n\n### API Contract\n```javascript\nconst JobDefinitionContract = {\n  defineJob: '(config) => JobDefinition',\n  discoverJobs: '(root: string) => JobDefinition[]',\n  validateJob: '(job: JobDefinition) => ValidationResult'\n}\n```\n"
        }
    ]
}