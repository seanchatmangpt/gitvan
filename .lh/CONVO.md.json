{
    "sourceFile": "CONVO.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758000182021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758000182021,
            "name": "Commit-0",
            "content": "Press Release — Expert GitVan Cookbook\n\nSEBASTOPOL, CA — September 15, 2025 — O’Reilly Media today announced Expert GitVan Cookbook, a practical guide to building Git-only workflows that implement the 43 classic workflow patterns (van der Aalst) with a tiny JavaScript DSL, a noun–verb CLI, and an optional daemon. The book focuses on the 80/20 “dark-matter” developer tasks—diaries, changelogs, reviews, release notes, SBOMs—and shows how to automate them with deterministic, signed, auditable receipts inside Git.\n\n“Git is already the runtime. This book shows how to encode automation as commits, notes, tags, and refs—then let a lightweight daemon do the rest,” said the authors.\n\nKey outcomes\n\nShip repeatable workflows with no servers, no runners, no DB.\n\nMap patterns to Git primitives: commits, branches, merges, tags, notes.\n\nUse a noun–verb CLI (gitvan recipe run changelog).\n\nRun an always-on daemon for commit/tag/cron triggers.\n\nAdd LLM steps for summaries, reviews, and explanations with signed receipts.\n\nAvailability\nExpert GitVan Cookbook is available today in eBook and Early Release formats on O’Reilly Learning, with print following. Companion code and recipes ship as a pnpm monorepo (JS, no TypeScript).\n\nWhat’s inside\n\nPart I — Foundations\n\nGit as runtime: determinism, idempotence, receipts\n\nThe 43 patterns → Git (sequence, parallelSplit, synchronize, discriminator, etc.)\n\nProject structure: pnpm monorepo, ESM, happy-path JS\n\nPart II — Core Components\n\n@gitvan/core: Git wrapper + pattern helpers\n\n@gitvan/cli: noun–verb commands (repo init, recipe add/run, daemon start)\n\n@gitvan/daemon: event predicates (commit, tag, path, cron), once-only locks, receipts\n\n@gitvan/llm: Ollama provider with prompt/params/output recorded in notes\n\n@gitvan/schemas: Zod schemas for recipes, notes, receipts (validated JSON)\n\nPart III — Dark-Matter 80/20 Cookbook\n\nDev diary, changelog, release notes, code-review assist\n\nBuild-log explainer, dependency bump explainer, ADR drafter\n\nStandup collector, backport planner, hotfix lane, incident write-up\n\nSBOM + diff, security digest, reviewer routing, test prioritization\n\nPart IV — Enterprise Patterns\n\nSeparation of duties, signed policy refs, protected branches\n\nPrintable audit bundles from notes; disaster controls and checkpoints\n\nMulti-repo orchestration with submodules and worktrees\n\nAppendices\n\nSchemas, receipts, example notes\n\nCLI reference (noun–verb)\n\nReproducible runs checklist\n\nWho it’s for\n\nSenior engineers and staff+ who want deterministic, auditable automation without CI sprawl.\n\nDev leads who need pragmatic, copy-paste recipes for the work everyone wants but nobody has time to wire.\n\nPlatform and compliance teams standardizing signed workflows.\n\nWhy it matters\n\nCompression: one substrate (Git) replaces scattered scripts, runners, and dashboards.\n\nDeterminism: every action leaves a signed receipt under refs/notes/gitvan/results.\n\nAdoption speed: install a cookbook recipe, run it, get proofs—in minutes.\n\nPricing and formats\n\neBook (EPUB/PDF), Early Release chapters, and print.\n\nCompanion monorepo under Apache-2.0; book content © O’Reilly.\n\nAbout O’Reilly\n\nO’Reilly provides technology and business training, knowledge, and insight to help companies succeed.\n\nMedia inquiries: press@oreilly.com\n\nFAQ (Working-Backwards)\n\nQ: What is GitVan?\nA small JS layer that treats Git as the workflow engine. Patterns are commits/branches/merges/tags; case data lives in notes; an optional daemon executes steps; every run is recorded as a signed receipt.\n\nQ: How is this different from CI/CD?\nNo hosted runners or YAML queues. Git is the queue and ledger. Policy lives in protected branches and signatures. Outputs are deterministic and auditable by default.\n\nQ: Do I need TypeScript or a database?\nNo. The reference project is pure JS (ESM), no TypeScript, no DB.\n\nQ: What are requirements?\nGit ≥ 2.30, Node ≥ 18, optional Ollama for LLM steps, pnpm for the monorepo.\n\nQ: How do LLMs fit without losing determinism?\nPrompts, parameters, model IDs, and outputs are stored as receipts. Use seeds for stability when the model supports it.\n\nQ: How do I start?\ngitvan repo init → gitvan cookbook install dev-diary → gitvan recipe run dev-diary → gitvan daemon start.\n\nQ: Is this production-safe?\nYes, with guarded policies: require signed merges/tags, SoD hooks, receipts enforced. The book includes audit bundles and disaster controls.\n\nQ: What about enterprises and multi-repo flows?\nUse submodules/worktrees for fan-out/fan-in; enforce policy via signed refs; generate organization-level audit packs.\n\nQ: What’s in the companion code?\n@gitvan/core, @gitvan/cli, @gitvan/daemon, @gitvan/llm, @gitvan/schemas, and 20+ ready recipes for the dark-matter 80/20 set.\n\nQ: License?\nCode Apache-2.0. Book under O’Reilly terms.\n\nEnd of press release & FAQ.\n\nYou said:\nWe do need a gitvan.config.js app\nChatGPT said:\nThought for 19s\n\nHere’s the minimal, happy-path gitvan.config.js + loader + CLI hook. Pure JS, ESM, no TS.\n\n1) gitvan.config.js (at repo root)\n// gitvan.config.js\nexport default {\n  repo: {\n    dir: process.cwd(),\n    defaultBranch: \"main\",\n    notesRef: \"refs/notes/gitvan\",\n    resultsRef: \"refs/notes/gitvan/results\",\n    signing: { require: true }\n  },\n\n  llm: {\n    baseURL: process.env.OLLAMA_BASE || \"http://localhost:11434\",\n    model: \"llama3.2\",\n    temperature: 0.2\n  },\n\n  cookbook: {\n    install: [\n      \"dev-diary\",\n      \"changelog\"\n    ]\n  },\n\n  // Declarative triggers → actions. These get materialized as git notes.\n  events: [\n    {\n      id: \"daily-dev-diary\",\n      wf: \"cron\",\n      cron: \"0 18 * * *\",                 // 18:00 UTC daily\n      run: { type: \"llm-call\",\n             model: \"llama3.2\",\n             prompt: \"Summarize today’s commits into a diary entry.\" }\n    },\n    {\n      id: \"tag-changelog\",\n      wf: \"event\",\n      on: { semverTag: true },\n      run: { type: \"cli-call\",\n             cmd: \"bash\",\n             args: [\"-lc\",\"git log $(git describe --tags --abbrev=0 --always --tags --match 'v*')..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: update changelog'\"] }\n    }\n  ]\n};\n\n2) Loader: /packages/core/config.js\n// @gitvan/core/config.js\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\n\nconst defaults = (cwd) => ({\n  repo: { dir: cwd, defaultBranch: \"main\", notesRef: \"refs/notes/gitvan\", resultsRef: \"refs/notes/gitvan/results\", signing: { require: false } },\n  llm:  { baseURL: process.env.OLLAMA_BASE || \"http://localhost:11434\", model: \"llama3.2\", temperature: 0.2 },\n  cookbook: { install: [] },\n  events: []\n});\n\nexport async function loadConfig(cwd = process.cwd()) {\n  const base = defaults(cwd);\n  const f = path.join(cwd, \"gitvan.config.js\");\n  const l = path.join(cwd, \".gitvan.local.js\");\n  let cfg = base;\n  if (fs.existsSync(f)) cfg = { ...cfg, ...(await import(pathToFileURL(f).href)).default };\n  if (fs.existsSync(l)) cfg = { ...cfg, ...(await import(pathToFileURL(l).href)).default };\n  return cfg;\n}\n\n3) CLI: add config noun with show and apply\n\nEdit /packages/cli/bin/gitvan.js and add:\n\nimport { loadConfig } from \"@gitvan/core/config.js\";\nimport { NOTES_REF } from \"@gitvan/core/index.js\";\n\n// ...\n\nconst config = defineCommand({\n  meta: { name: \"config\" },\n  subCommands: {\n    show: defineCommand({\n      run: async () => { console.log(JSON.stringify(await loadConfig(), null, 2)); }\n    }),\n    apply: defineCommand({\n      run: async () => {\n        const cfg = await loadConfig();\n        // install cookbook recipes\n        for (const name of (cfg.cookbook?.install || [])) {\n          const p = new URL(`../../cookbook/recipes/${name}.json`, import.meta.url);\n          const json = fs.readFileSync(p, \"utf8\");\n          await core.git.note(json, cfg.repo.notesRef || NOTES_REF);\n        }\n        // materialize events as workflow notes on an empty commit\n        await core.git.exec(`commit --allow-empty -m \"gitvan:config ${new Date().toISOString()}\"`);\n        for (const ev of (cfg.events || [])) {\n          await core.git.note(JSON.stringify(ev), cfg.repo.notesRef || NOTES_REF);\n        }\n        console.log(\"config applied\");\n      }\n    })\n  }\n});\n\n// include in main\nconst main = defineCommand({\n  meta: { name: \"gitvan\" },\n  subCommands: { repo, recipe, cookbook, conversation, daemon: daemonCmd, llm: llmCmd, config }\n});\n\n4) Daemon: read LLM baseURL from config (optional)\n\nIn /packages/llm/index.js:\n\nimport { loadConfig } from \"@gitvan/core/config.js\";\n\nexport async function generate({ model, prompt, options = {} }) {\n  const cfg = await loadConfig();\n  const base = cfg.llm?.baseURL || \"http://localhost:11434\";\n  const res = await fetch(`${base}/api/generate`, {\n    method: \"POST\",\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ model: model || cfg.llm?.model, prompt, options, stream: false })\n  });\n  const j = await res.json();\n  return j.response || \"\";\n}\n\n5) Use\npnpm i\ngitvan repo init\ngitvan config show\ngitvan config apply\ngitvan daemon start\n\n\nThis keeps everything Git-only: config → notes via config apply, daemon consumes notes, cookbook recipes preloaded.\n\nYou said:\nIs there a better practice than index.js\nChatGPT said:\nThought for 8s\n\nYes. Prefer explicit modules + export maps over index.js barrels.\n\nStructure\npackages/core/\n  package.json\n  src/\n    git.js\n    workflow.js\n    notes.js\n    config.js\n\npackage.json (ESM, subpath exports)\n{\n  \"name\": \"@gitvan/core\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./src/workflow.js\",\n    \"./git\": \"./src/git.js\",\n    \"./notes\": \"./src/notes.js\",\n    \"./config\": \"./src/config.js\"\n  },\n  \"files\": [\"src\"],\n  \"sideEffects\": false\n}\n\nImports\nimport { sequence, milestone } from \"@gitvan/core\";       // from workflow.js\nimport { exec, note } from \"@gitvan/core/git\";\nimport { loadConfig } from \"@gitvan/core/config\";\n\nGuidelines\n\nOne module per concern. No catch-all index.js.\n\nNamed exports only. Easier tree-shaking and DX.\n\nExport maps define the public API. No deep relative imports.\n\nsideEffects: false for better bundling.\n\nWhitelist files to keep publishes small.\n\nKeep CLI binaries in bin/, not exported.\n\nCLI example (@gitvan/cli)\npackages/cli/\n  package.json\n  bin/gitvan.js\n\n{\n  \"name\": \"@gitvan/cli\",\n  \"type\": \"module\",\n  \"bin\": { \"gitvan\": \"bin/gitvan.js\" },\n  \"dependencies\": {\n    \"@gitvan/core\": \"workspace:*\"\n  }\n}\n\n\nThis keeps APIs explicit, stable, and importable without index.js.\n\nYou said:\nFocus now on the full project structure \nChatGPT said:\nThought for 13s\n\nHere’s the full pnpm monorepo structure for gitvan. Pure JS (ESM). No index.js. Explicit modules + export maps. Happy path.\n\ngitvan/\n├─ package.json\n├─ pnpm-workspace.yaml\n├─ .gitignore\n├─ README.md\n├─ gitvan.config.js\n├─ scripts/\n│  ├─ seed-roadmap.mjs\n│  └─ demo.mjs\n└─ packages/\n   ├─ core/\n   │  ├─ package.json\n   │  └─ src/\n   │     ├─ git.js\n   │     ├─ workflow.js\n   │     ├─ notes.js\n   │     └─ config.js\n   ├─ cli/\n   │  ├─ package.json\n   │  └─ bin/\n   │     └─ gitvan.js\n   ├─ daemon/\n   │  ├─ package.json\n   │  └─ src/\n   │     ├─ predicates.js\n   │     ├─ actions.js\n   │     └─ loop.js\n   ├─ llm/\n   │  ├─ package.json\n   │  └─ src/\n   │     ├─ provider.js\n   │     └─ embed.js\n   ├─ schemas/\n   │  ├─ package.json\n   │  └─ src/\n   │     ├─ recipe.js\n   │     ├─ note.js\n   │     └─ receipt.js\n   └─ cookbook/\n      ├─ package.json\n      └─ recipes/\n         ├─ dev-diary.json\n         └─ changelog.json\n\nroot /package.json\n{\n  \"name\": \"gitvan-monorepo\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": {\n    \"dev\": \"pnpm -r start\",\n    \"cli\": \"node packages/cli/bin/gitvan.js\"\n  }\n}\n\n/pnpm-workspace.yaml\npackages:\n  - \"packages/*\"\n\n/gitvan.config.js\nexport default {\n  repo: { dir: process.cwd(), defaultBranch: \"main\", notesRef: \"refs/notes/gitvan\", resultsRef: \"refs/notes/gitvan/results\", signing: { require: true } },\n  llm:  { baseURL: process.env.OLLAMA_BASE || \"http://localhost:11434\", model: \"llama3.2\", temperature: 0.2 },\n  cookbook: { install: [\"dev-diary\", \"changelog\"] },\n  events: [\n    { id: \"daily-dev-diary\", wf: \"cron\", cron: \"0 18 * * *\", run: { type: \"llm-call\", model: \"llama3.2\", prompt: \"Summarize today’s commits into a diary entry.\" } },\n    { id: \"tag-changelog\", wf: \"event\", on: { semverTag: true }, run: { type: \"cli-call\", cmd: \"bash\", args: [\"-lc\",\"git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: update changelog'\"] } }\n  ]\n};\n\n@gitvan/core\npackages/core/package.json\n{\n  \"name\": \"@gitvan/core\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./src/workflow.js\",\n    \"./git\": \"./src/git.js\",\n    \"./notes\": \"./src/notes.js\",\n    \"./config\": \"./src/config.js\"\n  },\n  \"files\": [\"src\"],\n  \"sideEffects\": false\n}\n\nsrc/git.js\nimport { execSync } from \"node:child_process\";\nimport fs from \"node:fs\";\nconst sh = (cmd) => execSync(`git -C \"${process.cwd()}\" ${cmd}`, { stdio: [\"ignore\",\"pipe\",\"inherit\"] }).toString().trim();\n\nexport const git = {\n  init: async ({ dir }) => { if (!fs.existsSync(`${dir}/.git`)) sh(\"init\"); },\n  exec: async (cmd) => sh(cmd),\n  checkout: async (ref) => sh(`checkout ${ref}`),\n  branch: async (name) => sh(`checkout -b ${name}`),\n  merge: async (ref, msg) => sh(`merge --no-ff -m \"${msg||`merge ${ref}`}\" ${ref}`),\n  tag: async (name, msg) => sh(`tag -a ${name} -m \"${msg||name}\"`),\n  note: async (message, ref) => sh(`notes --ref=${ref} add -m '${String(message).replace(/'/g,\"'\\\\''\")}'`),\n  configUser: async (name,email) => { sh(`config user.name \"${name}\"`); sh(`config user.email \"${email}\"`); }\n};\n\nsrc/notes.js\nexport const NOTES_REF = \"refs/notes/gitvan\";\nexport const RESULTS_REF = \"refs/notes/gitvan/results\";\n\nsrc/config.js\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\n\nconst defaults = (cwd) => ({\n  repo: { dir: cwd, defaultBranch: \"main\", notesRef: \"refs/notes/gitvan\", resultsRef: \"refs/notes/gitvan/results\", signing: { require: false } },\n  llm:  { baseURL: process.env.OLLAMA_BASE || \"http://localhost:11434\", model: \"llama3.2\", temperature: 0.2 },\n  cookbook: { install: [] },\n  events: []\n});\n\nexport async function loadConfig(cwd = process.cwd()) {\n  let cfg = defaults(cwd);\n  const f = path.join(cwd, \"gitvan.config.js\");\n  if (fs.existsSync(f)) cfg = { ...cfg, ...(await import(pathToFileURL(f).href)).default };\n  return cfg;\n}\n\nsrc/workflow.js\nimport { git } from \"./git.js\";\nimport { NOTES_REF } from \"./notes.js\";\n\nexport async function sequence(msg){ await git.exec(`commit --allow-empty -m \"${msg}\"`); }\nexport async function milestone(tag){ await git.exec(`tag -a ${tag} -m \"${tag}\"`); }\nexport async function taskData(key,value){ await git.note(JSON.stringify({ kind:\"task-data\",[key]:value }), NOTES_REF); }\n\n@gitvan/cli\npackages/cli/package.json\n{\n  \"name\": \"@gitvan/cli\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"bin\": { \"gitvan\": \"bin/gitvan.js\" },\n  \"dependencies\": {\n    \"citty\": \"^0.1.6\",\n    \"@gitvan/core\": \"workspace:*\",\n    \"@gitvan/daemon\": \"workspace:*\",\n    \"@gitvan/llm\": \"workspace:*\",\n    \"@gitvan/schemas\": \"workspace:*\"\n  }\n}\n\nbin/gitvan.js\n#!/usr/bin/env node\nimport { defineCommand, runMain } from \"citty\";\nimport { git } from \"@gitvan/core/git\";\nimport { NOTES_REF, RESULTS_REF } from \"@gitvan/core/notes\";\nimport { loadConfig } from \"@gitvan/core/config\";\nimport * as wf from \"@gitvan/core\";\nimport * as daemon from \"@gitvan/daemon/loop\";\nimport { RecipeSchema } from \"@gitvan/schemas/recipe\";\nimport fs from \"node:fs\";\n\n// noun–verb\nconst repo = defineCommand({\n  meta: { name: \"repo\" },\n  subCommands: {\n    init: defineCommand({ run: async () => { await git.init({ dir: process.cwd() }); await git.configUser(\"Workflow Bot\",\"bot@example.com\"); console.log(\"repo ready\"); } }),\n    verify: defineCommand({ run: async () => console.log(\"verify ok\") })\n  }\n});\n\nconst recipe = defineCommand({\n  meta: { name: \"recipe\" },\n  subCommands: {\n    add: defineCommand({ args:{ file:{ type:\"positional\", required:true } }, run: async ({args}) => {\n      const obj = JSON.parse(fs.readFileSync(args.file,\"utf8\")); const j = RecipeSchema.parse(obj);\n      await git.note(JSON.stringify(j), NOTES_REF); console.log(\"added:\", j.name);\n    }}),\n    run: defineCommand({ args:{ id:{ type:\"positional\", required:true } }, run: async ({args}) => {\n      // scan notes for recipe with name/id, then apply minimal steps inline\n      const list = await git.exec(`notes --ref=${NOTES_REF} list`);\n      for (const l of list.split(\"\\n\").filter(Boolean)) {\n        const sha = l.split(\" \")[0]; const raw = await git.exec(`notes --ref=${NOTES_REF} show ${sha}`);\n        try { const r = JSON.parse(raw); if (r.kind===\"gitvan-recipe\" && (r.name===args.id||r.id===args.id)) {\n          for (const s of r.steps) {\n            if (s.kind===\"sequence\") await wf.sequence(s.args?.msg || s.id);\n            if (s.kind===\"milestone\") await wf.milestone(s.args?.tag || s.id);\n            if (s.kind===\"taskData\") await wf.taskData(s.args.key, s.args.value);\n            if (s.kind===\"cli-call\") await git.exec(`${s.args.cmd} ${(s.args.args||[]).join(\" \")}`);\n          }\n          await git.note(JSON.stringify({ kind:\"recipe-run\", name:r.name, ts:new Date().toISOString() }), RESULTS_REF);\n          console.log(\"ran:\", r.name); break;\n        }} catch {}\n      }\n    }})\n  }\n});\n\nconst cookbook = defineCommand({\n  meta: { name: \"cookbook\" },\n  subCommands: {\n    install: defineCommand({ args:{ name:{ type:\"positional\", required:true } }, run: async ({args}) => {\n      const p = new URL(`../../cookbook/recipes/${args.name}.json`, import.meta.url);\n      const json = fs.readFileSync(p, \"utf8\"); await git.note(json, NOTES_REF); console.log(\"installed:\", args.name);\n    }})\n  }\n});\n\nconst config = defineCommand({\n  meta: { name: \"config\" },\n  subCommands: {\n    show: defineCommand({ run: async () => console.log(JSON.stringify(await loadConfig(),null,2)) }),\n    apply: defineCommand({ run: async () => {\n      const cfg = await loadConfig();\n      for (const name of (cfg.cookbook?.install||[])) {\n        const p = new URL(`../../cookbook/recipes/${name}.json`, import.meta.url);\n        await git.note(fs.readFileSync(p,\"utf8\"), cfg.repo.notesRef || NOTES_REF);\n      }\n      await git.exec(`commit --allow-empty -m \"gitvan:config ${new Date().toISOString()}\"`);\n      for (const ev of (cfg.events||[])) await git.note(JSON.stringify(ev), cfg.repo.notesRef || NOTES_REF);\n      console.log(\"config applied\");\n    }})\n  }\n});\n\nconst daemonCmd = defineCommand({\n  meta: { name: \"daemon\" },\n  subCommands: {\n    start: defineCommand({ args:{ interval:{ type:\"string\", default:\"1500\" } }, run: async ({args}) => daemon.loop({ intervalMs:Number(args.interval) }) }),\n    once: defineCommand({ run: async () => daemon.tick() })\n  }\n});\n\nconst main = defineCommand({\n  meta: { name: \"gitvan\" },\n  subCommands: { repo, recipe, cookbook, config, daemon: daemonCmd }\n});\nrunMain(main);\n\n@gitvan/daemon\npackages/daemon/package.json\n{\n  \"name\": \"@gitvan/daemon\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./src/loop.js\",\n    \"./loop\": \"./src/loop.js\",\n    \"./predicates\": \"./src/predicates.js\",\n    \"./actions\": \"./src/actions.js\"\n  },\n  \"dependencies\": {\n    \"@gitvan/core\": \"workspace:*\",\n    \"@gitvan/llm\": \"workspace:*\"\n  }\n}\n\nsrc/predicates.js\nimport { git } from \"@gitvan/core/git\";\n\nexport async function commitMeta(sha){\n  const parents = (await git.exec(`rev-list --parents -n 1 ${sha}`)).split(\" \").slice(1);\n  const msg = await git.exec(`log -1 --pretty=%B ${sha}`);\n  const branches = (await git.exec(`branch --contains ${sha} --format=\"%(refname:short)\"`)).split(\"\\n\").filter(Boolean);\n  const tags = (await git.exec(`tag --contains ${sha}`)).split(\"\\n\").filter(Boolean);\n  return { isMerge: parents.length>=2, msg, branches, tags };\n}\n\nexport function isTimerDue(note, now = new Date()){\n  if (note.wf===\"cron\") return false; // cron omitted here\n  if (note.wf===\"timer\" && note.at) return new Date(note.at) <= now;\n  return false;\n}\n\nexport async function eventFires(note, sha, meta){\n  if (!note.on) return false;\n  const m = meta || await commitMeta(sha);\n  if (note.on.semverTag) return m.tags.some(t=>/^v?\\d+\\.\\d+\\.\\d+/.test(t));\n  return false;\n}\n\nsrc/actions.js\nimport { git } from \"@gitvan/core/git\";\nimport { RESULTS_REF } from \"@gitvan/core/notes\";\nimport { generate } from \"@gitvan/llm/provider\";\n\nexport async function runAction(note, sha){\n  if (note.run?.type===\"llm-call\") {\n    const text = await generate({ model: note.run.model, prompt: note.run.prompt });\n    await git.note(JSON.stringify({ kind:\"workflow-receipt\", id:note.id, status:\"OK\", ts:new Date().toISOString(), commit:sha, action:\"llm-call\", output:text }), RESULTS_REF);\n  }\n  if (note.run?.type===\"cli-call\") {\n    await git.exec(`${note.run.cmd} ${(note.run.args||[]).join(\" \")}`);\n    await git.note(JSON.stringify({ kind:\"workflow-receipt\", id:note.id, status:\"OK\", ts:new Date().toISOString(), commit:sha, action:\"cli-call\" }), RESULTS_REF);\n  }\n}\n\nsrc/loop.js\nimport { git } from \"@gitvan/core/git\";\nimport { NOTES_REF } from \"@gitvan/core/notes\";\nimport { isTimerDue, eventFires, commitMeta } from \"./predicates.js\";\nimport { runAction } from \"./actions.js\";\n\nasync function recentShas(){\n  const out = await git.exec(`log --pretty=%H -n 300 --no-show-signature`);\n  return out ? out.split(\"\\n\").filter(Boolean) : [];\n}\nasync function readNote(sha){\n  try { const raw = await git.exec(`notes --ref=${NOTES_REF} show ${sha}`); return JSON.parse(raw); }\n  catch { return null; }\n}\n\nexport async function tick(){\n  for (const sha of await recentShas()) {\n    const note = await readNote(sha); if (!note) continue;\n    const meta = await commitMeta(sha);\n    if (Array.isArray(note)) for (const n of note) if (isTimerDue(n) || await eventFires(n, sha, meta)) await runAction(n, sha);\n    else if (isTimerDue(note) || await eventFires(note, sha, meta)) await runAction(note, sha);\n  }\n}\nexport async function loop({ intervalMs=1500 }={}){ for(;;){ await tick(); await new Promise(r=>setTimeout(r, intervalMs)); } }\n\n@gitvan/llm\npackages/llm/package.json\n{\n  \"name\": \"@gitvan/llm\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./src/provider.js\",\n    \"./provider\": \"./src/provider.js\",\n    \"./embed\": \"./src/embed.js\"\n  }\n}\n\nsrc/provider.js\nimport { loadConfig } from \"@gitvan/core/config\";\n\nexport async function generate({ model, prompt, options = {} }){\n  const cfg = await loadConfig();\n  const base = cfg.llm?.baseURL || \"http://localhost:11434\";\n  const res = await fetch(`${base}/api/generate`, {\n    method: \"POST\", headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ model: model || cfg.llm?.model, prompt, options, stream: false })\n  });\n  const j = await res.json();\n  return j.response || \"\";\n}\n\nsrc/embed.js\nimport { loadConfig } from \"@gitvan/core/config\";\nexport async function embed({ model, text }){\n  const cfg = await loadConfig(); const base = cfg.llm?.baseURL || \"http://localhost:11434\";\n  const res = await fetch(`${base}/api/embeddings`, {\n    method:\"POST\", headers:{ \"content-type\":\"application/json\" },\n    body: JSON.stringify({ model, prompt: text })\n  });\n  return (await res.json()).embedding || [];\n}\n\n@gitvan/schemas\npackages/schemas/package.json\n{\n  \"name\": \"@gitvan/schemas\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./src/recipe.js\",\n    \"./recipe\": \"./src/recipe.js\",\n    \"./note\": \"./src/note.js\",\n    \"./receipt\": \"./src/receipt.js\"\n  },\n  \"dependencies\": { \"zod\": \"^3.23.8\" }\n}\n\nsrc/recipe.js\nimport { z } from \"zod\";\nconst Step = z.object({ id: z.string(), kind: z.enum([\"sequence\",\"milestone\",\"taskData\",\"cli-call\",\"llm-call\"]), args: z.record(z.any()).optional() });\nexport const RecipeSchema = z.object({ kind: z.literal(\"gitvan-recipe\"), name: z.string(), desc: z.string(), version: z.string(), tags: z.array(z.string()).default([]), steps: z.array(Step) });\n\nsrc/note.js\nimport { z } from \"zod\";\nexport const WorkflowNote = z.object({\n  id: z.string(),\n  wf: z.enum([\"timer\",\"cron\",\"event\"]),\n  at: z.string().optional(),\n  cron: z.string().optional(),\n  on: z.record(z.any()).optional(),\n  run: z.object({ type: z.enum([\"cli-call\",\"js-call\",\"llm-call\"]), cmd: z.string().optional(), args: z.array(z.string()).optional(), module: z.string().optional(), export: z.string().optional(), input: z.record(z.any()).optional(), model: z.string().optional(), prompt: z.string().optional() }).optional()\n});\n\nsrc/receipt.js\nimport { z } from \"zod\";\nexport const Receipt = z.object({\n  kind: z.literal(\"workflow-receipt\"),\n  id: z.string(),\n  status: z.enum([\"OK\",\"ERROR\",\"SKIP\"]),\n  ts: z.string(),\n  commit: z.string(),\n  action: z.enum([\"cli-call\",\"js-call\",\"llm-call\"]),\n  output: z.string().optional()\n});\n\n@gitvan/cookbook\npackages/cookbook/package.json\n{\n  \"name\": \"@gitvan/cookbook\",\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"files\": [\"recipes\"]\n}\n\nrecipes/dev-diary.json\n{\n  \"kind\": \"gitvan-recipe\",\n  \"name\": \"dev-diary\",\n  \"desc\": \"Summarize commits into a daily diary\",\n  \"version\": \"v0.1.0\",\n  \"tags\": [\"diary\",\"llm\"],\n  \"steps\": [\n    { \"id\":\"collect\", \"kind\":\"cli-call\", \"args\":{ \"cmd\":\"git\", \"args\":[\"log\",\"--since=1.day\",\"--oneline\"] } },\n    { \"id\":\"summarize\", \"kind\":\"llm-call\", \"args\":{ \"model\":\"llama3.2\", \"prompt\":\"Summarize today:\\\\n{{collect.output}}\" } },\n    { \"id\":\"store\", \"kind\":\"taskData\", \"args\":{ \"key\":\"dev-diary\", \"value\":\"{{summarize.output}}\" } }\n  ]\n}\n\nrecipes/changelog.json\n{\n  \"kind\": \"gitvan-recipe\",\n  \"name\": \"changelog\",\n  \"desc\": \"Generate CHANGELOG from last tag\",\n  \"version\": \"v0.1.0\",\n  \"tags\": [\"release\"],\n  \"steps\": [\n    { \"id\":\"since\", \"kind\":\"cli-call\", \"args\":{ \"cmd\":\"bash\", \"args\":[\"-lc\",\"git describe --tags --abbrev=0\"] } },\n    { \"id\":\"collect\", \"kind\":\"cli-call\", \"args\":{ \"cmd\":\"bash\", \"args\":[\"-lc\",\"git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s'\"] } },\n    { \"id\":\"write\", \"kind\":\"cli-call\", \"args\":{ \"cmd\":\"bash\", \"args\":[\"-lc\",\"echo \\\"## Unreleased\\n\\n{{collect.output}}\\\" > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: update changelog'\"] } }\n  ]\n}\n\nBootstrap\npnpm i\npnpm run cli repo init\npnpm run cli cookbook install dev-diary\npnpm run cli recipe run dev-diary\npnpm run cli daemon start\n\n\nThis is the complete, clean structure. No index.js. Explicit modules, export maps, JS-only.\n\nYou said:\nI like the idea that all you need for gitvan is package.json and gitvan.config.js \nChatGPT said:\nThought for 13s\n\nYes. Make gitvan a “two-file app”: only package.json + gitvan.config.js.\n\n1) package.json (npx, zero deps)\n{\n  \"name\": \"gitvan-twofile\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"scripts\": {\n    \"van\": \"npx -y @gitvan/cli\",\n    \"van:init\": \"npx -y @gitvan/cli repo init\",\n    \"van:apply\": \"npx -y @gitvan/cli config apply\",\n    \"van:daemon\": \"npx -y @gitvan/cli daemon start\"\n  }\n}\n\n2) gitvan.config.js\nexport default {\n  repo: {\n    dir: process.cwd(),\n    defaultBranch: \"main\",\n    notesRef: \"refs/notes/gitvan\",\n    resultsRef: \"refs/notes/gitvan/results\",\n    signing: { require: true }\n  },\n\n  // Optional: preinstall cookbook recipes by id\n  cookbook: {\n    install: [\"dev-diary\", \"changelog\"]\n  },\n\n  // Triggers → actions (materialized as git notes)\n  events: [\n    {\n      id: \"daily-dev-diary\",\n      wf: \"cron\",\n      cron: \"0 18 * * *\",\n      run: {\n        type: \"llm-call\",\n        model: \"llama3.2\",\n        prompt: \"Summarize today's commits into a diary entry.\"\n      }\n    },\n    {\n      id: \"on-semver-tag-changelog\",\n      wf: \"event\",\n      on: { semverTag: true },\n      run: {\n        type: \"cli-call\",\n        cmd: \"bash\",\n        args: [\n          \"-lc\",\n          \"git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: update changelog'\"\n        ]\n      }\n    }\n  ],\n\n  // Optional: inline recipe (no cookbook needed)\n  recipes: [\n    {\n      kind: \"gitvan-recipe\",\n      name: \"dev-diary-inline\",\n      desc: \"Summarize commits into a daily diary\",\n      version: \"v0.1.0\",\n      tags: [\"diary\",\"llm\"],\n      steps: [\n        { id: \"collect\",  kind: \"cli-call\", args: { cmd: \"git\",  args: [\"log\",\"--since=1.day\",\"--oneline\"] } },\n        { id: \"summarize\",kind: \"llm-call\", args: { model: \"llama3.2\", prompt: \"Summarize today:\\\\n{{collect.output}}\" } },\n        { id: \"store\",    kind: \"taskData\", args: { key: \"dev-diary\", value: \"{{summarize.output}}\" } }\n      ]\n    }\n  ],\n\n  // LLM defaults (used by @gitvan/llm)\n  llm: { baseURL: process.env.OLLAMA_BASE || \"http://localhost:11434\", model: \"llama3.2\", temperature: 0.2 }\n};\n\nQuickstart\ngit init && git add -A && git commit -m \"init\"\nnpm run van:init\nnpm run van:apply         # installs cookbook items + writes events + inline recipes as notes\nnpm run van:daemon        # start autonomic loop\n\nWhat this gives you\n\nZero project scaffolding: no src/, no TypeScript, no build.\n\nAll state in Git: config → notes; runs → signed receipts under refs/notes/gitvan/results.\n\nCookbook or inline: pull recipes by id, or ship them inline in gitvan.config.js.\n\nNoun–verb ops via npx @gitvan/cli: repo init, config apply, daemon start, recipe run dev-diary-inline.\n\nYou said:\nI want you to think about variations on the config file are there defaults? For instance we can infer what kind of event it is based on the js we dont need wf?\nChatGPT said:\nThought for 12s\n\nShort answer: yes. Make wf optional. Infer it. Ship sane defaults and sugar → normalize to a canonical note.\n\nDefaults\n\nrepo.dir = process.cwd()\n\nrepo.defaultBranch = main\n\nrepo.notesRef = refs/notes/gitvan\n\nrepo.resultsRef = refs/notes/gitvan/results\n\nrepo.signing.require = true\n\nllm.baseURL = http://localhost:11434\n\nllm.model = llama3.2\n\nllm.temperature = 0.2\n\nInference rules\n\nEvent kind:\n\ncron → wf = 'cron'\n\nat → wf = 'timer'\n\non → wf = 'event'\n\nAction:\n\nrun string with scheme → normalize\n\ncli:echo \"hi\" → {type:'cli-call', cmd:'bash', args:['-lc','echo \"hi\"']}\n\njs:./task.mjs#exportName → {type:'js-call', module:'./task.mjs', export:'exportName'}\n\nllm:MODEL|PROMPT → {type:'llm-call', model:'MODEL', prompt:'PROMPT'}\n\nrun object with {prompt} but no model → use default llm.model\n\nPredicates sugar (on can be string or array):\n\n'semverTag' → {semverTag:true}\n\n'mergeTo:main' → {mergeTo:'main'}\n\n'pushTo:release/*' → {pushTo:'release/*'}\n\n'pathChanged:src/**' → {pathChanged:'src/**'}\n\n'signed' → {signed:true}\n\nMinimal → Canonical examples\nMinimal\nexport default {\n  events: [\n    { id: 'daily-diary', cron: '0 18 * * *', run: 'llm:llama3.2|Summarize today’s commits.' },\n    { id: 'changelog-on-tag', on: 'semverTag', run: 'cli:git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:\\'* %s\\' > CHANGELOG.md && git add CHANGELOG.md && git commit -m \"chore: update changelog\"' }\n  ]\n}\n\nCanonical (what daemon sees)\n[\n  {\n    id: 'daily-diary',\n    wf: 'cron',\n    cron: '0 18 * * *',\n    run: { type: 'llm-call', model: 'llama3.2', prompt: 'Summarize today’s commits.' }\n  },\n  {\n    id: 'changelog-on-tag',\n    wf: 'event',\n    on: { semverTag: true },\n    run: { type: 'cli-call', cmd: 'bash', args: ['-lc','git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:\\'* %s\\' > CHANGELOG.md && git add CHANGELOG.md && git commit -m \"chore: update changelog\"'] }\n  }\n]\n\nNormalizer (JS, ESM, no TS)\n// gitvan-normalize.mjs\nconst defaults = {\n  repo: { dir: process.cwd(), defaultBranch: 'main', notesRef: 'refs/notes/gitvan', resultsRef: 'refs/notes/gitvan/results', signing: { require: true } },\n  llm:  { baseURL: 'http://localhost:11434', model: 'llama3.2', temperature: 0.2 }\n};\n\nexport function normalizeConfig(cfg = {}) {\n  const base = { ...defaults, ...cfg, repo: { ...defaults.repo, ...(cfg.repo||{}) }, llm: { ...defaults.llm, ...(cfg.llm||{}) } };\n  const events = toArray(cfg.events).map(e => normalizeEvent(e, base));\n  const recipes = toArray(cfg.recipes || []);\n  return { ...base, events, recipes };\n}\n\nfunction normalizeEvent(e, base) {\n  const id = e.id || hash(JSON.stringify(e)).slice(0,12);\n  const wf = e.wf || inferWf(e);\n  const on = normalizeOn(e.on);\n  const run = normalizeRun(e.run, base);\n  const out = { id, wf, run };\n  if (e.cron) out.cron = e.cron;\n  if (e.at) out.at = e.at;\n  if (on) out.on = on;\n  return out;\n}\n\nfunction inferWf(e) { if (e.cron) return 'cron'; if (e.at) return 'timer'; if (e.on) return 'event'; return 'event'; }\n\nfunction normalizeOn(on) {\n  if (!on) return null;\n  if (typeof on === 'string') return parseOnToken(on);\n  if (Array.isArray(on)) return { any: on.map(parseOnToken) };\n  if (typeof on === 'object') return on;\n  return null;\n}\n\nfunction parseOnToken(tok) {\n  if (tok === 'semverTag') return { semverTag: true };\n  if (tok === 'signed') return { signed: true };\n  const [k,v] = String(tok).split(':');\n  if (k === 'mergeTo') return { mergeTo: v };\n  if (k === 'pushTo') return { pushTo: v };\n  if (k === 'pathChanged') return { pathChanged: v };\n  return { message: tok };\n}\n\nfunction normalizeRun(run, base) {\n  if (typeof run === 'string') return parseRunString(run, base);\n  if (!run?.type && run?.prompt) return { type: 'llm-call', model: base.llm.model, prompt: run.prompt };\n  return run;\n}\n\nfunction parseRunString(s, base) {\n  if (s.startsWith('cli:')) return { type: 'cli-call', cmd: 'bash', args: ['-lc', s.slice(4)] };\n  if (s.startsWith('js:')) {\n    const body = s.slice(3); const [mod, exp='default'] = body.split('#');\n    return { type: 'js-call', module: mod, export: exp };\n  }\n  if (s.startsWith('llm:')) {\n    const body = s.slice(4); const [model, ...rest] = body.split('|');\n    return { type: 'llm-call', model: model || base.llm.model, prompt: rest.join('|') };\n  }\n  return { type: 'cli-call', cmd: 'bash', args: ['-lc', s] };\n}\n\nfunction toArray(x){ return Array.isArray(x) ? x : (x ? [x] : []); }\nfunction hash(x){ return Bun?.hash ? String(Bun.hash(x)) : String(x.split('').reduce((a,c)=>((a<<5)-a)+c.charCodeAt(0)|0,0)>>>0); }\n\nSuggested config variants\nVariant A — Ultra-minimal\nexport default {\n  events: [\n    { id: 'diary', cron: '0 18 * * *', run: 'llm:|Summarize today’s commits.' },\n    { id: 'relnotes', on: 'semverTag', run: 'cli:./scripts/release-notes.sh' }\n  ]\n}\n\nVariant B — Object map, IDs as keys\nexport default {\n  events: {\n    diary: { cron: '0 18 * * *', run: 'llm:llama3.2|Summarize today' },\n    changelog: { on: ['semverTag','signed'], run: 'cli:gitvan recipe run changelog' }\n  }\n}\n\n\nNormalize by turning the map into an array with id = key.\n\nVariant C — Full canonical (explicit wf allowed but optional)\nexport default {\n  events: [\n    { id:'X', wf:'event', on:{ mergeTo:'main', signed:true }, run:{ type:'cli-call', cmd:'node', args:['scripts/verify.js'] } }\n  ]\n}\n\n\nUse this: infer where possible, let power users be explicit if they want.\n\nYou said:\nOk are there any other best practices we could leverage \nChatGPT said:\nThought for 6s\n\nYes. Use these.\n\nConfig\n\nSingle source: gitvan.config.js only. Normalize sugar → canonical.\n\nLayering: load .gitvan.local.js last for machine overrides.\n\nIDs: stable, kebab-case. Prefix by domain, e.g. docs-changelog.\n\nVersions: configVersion: 1 and recipe.version semver.\n\nNamespacing\n\nNotes: refs/notes/gitvan and refs/notes/gitvan/results.\n\nLocks: refs/workflow/executions/<id>.\n\nPolicies: refs/gitvan/policy/* (deny/allow lists, JSON).\n\nDeterminism\n\nEnv: TZ=UTC, LANG=C, fixed PATH subset.\n\nInputs by hash or SHA. No ambient clock in recipes.\n\nLLM: set seed when model supports it; always record model+params+prompt.\n\nSecurity\n\nRequire signed merges/tags; signing.require = true.\n\nSoD: different signer for merge vs author (enforced by hook).\n\nCLI allowlist: only run from scripts/ and pnpm dlx tools you pin.\n\nPath scopes: predicates restricted to src/**, packages/**.\n\nSchema & receipts\n\nZod on load and before note write.\n\nReceipts minimal and uniform:\n\nid, ts, commit, action, status, outputHash?, error?\n\nOne event → one receipt. No multi-write per step.\n\nPerformance\n\nShallow queries: --no-show-signature, capped lookback.\n\nBatch note ops when applying config.\n\nAvoid git describe in hot paths; cache last tag in a note.\n\nDX\n\nNoun–verb CLI only. No flags unless needed.\n\ngitvan config apply idempotent.\n\ngitvan diagnose prints: notes ref, last 5 receipts, signer, default model.\n\nConventions\n\nCommit trailers for routing:\n\nType: feature|fix|docs\n\nDecision: adr-0123\n\nRisk: low|med|high\n\nTags: semver only for releases. Milestones as ms/<name>.\n\nTesting (happy path)\n\nGolden fixtures: run recipe → compare results notes.\n\n“Once” mode: daemon once for CI smoke.\n\nCookbook hygiene\n\nRecipes self-contained. No external env unless explicit.\n\nProvide README.md + inputs/outputs table per recipe.\n\nKeep scripts tiny; prefer git commands over bespoke code.\n\nLLM usage\n\nShort prompts with explicit structure. Avoid freeform.\n\nAlways store raw output and outputHash.\n\nUse embeddings only with capped dims and recorded model.\n\nFailure stance\n\nFail fast on invalid config or missing tools.\n\nNever auto-retry without explicit retry block.\n\nKeep errors human; attach one-line cause in receipt.\n\nExample guards (concise)\n// allowlist for CLI actions\nallow: { cmd: [/^bash$/, /^node$/, /^pnpm$/], paths: [/^scripts\\//] }\n\n// policy ref sketch (JSON under refs/gitvan/policy/allow-cli.json)\n{ \"cmd\": [\"bash\",\"node\",\"pnpm\"], \"paths\": [\"scripts/\"] }\n\n\nApply these and keep everything in Git: config → notes, policy → refs, runs → receipts.\n\nYou said:\nOk. I also like nitro and nuxt. So can we have an events directory you can drop\n\ndefine\nChatGPT said:\nThought for 18s\n\nYes. Add a file-based events API like Nuxt/Nitro.\n\nLayout\nrepo/\n  gitvan.config.js         # optional\n  events/\n    daily-dev-diary.mjs\n    changelog-on-tag.mjs\n    build-on-merge.mjs\n\nAuthoring API\n// events/daily-dev-diary.mjs\nimport { defineEvent } from \"@gitvan/core/events\";\n\nexport default defineEvent({\n  id: \"daily-dev-diary\",          // default = file path kebab\n  cron: \"0 18 * * *\",             // wf inferred: cron\n  run: \"llm:llama3.2|Summarize today’s commits.\"\n});\n\n// events/changelog-on-tag.mjs\nimport { defineEvent } from \"@gitvan/core/events\";\n\nexport default defineEvent({\n  on: \"semverTag\",                // wf inferred: event\n  run: \"cli:git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: update changelog'\"\n});\n\n// events/build-on-merge.mjs\nimport { defineEvent } from \"@gitvan/core/events\";\n\nexport default defineEvent({\n  on: [\"mergeTo:main\",\"signed\"],\n  run: \"cli:pnpm -C scripts build\"\n});\n\nLoader (happy path, ESM, JS)\n\n@gitvan/core/src/events.js\n\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\n\nexport function defineEvent(spec){ return spec; } // sugar\n\nexport async function loadEventsDir(cwd = process.cwd()) {\n  const dir = path.join(cwd, \"events\");\n  if (!fs.existsSync(dir)) return [];\n  const files = walk(dir).filter(f => /\\.(mjs|js)$/.test(f));\n  const out = [];\n  for (const f of files) {\n    const mod = await import(pathToFileURL(f).href);\n    const raw = (mod.default && typeof mod.default === \"object\") ? mod.default : mod;\n    const id = raw.id || toId(path.relative(dir, f));\n    out.push(normalizeEvent({ id, ...raw }));\n  }\n  return out;\n}\n\nfunction walk(dir, acc = []) {\n  for (const e of fs.readdirSync(dir, { withFileTypes:true })) {\n    const p = path.join(dir, e.name);\n    if (e.isDirectory()) walk(p, acc); else acc.push(p);\n  }\n  return acc;\n}\n\nfunction toId(rel){ return rel.replace(/\\.(mjs|js)$/, \"\").replace(/[\\\\/]/g, \"-\"); }\n\nfunction normalizeEvent(e){\n  const wf = e.wf || (e.cron ? \"cron\" : e.at ? \"timer\" : \"event\");\n  const on = normOn(e.on);\n  const run = normRun(e.run);\n  const out = { id: e.id, wf, run };\n  if (e.cron) out.cron = e.cron;\n  if (e.at) out.at = e.at;\n  if (on) out.on = on;\n  return out;\n}\n\nfunction normOn(on){\n  if (!on) return null;\n  if (typeof on === \"string\") return tok(on);\n  if (Array.isArray(on)) return { any: on.map(tok) };\n  return on; // already object\n}\nfunction tok(t){\n  if (t === \"semverTag\") return { semverTag: true };\n  if (t === \"signed\") return { signed: true };\n  const [k,v] = String(t).split(\":\");\n  if (k===\"mergeTo\") return { mergeTo:v };\n  if (k===\"pushTo\") return { pushTo:v };\n  if (k===\"pathChanged\") return { pathChanged:v };\n  return { message: t };\n}\n\nfunction normRun(run){\n  if (!run) return null;\n  if (typeof run !== \"string\") return run;\n  if (run.startsWith(\"cli:\")) return { type:\"cli-call\", cmd:\"bash\", args:[\"-lc\", run.slice(4)] };\n  if (run.startsWith(\"js:\"))  { const body = run.slice(3); const [m,e=\"default\"]=body.split(\"#\"); return { type:\"js-call\", module:m, export:e }; }\n  if (run.startsWith(\"llm:\")) { const body = run.slice(4); const [model, ...rest]=body.split(\"|\"); return { type:\"llm-call\", model:model||\"llama3.2\", prompt:rest.join(\"|\") }; }\n  return { type:\"cli-call\", cmd:\"bash\", args:[\"-lc\", run] };\n}\n\nWire into CLI\n\nExtend gitvan config apply to include events directory:\n\n// inside packages/cli/bin/gitvan.js\nimport { loadEventsDir } from \"@gitvan/core/events\";\n\n// in config.apply run()\nconst fromDir = await loadEventsDir();\nfor (const ev of fromDir) await git.note(JSON.stringify(ev), cfg.repo.notesRef || NOTES_REF);\n\nBehavior\n\nDrop a file in events/ → gitvan config apply writes canonical notes.\n\nwf optional; inferred from cron|at|on.\n\non can be string, array, or object.\n\nrun supports cli:, js:, llm: shorthands.\n\nNuxt/Nitro friendly\n\nSame file-based convention as server/routes or server/api.\n\nPure ESM modules; no TS required.\n\nWorks in any Node workspace; no build step needed.\n\nThat’s it.\n\nYou said:\n# 📍 unrouting\n\n[![npm version][npm-version-src]][npm-version-href]\n[![npm downloads][npm-downloads-src]][npm-downloads-href]\n[![bundle][bundle-src]][bundle-href]\n[![Codecov][codecov-src]][codecov-href]\n[![License][license-src]][license-href]\n[![JSDocs][jsdocs-src]][jsdocs-href]\n\n> Making filesystem routing universal\n\n## 🚧 In development\n\nThis library is a work in progress and in active development.\n\n- [ ] generic route parsing function with options to cover major filesystem routing patterns\n  - [x] [Nuxt](https://github.com/nuxt/nuxt)\n  - [x] [unplugin-vue-router](https://github.com/posva/unplugin-vue-router) (does not include dot-syntax nesting support)\n- [ ] export capability for framework routers\n  - [x] RegExp patterns\n  - [x] [vue-router](https://router.vuejs.org/) routes\n  - [x] [rou3](http://github.com/h3js/rou3)/[Nitro](https://nitro.unjs.io/) routes\n  - [ ] [SolidStart](https://start.solidjs.com/core-concepts/routing)\n  - [ ] [SvelteKit](https://kit.svelte.dev/docs/routing) routes\n- [ ] support scanning FS (with optional watch mode)\n- [ ] and more\n\n## Usage\n\nInstall package:\n\n\nsh\n# npm\nnpm install unrouting\n\n# pnpm\npnpm install unrouting\n\n\n### Basic Parsing\n\n\njs\nimport { parsePath } from 'unrouting'\n\n// Parse file paths into segments with mode detection\nconst [result] = parsePath(['users/[id]/profile.vue'])\nconsole.log(result.segments)\n// [\n//   [{ type: 'static', value: 'users' }],\n//   [{ type: 'dynamic', value: 'id' }],\n//   [{ type: 'static', value: 'profile' }]\n// ]\nconsole.log(result.meta) // undefined (no metadata detected)\n\n\n### Mode Detection\n\n\njs\nimport { parsePath } from 'unrouting'\n\n// Configure mode detection for .server, .client suffixes\nconst [result] = parsePath(['app.server.vue'], {\n  modes: ['server', 'client']\n})\n\nconsole.log(result.meta?.modes) // ['server']\nconsole.log(result.segments) // [[{ type: 'static', value: 'app' }]]\n\n// Multiple modes\nconst [result2] = parsePath(['api.server.edge.js'], {\n  modes: ['server', 'client', 'edge']\n})\nconsole.log(result2.meta?.modes) // ['server', 'edge']\nconsole.log(result2.segments) // [[{ type: 'static', value: 'api' }]]\n\n\n### Named Views\n\n\njs\nimport { parsePath } from 'unrouting'\n\n// Named views with @ suffix (for Vue Router named views)\nconst [result] = parsePath(['dashboard@sidebar.vue'])\nconsole.log(result.meta?.name) // 'sidebar'\nconsole.log(result.segments) // [[{ type: 'static', value: 'dashboard' }]]\n\n// Named views with modes\nconst [result2] = parsePath(['admin@main.client.vue'], {\n  modes: ['client', 'server']\n})\nconsole.log(result2.meta) // { name: 'main', modes: ['client'] }\n\n// Nested named views\nconst [result3] = parsePath(['users/[id]@profile.vue'])\nconsole.log(result3.meta?.name) // 'profile'\nconsole.log(result3.segments)\n// [\n//   [{ type: 'static', value: 'users' }],\n//   [{ type: 'dynamic', value: 'id' }]\n// ]\n\n\n### Convert to Router Formats\n\n\njs\nimport { parsePath, toRegExp, toRou3, toVueRouter4 } from 'unrouting'\n\nconst [result] = parsePath(['users/[id]/posts/[slug].vue'])\n\n// Vue Router 4 format\nconst [vueRoute] = toVueRouter4([result])\nconsole.log(vueRoute.path) // '/users/:id()/posts/:slug()'\n\n// Rou3/Nitro format\nconst [nitroRoute] = toRou3([result])\nconsole.log(nitroRoute) // '/users/:id/posts/:slug'\n\n// RegExp pattern\nconst [regexpRoute] = toRegExp([result])\nconsole.log(regexpRoute.pattern) // /^\\/users\\/([^\\/]+)\\/posts\\/([^\\/]+)\\/?$/\nconsole.log(regexpRoute.keys) // ['id', 'slug']\n\n// Or pass file paths directly to converters\nconst [vueRoute2] = toVueRouter4(['users/[id]/posts/[slug].vue'])\nconst [nitroRoute2] = toRou3(['users/[id]/posts/[slug].vue'])\nconst [regexpRoute2] = toRegExp(['users/[id]/posts/[slug].vue'])\n\n\n### Advanced Examples\n\n\njs\nimport { parsePath, toRegExp, toVueRouter4 } from 'unrouting'\n\n// Repeatable parameters ([slug]+.vue -> one or more segments)\nconst [repeatable] = parsePath(['posts/[slug]+.vue'])\nconst [vueRoute1] = toVueRouter4([repeatable])\nconsole.log(vueRoute1.path) // '/posts/:slug+'\n\n// Optional repeatable parameters ([[slug]]+.vue -> zero or more segments)\nconst [optionalRepeatable] = parsePath(['articles/[[slug]]+.vue'])\nconst [vueRoute2] = toVueRouter4([optionalRepeatable])\nconsole.log(vueRoute2.path) // '/articles/:slug*'\n\n// Group segments (ignored in final path, useful for organization)\nconst [grouped] = parsePath(['(admin)/(dashboard)/users/[id].vue'])\nconst [vueRoute3] = toVueRouter4([grouped])\nconsole.log(vueRoute3.path) // '/users/:id()'\n// Groups are parsed but excluded from path generation\n\n// Catchall routes ([...slug].vue -> captures remaining path)\nconst [catchall] = parsePath(['docs/[...slug].vue'])\nconst [vueRoute4] = toVueRouter4([catchall])\nconsole.log(vueRoute4.path) // '/docs/:slug(.*)*'\n\n// Optional parameters ([[param]].vue -> parameter is optional)\nconst [optional] = parsePath(['products/[[category]]/[[id]].vue'])\nconst [vueRoute5] = toVueRouter4([optional])\nconsole.log(vueRoute5.path) // '/products/:category?/:id?'\n\n// Complex mixed patterns\nconst [complex] = parsePath(['shop/[category]/product-[id]-[[variant]].vue'])\nconst [vueRoute6] = toVueRouter4([complex])\nconsole.log(vueRoute6.path)\n// '/shop/:category()/product-:id()-:variant?'\n\n// Proper regex matching with anchoring (fixes partial match issues)\nconst [pattern] = toRegExp(['[slug].vue'])\nconsole.log(pattern.pattern) // /^\\/(?<slug>[^/]+)\\/?$/\nconsole.log('/file'.match(pattern.pattern)) // ✅ matches\nconsole.log('/test/thing'.match(pattern.pattern)) // ❌ null (properly rejected)\n\n\n## API\n\n### parsePath(filePaths, options?)\n\nParse file paths into route segments with mode detection.\n\n**Parameters:**\n- filePaths (string[]): Array of file paths to parse\n- options (object, optional):\n  - extensions (string[]): File extensions to strip (default: all extensions)\n  - modes (string[]): Mode suffixes to detect (e.g., ['server', 'client'])\n  - warn (function): Warning callback for invalid characters\n\n**Returns:** ParsedPath[]\n\nts\ninterface ParsedPath {\n  segments: ParsedPathSegment[]\n  meta?: {\n    modes?: string[] // Detected mode suffixes (e.g., ['client', 'server'])\n    name?: string // Named view from @name suffix\n  }\n}\n\n\n### toVueRouter4(filePaths)\n\nConvert parsed segments or file paths to Vue Router 4 format.\n\n**Parameters:**\n- filePaths (string[] | ParsedPath[]): Array of file paths or parsed path objects\n\n**Returns:** Array<{ path: string }>\n\n### toRou3(filePaths)\n\nConvert parsed segments or file paths to Rou3/Nitro format.\n\n**Parameters:**\n- filePaths (string[] | ParsedPath[]): Array of file paths or parsed path objects\n\n**Returns:** string[]\n\n### toRegExp(filePaths)\n\nConvert parsed segments or file paths to RegExp patterns.\n\n**Parameters:**\n- filePaths (string[] | ParsedPath[]): Array of file paths or parsed path objects\n\n**Returns:** Array<{ pattern: RegExp, keys: string[] }>\n\n## 💻 Development\n\n- Clone this repository\n- Enable [Corepack](https://github.com/nodejs/corepack) using corepack enable (use npm i -g corepack for Node.js < 16.10)\n- Install dependencies using pnpm install\n- Run interactive tests using pnpm dev\n\n## License\n\nMade with ❤️\n\nPublished under [MIT License](./LICENCE).\n\n<!-- Badges -->\n\n[npm-version-src]: https://img.shields.io/npm/v/unrouting?style=flat&colorA=18181B&colorB=F0DB4F\n[npm-version-href]: https://npmjs.com/package/unrouting\n[npm-downloads-src]: https://img.shields.io/npm/dm/unrouting?style=flat&colorA=18181B&colorB=F0DB4F\n[npm-downloads-href]: https://npmjs.com/package/unrouting\n[codecov-src]: https://img.shields.io/codecov/c/gh/unjs/unrouting/main?style=flat&colorA=18181B&colorB=F0DB4F\n[codecov-href]: https://codecov.io/gh/unjs/unrouting\n[bundle-src]: https://img.shields.io/bundlephobia/minzip/unrouting?style=flat&colorA=18181B&colorB=F0DB4F\n[bundle-href]: https://bundlephobia.com/result?p=unrouting\n[license-src]: https://img.shields.io/github/license/unjs/unrouting.svg?style=flat&colorA=18181B&colorB=F0DB4F\n[license-href]: https://github.com/unjs/unrouting/blob/main/LICENSE\n[jsdocs-src]: https://img.shields.io/badge/jsDocs.io-reference-18181B?style=flat&colorA=18181B&colorB=F0DB4F\n[jsdocs-href]: https://www.jsdocs.io/package/unrouting\n\n\nWe are going to fully utilize the Unjs ecosystem \n\nChatGPT said:\nThought for 30s\n\nPlan: make gitvan “UnJS-first” while staying Git-only at core.\n\nAdopt these libs\n\nc12: config loader (gitvan.config.*, .local, env merge).\n\ndefu: deep defaults merge.\n\npathe: path utils.\n\nconsola: logging.\n\nofetch (+ ufo): HTTP to LLMs.\n\nhookable: lifecycle hooks.\n\nunrouting: file-based events/ → canonical events.\n\nunbuild: bundle packages (optional).\n\nNitro + h3: optional local API/dashboard, no server required to run core.\n\nMinimal replacements\n1) Config loader (c12 + defu)\n// packages/core/src/config.js\nimport { loadConfig as c12 } from 'c12'\nimport { defu } from 'defu'\n\nconst defaults = {\n  repo: { defaultBranch: 'main', notesRef: 'refs/notes/gitvan', resultsRef: 'refs/notes/gitvan/results', signing: { require: true } },\n  llm: { baseURL: 'http://localhost:11434', model: 'llama3.2', temperature: 0.2 },\n  events: [],\n  recipes: []\n}\n\nexport async function loadConfig(cwd = process.cwd()) {\n  const { config } = await c12({\n    name: 'gitvan',\n    cwd,\n    dotenv: true, // .env support\n    defaults\n  })\n  return defu(config || {}, defaults)\n}\n\n2) Events directory (unrouting)\n// packages/core/src/events.js\nimport { parsePath } from 'unrouting'\nimport { join } from 'pathe'\nimport fs from 'node:fs'\n\nexport async function loadEventsDir(cwd = process.cwd()) {\n  const dir = join(cwd, 'events')\n  if (!fs.existsSync(dir)) return []\n  const files = fs.readdirSync(dir).filter(f => f.endsWith('.mjs') || f.endsWith('.js'))\n  // infer ids from filenames; map sugar → canonical\n  return files.map(f => {\n    const id = f.replace(/\\.(mjs|js)$/, '')\n    const mod = await import(join(dir, f).toString())\n    const raw = mod.default || mod\n    return normalizeEvent({ id, ...raw })\n  })\n}\n\nfunction normalizeEvent(e) {\n  const wf = e.cron ? 'cron' : e.at ? 'timer' : 'event'\n  const run = typeof e.run === 'string' ? normRun(e.run) : e.run\n  return { id: e.id, wf, cron: e.cron, at: e.at, on: normOn(e.on), run }\n}\n\nfunction normRun(s) {\n  if (s.startsWith('cli:')) return { type:'cli-call', cmd:'bash', args:['-lc', s.slice(4)] }\n  if (s.startsWith('js:'))  { const [m,e='default']=s.slice(3).split('#'); return { type:'js-call', module:m, export:e } }\n  if (s.startsWith('llm:')) { const [model,...p]=s.slice(4).split('|'); return { type:'llm-call', model, prompt:p.join('|') } }\n  return { type:'cli-call', cmd:'bash', args:['-lc', s] }\n}\n\nfunction normOn(on) {\n  if (!on) return null\n  const tok = t => t==='semverTag' ? { semverTag:true }\n    : t==='signed' ? { signed:true }\n    : t.startsWith('mergeTo:') ? { mergeTo:t.split(':')[1] }\n    : t.startsWith('pushTo:') ? { pushTo:t.split(':')[1] }\n    : t.startsWith('pathChanged:') ? { pathChanged:t.split(':')[1] }\n    : { message:t }\n  if (typeof on === 'string') return tok(on)\n  if (Array.isArray(on)) return { any: on.map(tok) }\n  return on\n}\n\n3) LLM client (ofetch + ufo)\n// packages/llm/src/provider.js\nimport { ofetch } from 'ofetch'\nimport { withQuery } from 'ufo'\nimport { loadConfig } from '@gitvan/core/config'\n\nexport async function generate({ model, prompt, options = {} }) {\n  const cfg = await loadConfig()\n  const base = cfg.llm.baseURL\n  const post = ofetch.create({ baseURL: base })\n  const res = await post('/api/generate', { method:'POST', body: { model: model || cfg.llm.model, prompt, options, stream:false } })\n  return res.response || ''\n}\n\n4) Hooks (hookable)\n// packages/daemon/src/hooks.js\nimport { createHooks } from 'hookable'\nexport const hooks = createHooks()\n// use: await hooks.callHook('before:action', note), etc.\n\n\nWire in loop:\n\n// packages/daemon/src/loop.js\nimport { hooks } from './hooks.js'\n...\nif (due) { await hooks.callHook('before:action', note); await runAction(note, sha); await hooks.callHook('after:action', note); }\n\n5) Logging (consola)\n// anywhere\nimport { createConsola } from 'consola'\nexport const log = createConsola({ level: 3 })\nlog.start('daemon start'); log.success('ran %s', note.id)\n\n6) Optional Nitro UI/API (purely optional)\napps/dashboard/\n  nitro.config.ts\n  server/api/receipts.get.ts\n  server/api/events.get.ts\n\n\nserver/api/receipts.get.ts\n\nimport { defineEventHandler } from 'h3'\nimport { git } from '@gitvan/core/git'\nexport default defineEventHandler(async () => {\n  const list = await git.exec('notes --ref=refs/notes/gitvan/results list')\n  return list.split('\\n').filter(Boolean).map(l => {\n    const sha = l.split(' ')[0]\n    const raw = await git.exec(`notes --ref=refs/notes/gitvan/results show ${sha}`)\n    return JSON.parse(raw)\n  })\n})\n\n\nRun locally: npx nitro dev to browse receipts; core still Git-only.\n\nTwo-file app stays intact\n\nKeep package.json + gitvan.config.js flow.\n\ngitvan config apply should:\n\nLoad config via c12.\n\nMerge events from events/ via unrouting loader.\n\nMaterialize canonical notes.\n\nSuggested deps (root)\n{\n  \"dependencies\": {\n    \"c12\": \"^1.5.0\",\n    \"defu\": \"^6.1.4\",\n    \"pathe\": \"^1.1.2\",\n    \"consola\": \"^3.2.3\",\n    \"ofetch\": \"^1.3.4\",\n    \"ufo\": \"^1.5.3\",\n    \"hookable\": \"^5.5.3\",\n    \"unrouting\": \"^0.3.0\"\n  },\n  \"devDependencies\": { \"unbuild\": \"^2.0.0\", \"nitro\": \"^2.9.0\", \"h3\": \"^1.12.0\" }\n}\n\nFile-based events examples\n// events/dev-diary.mjs\nexport default { cron: '0 18 * * *', run: 'llm:llama3.2|Summarize today’s commits.' }\n\n// events/changelog-on-tag.mjs\nexport default { on: 'semverTag', run: 'cli:pnpm -C scripts changelog' }\n\n\nThis leverages UnJS everywhere it adds value while preserving the core contract: Git is the runtime.\n\nYou said:\nLets maximize usage of hookable\nChatGPT said:\nThought for 22s\n\nYes. Make hooks the spine. Define a small, stable hook map and run everything through it. Pure JS, ESM, happy path.\n\n1) Hook map (names + payloads)\n\nAll hooks receive a mutable context object. Plugins mutate in place.\n\nconfig:load:before      { cwd, sources }\nconfig:load:after       { config }\n\nconfig:apply:before     { config, notesRef }\nconfig:apply:after      { config, wrote: number }\n\ndaemon:start            { intervalMs }\ndaemon:tick:before      { shas: string[] }\ndaemon:tick:after       { ran: number }\n\nevent:match:before      { note, sha, meta, matched: boolean }\nevent:match:after       { note, sha, matched: boolean }\n\naction:before           { note, sha, action }            // action = 'cli'|'js'|'llm'\naction:after            { note, sha, action, output }    // output may be string\n\nreceipt:before          { note, sha, receipt }           // mutate/add fields\nreceipt:after           { note, sha, receiptRef }\n\nnote:write:before       { ref, message }                 // mutate message\nnote:write:after        { ref, sha }\n\nllm:before              { model, prompt, options }\nllm:after               { model, prompt, options, output }\n\ncli:before              { cmd, args, env }\ncli:after               { cmd, args, code: 0 }\n\npolicy:check            { kind, payload }                // throw or set payload.blocked=true\n\n2) Singleton hooks\n\npackages/daemon/src/hooks.js\n\nimport { createHooks } from 'hookable'\nexport const hooks = createHooks()\nexport const on  = hooks.hook.bind(hooks)         // register\nexport const run = hooks.callHook.bind(hooks)     // serial\nexport const runP= hooks.callHookParallel?.bind?.(hooks) || run\n\n3) Wire hooks into core paths\nconfig load/apply\n\npackages/core/src/config.js\n\nimport { loadConfig as c12 } from 'c12'\nimport { defu } from 'defu'\nimport { run } from '@gitvan/daemon/hooks'\n\nconst defaults = { repo:{ defaultBranch:'main', notesRef:'refs/notes/gitvan', resultsRef:'refs/notes/gitvan/results', signing:{require:true}}, llm:{ baseURL:'http://localhost:11434', model:'llama3.2', temperature:0.2 }, events:[], recipes:[], plugins:[] }\n\nexport async function loadConfig(cwd=process.cwd()){\n  const ctx = { cwd, sources:['gitvan.config.*'] }\n  await run('config:load:before', ctx)\n  const { config } = await c12({ name:'gitvan', cwd, dotenv:true, defaults })\n  const merged = defu(config||{}, defaults)\n  const out = { config: merged }\n  await run('config:load:after', out)\n  return out.config\n}\n\n\npackages/cli/bin/gitvan.js (inside config apply)\n\nimport { run } from '@gitvan/daemon/hooks'\n// ...\nawait run('config:apply:before', { config: cfg, notesRef: cfg.repo.notesRef })\n/* write notes, events, recipes … increment wrote */\nawait run('config:apply:after', { config: cfg, wrote })\n\ndaemon loop\n\npackages/daemon/src/loop.js\n\nimport { run } from './hooks.js'\nimport { git } from '@gitvan/core/git'\nimport { NOTES_REF, RESULTS_REF } from '@gitvan/core/notes'\nimport { commitMeta } from './predicates.js'\nimport { runAction } from './actions.js'\n\nexport async function tick(){\n  const shas = await recentShas()\n  await run('daemon:tick:before', { shas })\n  let ran = 0\n  for (const sha of shas) {\n    const note = await readNote(sha); if (!note) continue\n    const meta = await commitMeta(sha)\n    const list = Array.isArray(note) ? note : [note]\n    for (const n of list) {\n      const matchCtx = { note:n, sha, meta, matched:false }\n      await run('event:match:before', matchCtx)\n      const matched = matchCtx.matched || await isDueOrFires(n, sha, meta)\n      await run('event:match:after', { note:n, sha, matched })\n      if (!matched) continue\n\n      const out = await runActionWithHooks(n, sha)\n      const receipt = { kind:'workflow-receipt', id:n.id, status:'OK', ts:new Date().toISOString(), commit:sha, action:out.kind, output:out.output }\n      const rctx = { note:n, sha, receipt }\n      await run('receipt:before', rctx)\n      const refSha = await git.note(JSON.stringify(rctx.receipt), RESULTS_REF)\n      await run('receipt:after', { note:n, sha, receiptRef: refSha })\n      ran++\n    }\n  }\n  await run('daemon:tick:after', { ran })\n}\n\nasync function runActionWithHooks(note, sha){\n  if (note.run?.type === 'llm-call') {\n    const ctx = { model: note.run.model, prompt: note.run.prompt, options: note.run.options||{} }\n    await run('llm:before', ctx)\n    const output = await llmGenerate(ctx) // uses ctx.model/prompt/options\n    await run('llm:after', { ...ctx, output })\n    return { kind:'llm', output }\n  }\n  if (note.run?.type === 'cli-call') {\n    const ctx = { cmd: note.run.cmd, args: note.run.args||[], env: {} }\n    await run('cli:before', ctx)\n    await execCLI(ctx) // use ctx.cmd/args/env\n    await run('cli:after', { ...ctx, code: 0 })\n    return { kind:'cli' }\n  }\n  return { kind:'noop' }\n}\n\nnote writes (centralize)\n\npackages/core/src/git.js\n\nimport { run } from '@gitvan/daemon/hooks'\nconst sh = (cmd) => execSync(`git -C \"${process.cwd()}\" ${cmd}`, { stdio:[\"ignore\",\"pipe\",\"inherit\"] }).toString().trim()\n\nexport const git = {\n  // ...\n  note: async (message, ref) => {\n    const ctx = { ref, message }\n    await run('note:write:before', ctx)\n    const sha = sh(`notes --ref=${ctx.ref} add -m '${String(ctx.message).replace(/'/g,\"'\\\\''\")}'`)\n    await run('note:write:after', { ref: ctx.ref, sha })\n    return sha\n  }\n}\n\n4) Plugin loader\n\npackages/core/src/plugins.js\n\nimport { pathToFileURL } from 'node:url'\nimport { join } from 'pathe'\nimport { on } from '@gitvan/daemon/hooks'\nimport { loadConfig } from './config.js'\n\nexport async function loadPlugins(cwd=process.cwd()){\n  const cfg = await loadConfig(cwd)\n  for (const p of (cfg.plugins||[])) {\n    const url = p.startsWith('.') || p.startsWith('/') ? pathToFileURL(join(cwd, p)).href : p\n    const mod = await import(url)\n    const reg = mod.default || mod.register || mod.plugin\n    if (typeof reg === 'function') await reg({ on })\n  }\n}\n\n\nCall once early (CLI entry and daemon start):\n\nimport { loadPlugins } from '@gitvan/core/plugins'\nawait loadPlugins()\n\n5) Example plugins\nA) CLI allowlist (policy)\n\nplugins/allow-cli.mjs\n\nexport default ({ on }) => {\n  const allowCmd = /^(bash|node|pnpm)$/\n  const allowPath = /^scripts\\//\n  on('cli:before', (ctx) => {\n    if (!allowCmd.test(ctx.cmd)) throw new Error('cli blocked: cmd')\n    if (ctx.args?.[0] === '-lc' && typeof ctx.args[1] === 'string' && !ctx.args[1].startsWith('git ') && !ctx.args[1].startsWith('echo ') ) {\n      // allow simple safe commands; real policy up to you\n    }\n  })\n}\n\nB) LLM prompt decorator\n\nplugins/prompt-prefix.mjs\n\nexport default ({ on }) => {\n  on('llm:before', (ctx) => {\n    ctx.prompt = `[repo:${process.cwd()}]\\n${ctx.prompt}`\n    ctx.options = { ...ctx.options, seed: 7 }\n  })\n}\n\nC) Secret redactor for receipts/notes\n\nplugins/redact.mjs\n\nconst re = /(AKIA[0-9A-Z]{16}|ghp_[0-9A-Za-z]{36})/g\nexport default ({ on }) => {\n  on('receipt:before', (ctx) => {\n    if (typeof ctx.receipt.output === 'string') ctx.receipt.output = ctx.receipt.output.replace(re, '***')\n  })\n  on('note:write:before', (ctx) => {\n    if (typeof ctx.message === 'string') ctx.message = ctx.message.replace(re, '***')\n  })\n}\n\nD) Metrics to notes\n\nplugins/metrics.mjs\n\nimport { git } from '@gitvan/core/git'\nimport { RESULTS_REF } from '@gitvan/core/notes'\nexport default ({ on }) => {\n  let count = 0\n  on('daemon:tick:after', async ({ ran }) => {\n    count += ran\n    if (count >= 50) {\n      await git.note(JSON.stringify({ kind:'metric', executions: count, ts: new Date().toISOString() }), RESULTS_REF)\n      count = 0\n    }\n  })\n}\n\nE) Reviewer router on event match\n\nplugins/reviewer-route.mjs\n\nexport default ({ on }) => {\n  on('event:match:after', (ctx) => {\n    if (!ctx.matched) return\n    // attach reviewer suggestion to note object so receipt includes it\n    ctx.note.suggestedReviewer = 'alice'\n  })\n}\n\n6) Use in config\n\ngitvan.config.js\n\nexport default {\n  plugins: [\n    './plugins/allow-cli.mjs',\n    './plugins/prompt-prefix.mjs',\n    './plugins/redact.mjs',\n    './plugins/metrics.mjs',\n    './plugins/reviewer-route.mjs'\n  ],\n  events: [\n    { id:'daily-diary', cron:'0 18 * * *', run:'llm:llama3.2|Summarize today’s commits.' },\n    { id:'tag-changelog', on:'semverTag', run:'cli:pnpm -C scripts changelog' }\n  ]\n}\n\n7) Event files can register too\n\nevents/build-on-merge.mjs\n\nexport const register = ({ on }) => {\n  on('action:before', (ctx) => {\n    if (ctx.action === 'cli') ctx.env = { ...ctx.env, CI:'1' }\n  })\n}\n\nexport default { on:['mergeTo:main','signed'], run:'cli:pnpm -C scripts build' }\n\n\nLoader: if an event module exports register, call it during loadEventsDir().\n\n8) Conventions\n\nHook names: namespace:verb.\n\nPayloads are mutable. No returns. Short, synchronous by default; await when needed.\n\nAvoid try/catch here. Fail fast. Let a plugin add on('policy:check', …) if desired.\n\nThis turns gitvan into a hook-first runtime: every path is observable and rewritable, without changing core.\n\nYou said:\n# 🍦 unctx\n\n> Composition-API in Vanilla js\n\n[![npm version][npm-v-src]][npm-v-href]\n[![npm downloads][npm-dm-src]][npm-dm-href]\n[![package phobia][packagephobia-src]][packagephobia-href]\n[![bundle phobia][bundlephobia-src]][bundlephobia-href]\n[![codecov][codecov-src]][codecov-href]\n\n## What is unctx?\n\n[Vue.js](https://vuejs.org) introduced an amazing pattern called [Composition API](https://v3.vuejs.org/guide/composition-api-introduction.html) that allows organizing complex logic by splitting it into reusable functions and grouping in logical order. unctx allows easily implementing composition API pattern in your javascript libraries without hassle.\n\n## Usage\n\nIn your **awesome** library:\n\n\nbash\nyarn add unctx\n# or\nnpm install unctx\n\n\n\njs\nimport { createContext } from \"unctx\";\n\nconst ctx = createContext();\n\nexport const useAwesome = ctx.use;\n\n// ...\nctx.call({ test: 1 }, () => {\n  // This is similar to the vue setup function\n  // Any function called here can use `useAwesome` to get { test: 1 }\n});\n\n\nUser code:\n\n\njs\nimport { useAwesome } from \"awesome-lib\";\n\n// ...\nfunction setup() {\n  const ctx = useAwesome();\n}\n\n\n**Note:** When no context is presented ctx.use will throw an error. Use ctx.tryUse for tolerant usages (return nullable context).\n\n### Using Namespaces\n\nTo avoid issues with multiple version of the library, unctx provides a safe global namespace to access context by key (kept in [globalThis](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis)). **Important:** Please use a verbose name for the key to avoid conflict with other js libraries. Using the npm package name is recommended. Using symbols has no effect since it still causes multiple context issues.\n\n\njs\nimport { useContext, getContext } from \"unctx\";\n\nconst useAwesome = useContext(\"awesome-lib\");\n\n// or\n// const awesomeContext = getContext('awesome-lib')\n\n\nYou can also create your internal namespace with createNamespace utility for more advanced use cases.\n\n## Async Context\n\nUsing context is only possible in non-async usages and only before the first await statement. This is to make sure context is not shared between concurrent calls.\n\n\njs\nasync function setup() {\n  console.log(useAwesome()); // Returns context\n  setTimeout(() => {\n    console.log(useAwesome());\n  }, 1); // Returns null\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n  console.log(useAwesome()); // Returns null\n}\n\n\nA simple workaround is caching context into a local variable:\n\n\njs\nasync function setup() {\n  const ctx = useAwesome(); // We can directly access cached version of ctx\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n  console.log(ctx);\n}\n\n\nThis is not always an elegant and easy way by making a variable and passing it around. After all, this is the purpose of unctx to make sure context is magically available everywhere in composables!\n\n### Native Async Context\n\nUnctx supports Node.js [AsyncLocalStorage](https://nodejs.org/api/async_context.html#class-asynclocalstorage) as a native way to preserve and track async contexts. To enable this mode, you need to set asyncContext: true option and also provides an implementation for AsyncLocalStorage (or provide globalThis.AsyncLocalStorage polyfill).\n\nSee [tc39 proposal for async context](https://github.com/tc39/proposal-async-context) and [cloudflare docs](https://developers.cloudflare.com/workers/runtime-apis/nodejs/asynclocalstorage/) for relevant platform specific docs.\n\n\nts\nimport { createContext } from \"unctx\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nconst ctx = createContext({\n  asyncContext: true,\n  AsyncLocalStorage,\n});\n\nctx.call(\"123\", () => {\n  setTimeout(() => {\n    // Prints 123\n    console.log(ctx.use());\n  }, 100);\n});\n\n\n### Async Transform\n\nSince native async context is not supported in all platforms yet, unctx provides a build-time solution that transforms async syntax to automatically restore context after each async/await statement. This requires using a bundler such as Rollup, Vite, or Webpack.\n\nImport and register transform plugin:\n\n\njs\nimport { unctxPlugin } from \"unctx/plugin\";\n\n// Rollup\n// TODO: Add to rollup configuration\nunctxPlugin.rollup();\n\n// Vite\n// TODO: Add to vite configuration\nunctxPlugin.vite();\n\n// Webpack\n// TODO: Add to webpack configuration\nunctxPlugin.webpack();\n\n\nUse ctx.callAsync instead of ctx.call:\n\n\njs\nawait ctx.callAsync(\"test\", setup);\n\n\n**_NOTE:_** callAsync is not transformed by default. You need to add it to the plugin's asyncFunctions: [] option to transform it.\n\nAny async function that requires context, should be wrapped with withAsyncContext:\n\n\njs\nimport { withAsyncContext } from \"unctx\";\n\nconst setup = withAsyncContext(async () => {\n  console.log(useAwesome()); // Returns context\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n  console.log(useAwesome()); // Still returns context with dark magic!\n});\n\n\n## Singleton Pattern\n\nIf you are sure it is safe to use a shared instance (not depending to request), you can also use ctx.set and ctx.unset for a [singleton pattern](https://en.wikipedia.org/wiki/Singleton_pattern).\n\n**Note:** You cannot combine set with call. Always use unset before replacing the instance otherwise you will get Context conflict error.\n\n\njs\nimport { createContext } from \"unctx\";\n\nconst ctx = createContext();\nctx.set(new Awesome());\n\n// Replacing instance without unset\n// ctx.set(new Awesome(), true)\n\nexport const useAwesome = ctx.use;\n\n\n## Typed Context\n\nA generic type exists on all utilities to be set for instance/context type for typescript support.\n\n\nts\n// Return type of useAwesome is Awesome | null\nconst { use: useAwesome } = createContext<Awesome>();\n\n\n## Under the hood\n\nThe composition of functions is possible using temporary context injection. When calling ctx.call(instance, cb), instance argument will be stored in a temporary variable then cb is called. Any function inside cb, can then implicitly access the instance by using ctx.use (or useAwesome)\n\n## Pitfalls\n\n**context can be only used before first await**:\n\nPlease check [Async Context](#async-context) section.\n\n**Context conflict error**:\n\nIn your library, you should only keep one call() running at a time (unless calling with the same reference for the first argument)\n\nFor instance, this makes an error:\n\n\njs\nctx.call({ test: 1 }, () => {\n  ctx.call({ test: 2 }, () => {\n    // Throws error!\n  });\n});\n\n\n## License\n\nMIT. Made with 💖\n\n<!-- Refs -->\n\n[npm-v-src]: https://flat.badgen.net/npm/v/unctx/latest\n[npm-v-href]: https://npmjs.com/package/unctx\n[npm-dm-src]: https://flat.badgen.net/npm/dm/unctx\n[npm-dm-href]: https://npmjs.com/package/unctx\n[packagephobia-src]: https://flat.badgen.net/packagephobia/install/unctx\n[packagephobia-href]: https://packagephobia.now.sh/result?p=unctx\n[bundlephobia-src]: https://flat.badgen.net/bundlephobia/min/unctx\n[bundlephobia-href]: https://bundlephobia.com/result?p=unctx\n[codecov-src]: https://flat.badgen.net/codecov/c/github/unjs/unctx/master\n[codecov-href]: https://codecov.io/gh/unjs/unctx\nChatGPT said:\nThought for 11s\n\nYes. Wire unctx in as the runtime context for gitvan. Minimal surface, async-safe, hook-first.\n\n1) Context singleton\n\npackages/core/src/ctx.js\n\nimport { createContext } from \"unctx\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nconst gv = createContext({\n  asyncContext: true,\n  AsyncLocalStorage\n});\n\nexport const useVan = gv.use;          // throw if missing\nexport const tryUseVan = gv.tryUse;    // null if missing\nexport const callVan = gv.call.bind(gv);\nexport const callVanAsync = gv.callAsync?.bind(gv) || ((val, fn) => Promise.resolve(gv.call(val, fn)));\nexport { default as withAsyncContext } from \"unctx/with-async-context\"; // optional if you use the transform\n\n\nExport map:\n\n// @gitvan/core/package.json\n{\n  \"exports\": {\n    \"./ctx\": \"./src/ctx.js\",\n    \"...\": \"./src/...\"\n  }\n}\n\n2) Put context around daemon execution\n\npackages/daemon/src/loop.js\n\nimport { callVanAsync } from \"@gitvan/core/ctx\";\nimport { loadConfig } from \"@gitvan/core/config\";\nimport { git } from \"@gitvan/core/git\";\nimport { NOTES_REF, RESULTS_REF } from \"@gitvan/core/notes\";\nimport { isTimerDue, eventFires, commitMeta } from \"./predicates.js\";\nimport { runAction } from \"./actions.js\";\nimport { run } from \"./hooks.js\";\n\nexport async function tick(){\n  const cfg = await loadConfig();\n  const shas = await git.exec(`log --pretty=%H -n 300 --no-show-signature`).then(s => s.split(\"\\n\").filter(Boolean));\n  await run(\"daemon:tick:before\", { shas });\n\n  let ran = 0;\n  for (const sha of shas) {\n    const raw = await git.exec(`notes --ref=${cfg.repo.notesRef||NOTES_REF} show ${sha}`).catch(()=>null);\n    if (!raw) continue;\n    const meta = await commitMeta(sha);\n    const list = Array.isArray(JSON.parse(raw)) ? JSON.parse(raw) : [JSON.parse(raw)];\n\n    for (const note of list) {\n      const matched = (isTimerDue(note) || await eventFires(note, sha, meta));\n      await run(\"event:match:after\", { note, sha, matched });\n      if (!matched) continue;\n\n      // Context per execution\n      await callVanAsync({ cfg, sha, note, meta, refs:{ NOTES_REF, RESULTS_REF }, git }, async () => {\n        await run(\"action:before\", { note, sha, action: note.run?.type || \"noop\" });\n        const out = await runAction(note, sha); // everything inside can use useVan()\n        const receipt = { kind:\"workflow-receipt\", id:note.id, status:\"OK\", ts:new Date().toISOString(), commit:sha, action:out.kind, output: out.output };\n        await run(\"receipt:before\", { note, sha, receipt });\n        await git.note(JSON.stringify(receipt), cfg.repo.resultsRef || RESULTS_REF);\n        await run(\"receipt:after\", { note, sha, receiptRef: sha });\n        ran++;\n        await run(\"action:after\", { note, sha, action: out.kind, output: out.output });\n      });\n    }\n  }\n  await run(\"daemon:tick:after\", { ran });\n}\n\n3) Make LLM/provider context-aware\n\npackages/llm/src/provider.js\n\nimport { tryUseVan } from \"@gitvan/core/ctx\";\nimport { loadConfig } from \"@gitvan/core/config\";\n\nexport async function generate({ model, prompt, options = {} }) {\n  const ctx = tryUseVan();\n  const cfg = ctx?.cfg || await loadConfig();\n  const base = cfg.llm?.baseURL || \"http://localhost:11434\";\n  const res = await fetch(`${base}/api/generate`, {\n    method:\"POST\", headers:{ \"content-type\":\"application/json\" },\n    body: JSON.stringify({ model: model || cfg.llm?.model, prompt, options, stream:false })\n  });\n  const j = await res.json();\n  return j.response || \"\";\n}\n\n4) CLI runs inside context\n\npackages/cli/bin/gitvan.js\n\nimport { callVan } from \"@gitvan/core/ctx\";\nimport { loadConfig } from \"@gitvan/core/config\";\nimport { git } from \"@gitvan/core/git\";\n// ...\nconst runRecipe = defineCommand({\n  // ...\n  run: async ({ args }) => {\n    const cfg = await loadConfig();\n    await callVan({ cfg, git }, async () => {\n      // apply steps; inside, useVan() is available to plugins/actions\n      // ...\n    });\n  }\n});\n\n5) Actions use useVan() instead of re-loading\n\npackages/daemon/src/actions.js\n\nimport { useVan } from \"@gitvan/core/ctx\";\nimport { generate } from \"@gitvan/llm/provider\";\n\nexport async function runAction(note){\n  const { git, cfg } = useVan();\n  if (note.run?.type === \"llm-call\") {\n    const output = await generate({ model: note.run.model, prompt: note.run.prompt, options: note.run.options||{} });\n    return { kind:\"llm\", output };\n  }\n  if (note.run?.type === \"cli-call\") {\n    await git.exec(`${note.run.cmd} ${(note.run.args||[]).join(\" \")}`);\n    return { kind:\"cli\" };\n  }\n  return { kind:\"noop\" };\n}\n\n6) Hooks and plugins can read/modify context\n\nExample plugin that pins env and prefixes prompts:\n\nplugins/ctx-hardening.mjs\n\nimport { useVan } from \"@gitvan/core/ctx\";\n\nexport default ({ on }) => {\n  on(\"cli:before\", (ctx) => {\n    const { cfg } = useVan();\n    ctx.env = { TZ:\"UTC\", LANG:\"C\", ...ctx.env };\n    if (cfg.repo?.signing?.require) ctx.env.GIT_TRACE = \"1\";\n  });\n\n  on(\"llm:before\", (ctx) => {\n    const { sha } = useVan();\n    ctx.prompt = `[commit:${sha}]\\n` + ctx.prompt;\n    ctx.options = { seed: 7, ...ctx.options };\n  });\n};\n\n7) Events files can use context helpers\n\nevents/build-on-merge.mjs\n\nexport const register = ({ on }) => {\n  on(\"action:before\", (ctx) => {\n    const { note } = require(\"@gitvan/core/ctx\").useVan(); // ESM: import at top\n    if (ctx.action === \"cli\" && note?.on?.mergeTo === \"main\") ctx.env = { ...ctx.env, CI:\"1\" };\n  });\n};\nexport default { on:[\"mergeTo:main\",\"signed\"], run:\"cli:pnpm -C scripts build\" };\n\n8) Optional: transform for broad async usage\n\nIf you need context inside deep await chains everywhere, enable unctx plugin at build time and wrap long asyncs with withAsyncContext. Not required for happy path.\n\nResult: single source of truth passed through the system. Hooks, actions, LLM, CLI, and plugins all share state via useVan(). Deterministic, minimal, no boilerplate.\n\nYou said:\nLets go back to the 43 patterns. What do they look like now?\nChatGPT said:\nThought for 12s\n\nThey’re now canonical notes + recipe steps. Each pattern compiles to a tiny JSON “step” (for one-shot runs) or an event note (for daemon-driven runs). Hooks enforce policy; context (useVan()) carries repo/config.\n\nControl-flow (20)\n\nSequence → empty commit\n\n{\"kind\":\"sequence\",\"args\":{\"msg\":\"step\"}}\n\n\nParallel Split → spawn branch\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"checkout\",\"-b\",\"feat-A\"]}}\n\n\nSynchronization → merge no-ff\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"merge\",\"--no-ff\",\"feat-A\"]}}\n\n\nExclusive Choice → pick one branch\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"checkout\",\"fast-track\"]}}\n\n\nSimple Merge → fast merge\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"merge\",\"topic\"]}}\n\n\nMulti-Choice → N branches from main\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"bash\",\"args\":[\"-lc\",\"for b in A B; do git checkout -b $b; done\"]}}\n\n\nSynchronizing Merge (structured) → merge planned set\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"bash\",\"args\":[\"-lc\",\"git checkout main && git merge --no-ff A B\"]}}\n\n\nMulti-Merge → repeated merges back\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"bash\",\"args\":[\"-lc\",\"for b in A B C; do git merge --no-ff $b; done\"]}}\n\n\nDiscriminator (first finisher wins) → event + hook decides first\n\n// events/discriminator.mjs\nexport default { on: [\"pushTo:feat-*\"], run: \"js:./scripts/discriminator.mjs#acceptFirst\" }\n\n\nArbitrary Cycles → tag loop point + repeat\n\n{\"kind\":\"milestone\",\"args\":{\"tag\":\"loop-1\"}}\n\n\nImplicit Termination → structure signals done (no step)\n(document via receipt note:)\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"implicit-termination\",\"value\":\"true\"}}\n\n\nMI no Sync → N parallel, no join\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"bash\",\"args\":[\"-lc\",\"for i in 1 2 3; do git checkout -b mi-$i; done\"]}}\n\n\nMI design-time N → as above with fixed N\n\nMI runtime-known N → js computes N\n\n{\"kind\":\"js-call\",\"args\":{\"module\":\"./scripts/mi.js\",\"export\":\"spawn\",\"input\":{\"countFromEnv\":true}}}\n\n\nMI runtime-unknown → producer appends branches\n\n{\"kind\":\"js-call\",\"args\":{\"module\":\"./scripts/mi.js\",\"export\":\"produce\"}}\n\n\nDeferred Choice → decide at merge time via policy hook\n\nexport default { on:[\"mergeTo:staging\",\"signed\"], run:\"js:./scripts/deferred.mjs#decide\" }\n\n\nInterleaved Parallel → serialize critical section via hook\n\nexport default { on:\"pathChanged:src/**\", run:\"cli:pnpm test\" } // hook enforces mutex\n\n\nMilestone → tag\n\n{\"kind\":\"milestone\",\"args\":{\"tag\":\"v1.0.0\"}}\n\n\nCancel Task → revert HEAD\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"revert\",\"--no-edit\",\"HEAD\"]}}\n\n\nCancel Case → hard reset\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"reset\",\"--hard\",\"origin/main\"]}}\n\nData (9)\n\nTask Data → git note on current commit\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"owner\",\"value\":\"sean\"}}\n\n\nBlock Data → note at block tag\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"block:billing\",\"value\":\"P1\"}}\n\n\nCase Data → note on mainline commit\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"case\",\"value\":\"ABC-42\"}}\n\n\nTransfer by Value → add blob to tree\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"bash\",\"args\":[\"-lc\",\"cp input.json data/ && git add data/input.json && git commit -m 'data:input'\"]}}\n\n\nTransfer by Reference → submodule\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"submodule\",\"add\",\"https://repo/url\",\"deps/x\"]}}\n\n\nData-based Routing → route by message/notes\n\nexport default { on:\"message:^TYPE:refund\", run:\"cli:git checkout refund-lane\" }\n\n\nExternal Input → structured note JSON\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"external\",\"value\":{\"wf\":\"timer\",\"at\":\"2025-12-01T00:00:00Z\"}}}\n\n\nData Validation → js predicate throws on fail (hook or step)\n\n{\"kind\":\"js-call\",\"args\":{\"module\":\"./scripts/validate.mjs\",\"export\":\"assertClean\"}}\n\n\nData Versioning → tag snapshots\n\n{\"kind\":\"milestone\",\"args\":{\"tag\":\"snapshot-2025-09-15\"}}\n\nResource (9)\n\nRole-based Allocation → signer/GPG key\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"role\",\"value\":\"reviewer:KEYID_A\"}}\n\n\nOrganizational Allocation → group label in notes\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"org\",\"value\":\"payments\"}}}\n\n\nSeparation of Duties → hook enforces distinct signers on merge\n\nexport default { on:\"mergeTo:main\", run:\"cli:git merge --no-ff feature\" } // SoD hook checks\n\n\nRetain Familiar → require same signer as before (hook)\n(step not needed; policy plugin enforces)\n\nCapability-based Routing → note + branch\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"capability\",\"value\":\"android-build\"}}\n\n\nResource Pool → pool branch strategy\n\n{\"kind\":\"cli-call\",\"args\":{\"cmd\":\"git\",\"args\":[\"checkout\",\"-b\",\"pool/runner-1\"]}}\n\n\nCase Ownership → owner note\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"owner\",\"value\":\"alice\"}}\n\n\nDirect Allocation → explicit signer key (policy consumes)\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"signer\",\"value\":\"KEYID_B\"}}\n\n\nWork Prioritization → priority note + lane\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"priority\",\"value\":\"P1\"}}\n\nException / Time (5)\n\nTimeout / Escalation → deadline encoded; hook enforces on merge\n\nexport default { on:\"mergeTo:main\", run:\"js:./scripts/timeout.mjs#enforce\" }\n\n\nRepeat-Until → loop with predicate\n\n{\"kind\":\"js-call\",\"args\":{\"module\":\"./scripts/repeat.mjs\",\"export\":\"untilGreen\"}}\n\n\nRetry with Backoff → action wrapper uses hook to retry\n\nexport default { on:\"pushTo:retry/*\", run:\"js:./scripts/retry.mjs#run\" }\n\n\nCompensation / Saga → chained reverts plan\n\n{\"kind\":\"js-call\",\"args\":{\"module\":\"./scripts/compensate.mjs\",\"export\":\"saga\"}}\n\n\nProvenance / Audit → PROV-like note + receipts\n\n{\"kind\":\"taskData\",\"args\":{\"key\":\"provenance\",\"value\":\"prov:build->test->release\"}}\n\nCanonical event note (what the daemon consumes)\n{\n  \"id\":\"daily-dev-diary\",\n  \"wf\":\"cron\",\n  \"cron\":\"0 18 * * *\",\n  \"run\":{\"type\":\"llm-call\",\"model\":\"llama3.2\",\"prompt\":\"Summarize today\"}\n}\n\nCLI noun–verb examples\ngitvan recipe run changelog\ngitvan daemon start\ngitvan config apply\n\nHooks you’ll actually use\n\nevent:match:* to encode Discriminator, Interleaved Parallel, Deferred Choice.\n\npolicy:* to enforce SoD, Retain Familiar, Timeout.\n\nreceipt:* to attach proofs for Provenance/Audit.\n\nEverything remains Git-only: commits, merges, tags, notes, receipts.\n\nYou said:\nOk lets now rewrite the readme\nChatGPT said:\nThought for 8s\ngitvan\n\nGit-only workflow engine. 43 van der Aalst patterns as tiny JSON steps and events. No servers. No runners. No DB. JS only.\n\nWhy\n\nGit is state, queue, audit.\n\nNotes and tags are receipts.\n\nHooks and plugins control policy.\n\nTwo files to start.\n\nInstall\n# zero-scaffold\ngit init\nnpm pkg set type=module\nnpm i -D @gitvan/cli\n\nTwo-file app\npackage.json\n{\n  \"name\": \"my-repo\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"scripts\": {\n    \"van\": \"gitvan\",\n    \"van:init\": \"gitvan repo init\",\n    \"van:apply\": \"gitvan config apply\",\n    \"van:daemon\": \"gitvan daemon start\"\n  }\n}\n\ngitvan.config.js\nexport default {\n  repo: {\n    defaultBranch: \"main\",\n    notesRef: \"refs/notes/gitvan\",\n    resultsRef: \"refs/notes/gitvan/results\",\n    signing: { require: true }\n  },\n\n  // inline recipes (optional)\n  recipes: [{\n    kind: \"gitvan-recipe\",\n    name: \"dev-diary-inline\",\n    version: \"0.1.0\",\n    steps: [\n      { id:\"collect\",   kind:\"cli-call\", args:{ cmd:\"git\", args:[\"log\",\"--since=1.day\",\"--oneline\"] } },\n      { id:\"summarize\", kind:\"llm-call\", args:{ model:\"llama3.2\", prompt:\"Summarize today:\\\\n{{collect.output}}\" } },\n      { id:\"store\",     kind:\"taskData\", args:{ key:\"dev-diary\", value:\"{{summarize.output}}\" } }\n    ]\n  }],\n\n  // triggers → actions; wf inferred\n  events: [\n    { id:\"daily-dev-diary\", cron:\"0 18 * * *\", run:\"llm:llama3.2|Summarize today’s commits.\" },\n    { id:\"changelog-on-tag\", on:\"semverTag\",\n      run:\"cli:git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: changelog'\" }\n  ],\n\n  // optional plugins (file or package)\n  plugins: [\"./plugins/redact.mjs\"]\n}\n\n\nRun:\n\nnpm run van:init\nnpm run van:apply\nnpm run van:daemon\n\n\nOutputs: signed receipts under refs/notes/gitvan/results.\n\nEvents directory (Nuxt-style)\n\nDrop files in events/. gitvan config apply normalizes and writes notes.\n\nevents/\n  daily-dev-diary.mjs\n  changelog-on-tag.mjs\n\n// events/daily-dev-diary.mjs\nexport default { cron: \"0 18 * * *\", run: \"llm:llama3.2|Summarize today’s commits.\" }\n\n// events/changelog-on-tag.mjs\nexport default { on: \"semverTag\", run: \"cli:pnpm -C scripts changelog\" }\n\nDefaults and inference\n\nrepo.defaultBranch=main\n\nnotesRef=refs/notes/gitvan, resultsRef=refs/notes/gitvan/results\n\nwf inferred: cron → cron, at → timer, on → event\n\nrun shorthands:\n\ncli:<shell> → {type:\"cli-call\", cmd:\"bash\", args:[\"-lc\", \"<shell>\"]}\n\njs:./task.mjs#fn → {type:\"js-call\", module:\"./task.mjs\", export:\"fn\"}\n\nllm:MODEL|PROMPT → {type:\"llm-call\", model:\"MODEL\", prompt:\"PROMPT\"}\n\nCLI (noun-verb)\ngitvan repo init\ngitvan config show\ngitvan config apply\ngitvan cookbook install <name>\ngitvan recipe run <id>\ngitvan daemon start\ngitvan daemon once\ngitvan diagnose\n\nPatterns (43) → Git\n\nAll patterns compile to steps or events. Examples:\n\nSequence → empty commit: {\"kind\":\"sequence\",\"args\":{\"msg\":\"step\"}}\n\nParallel split → git checkout -b feat-A (cli-call)\n\nSynchronization → git merge --no-ff feat-A\n\nExclusive choice → git checkout fast-track\n\nMilestone → {\"kind\":\"milestone\",\"args\":{\"tag\":\"v1.0.0\"}}\n\nDiscriminator → event + hook selects first merge\n\nCancel task → git revert --no-edit HEAD\n\nCase data / task data → {\"kind\":\"taskData\",\"args\":{\"key\":\"owner\",\"value\":\"alice\"}}\n\nTimeout / SoD / Interleaved → enforced by hooks on merges\n\nFull list is in /cookbook as recipes.\n\nHooks (spine)\n\nPowered by hookable. All payloads are mutable.\n\nconfig:load:before|after\n\nconfig:apply:before|after\n\ndaemon:start · daemon:tick:before|after\n\nevent:match:before|after\n\naction:before|after (cli|js|llm)\n\nllm:before|after\n\ncli:before|after\n\nreceipt:before|after\n\nnote:write:before|after\n\npolicy:check\n\nPlugin example\n// plugins/redact.mjs\nexport default ({ on }) => {\n  const re = /(AKIA[0-9A-Z]{16}|ghp_[0-9A-Za-z]{36})/g\n  on(\"receipt:before\", (ctx) => {\n    if (typeof ctx.receipt.output === \"string\") ctx.receipt.output = ctx.receipt.output.replace(re, \"***\")\n  })\n  on(\"cli:before\", (ctx) => { ctx.env = { TZ:\"UTC\", LANG:\"C\", ...ctx.env } })\n}\n\n\nDeclare in gitvan.config.js:\n\nexport default { plugins: [\"./plugins/redact.mjs\"], events:[/* … */] }\n\nContext (unctx)\n\nEach execution runs inside a context. Use it in actions/plugins.\n\nimport { useVan } from \"@gitvan/core/ctx\";\n// inside action/hook:\nconst { cfg, git, sha, note } = useVan();\n\nLLM (optional)\n\nDefaults: Ollama at http://localhost:11434. Model from config. Prompts, params, outputs are stored in receipts. Use seeds when supported.\n\nReceipts\n\nStored at refs/notes/gitvan/results.\n\nShape:\n\n{\"kind\":\"workflow-receipt\",\"id\":\"daily-dev-diary\",\"status\":\"OK\",\"ts\":\"2025-09-15T00:00:00Z\",\"commit\":\"<sha>\",\"action\":\"llm\",\"output\":\"...\"}\n\nSecurity\n\nRequire signed merges/tags.\n\nSoD via hooks. Different signer for merge vs author.\n\nCLI allowlist (cmds and paths).\n\nRead-only humans. Bots sign.\n\nCookbook (dark-matter 80/20)\n\nReady recipes: dev-diary, changelog, release notes, SBOM diff, ADR draft, incident note, reviewer routing, backport plan, test prioritization. Install and run.\n\ngitvan cookbook install dev-diary\ngitvan recipe run dev-diary\n\nProject structure (optional monorepo)\n\nPure JS. No TypeScript.\n\npackages/\n  core/      # git, workflow helpers, config, ctx\n  cli/       # bin/gitvan\n  daemon/    # predicates, actions, loop, hooks\n  llm/       # provider\n  cookbook/  # recipes/*\n\nLicense\n\nApache-2.0.\n\nYou said:\nIs kind needed?\nChatGPT said:\nThought for 10s\n\nNo.\n\nEvents: kind not needed. Use { id, cron|at|on, run }. wf inferred.\n\nRecipes: kind optional per step. Infer:\n\nargs.cmd → cli-call\n\nargs.module → js-call\n\nargs.model && args.prompt → llm-call\n\nargs.tag → milestone\n\nargs.msg → sequence\n\nargs.key && args.value → taskData\n\nReceipts: keep a type tag for audit. Prefer type: \"receipt\" (or keep kind:\"workflow-receipt\"). Everything else can drop kind.\n\nMinimal examples\n\nRecipe step (no kind):\n\n{ \"id\":\"write\", \"args\":{ \"cmd\":\"bash\", \"args\":[\"-lc\",\"echo ok\"] } }\n\n\nNormalizer → {\"kind\":\"cli-call\", ...} internally.\n\nEvent (no kind):\n\n{ \"id\":\"daily-diary\", \"cron\":\"0 18 * * *\", \"run\":\"llm:llama3.2|Summarize today\" }\n\n\nReceipt (typed):\n\n{ \"type\":\"receipt\", \"id\":\"daily-diary\", \"status\":\"OK\", \"ts\":\"...\", \"commit\":\"...\", \"action\":\"llm\" }\n\nTiny infer helper\nfunction inferKind(step){\n  const a = step.args||{};\n  if (a.cmd) return \"cli-call\";\n  if (a.module) return \"js-call\";\n  if (a.model && a.prompt) return \"llm-call\";\n  if (a.tag) return \"milestone\";\n  if (a.msg) return \"sequence\";\n  if (a.key && \"value\" in a) return \"taskData\";\n  throw new Error(\"unknown step shape\");\n}\n\n\nBottom line: drop kind in authoring for events and steps; retain a typed receipt for grep-ability.\n\nYou said:\nI think type is a overloaded word and kind doesn’t have any contextual meanings. Create a turtle ontology for the whole project \nChatGPT said:\nThought for 36s\n@prefix gv:    <https://gitvan.dev/ns#> .\n@prefix gvcs:  <https://gitvan.dev/ns/cs#> .          # concept schemes\n@prefix prov:  <http://www.w3.org/ns/prov#> .\n@prefix dct:   <http://purl.org/dc/terms/> .\n@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .\n@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix owl:   <http://www.w3.org/2002/07/owl#> .\n@prefix skos:  <http://www.w3.org/2004/02/skos/core#> .\n@prefix sh:    <http://www.w3.org/ns/shacl#> .\n\n############################\n# Ontology header\n############################\n\n<https://gitvan.dev/ns>\n  a owl:Ontology ;\n  dct:title \"gitvan ontology\" ;\n  dct:creator \"gitvan\" ;\n  dct:license <https://www.apache.org/licenses/LICENSE-2.0> ;\n  dct:issued \"2025-09-15\"^^xsd:date .\n\n############################\n# Core classes\n############################\n\ngv:Config        a owl:Class ; rdfs:label \"Config\" .\ngv:Repository    a owl:Class ; rdfs:label \"Git repository\" .\ngv:Event         a owl:Class ; rdfs:label \"Workflow event\" ; rdfs:subClassOf prov:Entity .\ngv:Trigger       a owl:Class ; rdfs:label \"Trigger\" ; rdfs:subClassOf prov:Entity .\ngv:Predicate     a owl:Class ; rdfs:label \"Predicate\" .\ngv:Action        a owl:Class ; rdfs:label \"Action\" ; rdfs:subClassOf prov:Plan .\ngv:Run           a owl:Class ; rdfs:label \"Action run\" ; rdfs:subClassOf prov:Activity .\ngv:Receipt       a owl:Class ; rdfs:label \"Execution receipt\" ; rdfs:subClassOf prov:Entity .\ngv:Recipe        a owl:Class ; rdfs:label \"Recipe\" ; rdfs:subClassOf prov:Plan .\ngv:Step          a owl:Class ; rdfs:label \"Recipe step\" ; rdfs:subClassOf prov:Entity .\ngv:Policy        a owl:Class ; rdfs:label \"Policy\" ; rdfs:subClassOf prov:Entity .\ngv:HookInvocation a owl:Class ; rdfs:label \"Hook invocation\" ; rdfs:subClassOf prov:Activity .\ngv:Context       a owl:Class ; rdfs:label \"Execution context\" ; rdfs:subClassOf prov:Entity .\ngv:GitRef        a owl:Class ; rdfs:label \"Git ref\" .\ngv:GitCommit     a owl:Class ; rdfs:label \"Git commit\" ; rdfs:subClassOf prov:Entity .\ngv:GitTag        a owl:Class ; rdfs:label \"Git tag\" ; rdfs:subClassOf prov:Entity .\ngv:GitNote       a owl:Class ; rdfs:label \"Git note\" ; rdfs:subClassOf prov:Entity .\ngv:Agent         a owl:Class ; rdfs:label \"Agent\" ; rdfs:subClassOf prov:Agent .\n\n############################\n# Action specializations\n############################\n\ngv:CLICall  a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"CLI call\" .\ngv:JSCall   a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"JS module call\" .\ngv:LLMCall  a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"LLM call\" .\ngv:Milestone a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"Milestone (tag)\" .\ngv:Sequence  a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"Sequence (empty commit)\" .\ngv:TaskData  a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"Task data note\" .\ngv:GitMerge  a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"Git merge\" .\ngv:GitBranch a owl:Class ; rdfs:subClassOf gv:Action ; rdfs:label \"Git branch\" .\n\n############################\n# Trigger specializations\n############################\n\ngv:CronTrigger  a owl:Class ; rdfs:subClassOf gv:Trigger ; rdfs:label \"Cron trigger\" .\ngv:TimeTrigger  a owl:Class ; rdfs:subClassOf gv:Trigger ; rdfs:label \"Absolute time trigger\" .\ngv:EventTrigger a owl:Class ; rdfs:subClassOf gv:Trigger ; rdfs:label \"Repo event trigger\" .\n\n############################\n# Predicates (as individuals in a scheme)\n############################\n\ngvcs:PredicateScheme a skos:ConceptScheme ; skos:prefLabel \"Predicate types\" .\ngv:mergeTo      a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"mergeTo\" .\ngv:pushTo       a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"pushTo\" .\ngv:tagCreate    a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"tagCreate\" .\ngv:semverTag    a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"semverTag\" .\ngv:pathChanged  a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"pathChanged\" .\ngv:messageMatch a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"messageMatch\" .\ngv:authorEmail  a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"authorEmail\" .\ngv:signed       a skos:Concept ; skos:inScheme gvcs:PredicateScheme ; skos:prefLabel \"signed\" .\n\n############################\n# Status scheme\n############################\n\ngvcs:StatusScheme a skos:ConceptScheme ; skos:prefLabel \"Run status\" .\ngv:OK    a skos:Concept ; skos:inScheme gvcs:StatusScheme ; skos:prefLabel \"OK\" .\ngv:ERROR a skos:Concept ; skos:inScheme gvcs:StatusScheme ; skos:prefLabel \"ERROR\" .\ngv:SKIP  a skos:Concept ; skos:inScheme gvcs:StatusScheme ; skos:prefLabel \"SKIP\" .\n\n############################\n# Workflow patterns (van der Aalst 43)\n############################\n\ngvcs:PatternScheme a skos:ConceptScheme ; skos:prefLabel \"Workflow patterns\" .\n\n# Control-flow (1–20)\ngv:SequencePattern            a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Sequence\" .\ngv:ParallelSplitPattern       a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Parallel Split\" .\ngv:SynchronizationPattern     a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Synchronization\" .\ngv:ExclusiveChoicePattern     a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Exclusive Choice\" .\ngv:SimpleMergePattern         a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Simple Merge\" .\ngv:MultiChoicePattern         a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Multi-Choice\" .\ngv:SynchronizingMergePattern  a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Synchronizing Merge\" .\ngv:MultiMergePattern          a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Multi-Merge\" .\ngv:DiscriminatorPattern       a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Discriminator\" .\ngv:ArbitraryCyclesPattern     a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Arbitrary Cycles\" .\ngv:ImplicitTerminationPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Implicit Termination\" .\ngv:MI_NoSyncPattern           a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"MI without Sync\" .\ngv:MI_DesignTimePattern       a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"MI design-time\" .\ngv:MI_RuntimeKnownPattern     a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"MI runtime-known\" .\ngv:MI_RuntimeUnknownPattern   a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"MI runtime-unknown\" .\ngv:DeferredChoicePattern      a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Deferred Choice\" .\ngv:InterleavedParallelPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Interleaved Parallel\" .\ngv:MilestonePattern           a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Milestone\" .\ngv:CancelTaskPattern          a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Cancel Task\" .\ngv:CancelCasePattern          a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Cancel Case\" .\n\n# Data (21–29)\ngv:TaskDataPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Task Data\" .\ngv:BlockDataPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Block Data\" .\ngv:CaseDataPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Case Data\" .\ngv:TransferByValuePattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Transfer by Value\" .\ngv:TransferByRefPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Transfer by Reference\" .\ngv:DataRoutingPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Data-based Routing\" .\ngv:ExternalInputPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"External Input\" .\ngv:DataValidationPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Data Validation\" .\ngv:DataVersioningPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Data Versioning\" .\n\n# Resource (30–38)\ngv:RoleAllocPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Role-based Allocation\" .\ngv:OrgAllocPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Organizational Allocation\" .\ngv:SeparationOfDutiesPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Separation of Duties\" .\ngv:RetainFamiliarPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Retain Familiar\" .\ngv:CapabilityRoutingPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Capability Routing\" .\ngv:ResourcePoolPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Resource Pool\" .\ngv:CaseOwnershipPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Case Ownership\" .\ngv:DirectAllocPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Direct Allocation\" .\ngv:PrioritizePattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Work Prioritization\" .\n\n# Exception/Time (39–43)\ngv:TimeoutPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Timeout/Escalation\" .\ngv:RepeatUntilPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Repeat-Until\" .\ngv:RetryBackoffPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Retry with Backoff\" .\ngv:CompensationSagaPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Compensation/Saga\" .\ngv:ProvenanceAuditPattern a skos:Concept ; skos:inScheme gvcs:PatternScheme ; skos:prefLabel \"Provenance/Audit\" .\n\n############################\n# Properties\n############################\n\ngv:hasRepository  a owl:ObjectProperty ; rdfs:domain gv:Config ; rdfs:range gv:Repository .\ngv:defaultBranch  a owl:DatatypeProperty ; rdfs:domain gv:Repository ; rdfs:range xsd:string .\ngv:notesRef       a owl:DatatypeProperty ; rdfs:domain gv:Repository ; rdfs:range xsd:string .\ngv:resultsRef     a owl:DatatypeProperty ; rdfs:domain gv:Repository ; rdfs:range xsd:string .\ngv:requireSigned  a owl:DatatypeProperty ; rdfs:domain gv:Repository ; rdfs:range xsd:boolean .\n\ngv:hasEvent       a owl:ObjectProperty ; rdfs:domain gv:Config ; rdfs:range gv:Event .\ngv:hasTrigger     a owl:ObjectProperty ; rdfs:domain gv:Event ; rdfs:range gv:Trigger .\ngv:triggersAction a owl:ObjectProperty ; rdfs:domain gv:Event ; rdfs:range gv:Action .\ngv:realizesPattern a owl:ObjectProperty ; rdfs:domain gv:Action ; rdfs:range skos:Concept .\n\n# Trigger data\ngv:cronExpr       a owl:DatatypeProperty ; rdfs:domain gv:CronTrigger ; rdfs:range xsd:string .\ngv:atTime         a owl:DatatypeProperty ; rdfs:domain gv:TimeTrigger ; rdfs:range xsd:dateTime .\ngv:hasPredicate   a owl:ObjectProperty ; rdfs:domain gv:EventTrigger ; rdfs:range gv:Predicate .\ngv:predicateType  a owl:ObjectProperty ; rdfs:domain gv:Predicate ; rdfs:range skos:Concept .\ngv:mergeToBranch  a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:string .\ngv:pushToGlob     a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:string .\ngv:tagGlob        a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:string .\ngv:pathGlob       a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:string .\ngv:regex          a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:string .\ngv:booleanFlag    a owl:DatatypeProperty ; rdfs:domain gv:Predicate ; rdfs:range xsd:boolean .\n\n# Action payloads\ngv:command        a owl:DatatypeProperty ; rdfs:domain gv:CLICall ; rdfs:range xsd:string .\ngv:argv           a owl:DatatypeProperty ; rdfs:domain gv:CLICall ; rdfs:range xsd:string .\ngv:modulePath     a owl:DatatypeProperty ; rdfs:domain gv:JSCall ; rdfs:range xsd:string .\ngv:exportName     a owl:DatatypeProperty ; rdfs:domain gv:JSCall ; rdfs:range xsd:string .\ngv:prompt         a owl:DatatypeProperty ; rdfs:domain gv:LLMCall ; rdfs:range xsd:string .\ngv:model          a owl:DatatypeProperty ; rdfs:domain gv:LLMCall ; rdfs:range xsd:string .\ngv:optionsJSON    a owl:DatatypeProperty ; rdfs:domain gv:Action ; rdfs:range xsd:string .\ngv:tagName        a owl:DatatypeProperty ; rdfs:domain gv:Milestone ; rdfs:range xsd:string .\ngv:message        a owl:DatatypeProperty ; rdfs:domain gv:Sequence ; rdfs:range xsd:string .\ngv:dataKey        a owl:DatatypeProperty ; rdfs:domain gv:TaskData ; rdfs:range xsd:string .\ngv:dataValue      a owl:DatatypeProperty ; rdfs:domain gv:TaskData ; rdfs:range xsd:string .\n\n# Git linkage\ngv:commit         a owl:ObjectProperty ; rdfs:domain gv:Receipt ; rdfs:range gv:GitCommit .\ngv:sha            a owl:DatatypeProperty ; rdfs:domain gv:GitCommit ; rdfs:range xsd:string .\ngv:onBranch       a owl:DatatypeProperty ; rdfs:domain gv:GitCommit ; rdfs:range xsd:string .\ngv:refName        a owl:DatatypeProperty ; rdfs:domain gv:GitRef ; rdfs:range xsd:string .\ngv:noteRef        a owl:DatatypeProperty ; rdfs:domain gv:GitNote ; rdfs:range xsd:string .\n\n# Runs and receipts\ngv:forEvent       a owl:ObjectProperty ; rdfs:domain gv:Run ; rdfs:range gv:Event .\ngv:forAction      a owl:ObjectProperty ; rdfs:domain gv:Run ; rdfs:range gv:Action .\ngv:status         a owl:ObjectProperty ; rdfs:domain gv:Receipt ; rdfs:range skos:Concept .\ngv:output         a owl:DatatypeProperty ; rdfs:domain gv:Receipt ; rdfs:range xsd:string .\ngv:outputHash     a owl:DatatypeProperty ; rdfs:domain gv:Receipt ; rdfs:range xsd:string .\ngv:executionRef   a owl:DatatypeProperty ; rdfs:domain gv:Run ; rdfs:range xsd:string .\ngv:resultsNoteRef a owl:DatatypeProperty ; rdfs:domain gv:Receipt ; rdfs:range xsd:string .\ngv:ranBy          a owl:ObjectProperty ; rdfs:domain gv:Run ; rdfs:range gv:Agent .\n\n# Hooks & policies\ngv:hookName       a owl:DatatypeProperty ; rdfs:domain gv:HookInvocation ; rdfs:range xsd:string .\ngv:payloadJSON    a owl:DatatypeProperty ; rdfs:domain gv:HookInvocation ; rdfs:range xsd:string .\ngv:appliesToHook  a owl:DatatypeProperty ; rdfs:domain gv:Policy ; rdfs:range xsd:string .\ngv:allowCmdRegex  a owl:DatatypeProperty ; rdfs:domain gv:Policy ; rdfs:range xsd:string .\ngv:allowPathRegex a owl:DatatypeProperty ; rdfs:domain gv:Policy ; rdfs:range xsd:string .\n\n############################\n# SHACL shapes (minimal)\n############################\n\ngv:EventShape a sh:NodeShape ;\n  sh:targetClass gv:Event ;\n  sh:property [ sh:path gv:hasTrigger ; sh:minCount 1 ] ;\n  sh:property [ sh:path gv:triggersAction ; sh:minCount 1 ] .\n\ngv:ReceiptShape a sh:NodeShape ;\n  sh:targetClass gv:Receipt ;\n  sh:property [ sh:path gv:status ; sh:minCount 1 ] ;\n  sh:property [ sh:path gv:commit ; sh:minCount 1 ] ;\n  sh:property [ sh:path dct:created ; sh:minCount 1 ] .\n\n############################\n# Example instances\n############################\n\n# Config → Repo\n[] a gv:Config ;\n  gv:hasRepository [\n    a gv:Repository ;\n    gv:defaultBranch \"main\" ;\n    gv:notesRef \"refs/notes/gitvan\" ;\n    gv:resultsRef \"refs/notes/gitvan/results\" ;\n    gv:requireSigned true\n  ] ;\n  gv:hasEvent [\n    a gv:Event ;\n    dct:identifier \"daily-dev-diary\" ;\n    gv:hasTrigger [ a gv:CronTrigger ; gv:cronExpr \"0 18 * * *\" ] ;\n    gv:triggersAction [\n      a gv:LLMCall ;\n      gv:model \"llama3.2\" ;\n      gv:prompt \"Summarize today's commits.\"\n    ]\n  ] .\n\n# Receipt for a run\n[] a gv:Receipt ;\n  dct:identifier \"daily-dev-diary#2025-09-15T18:00:03Z\" ;\n  gv:status gv:OK ;\n  gv:output \"Today: refactor parser, add hooks.\" ;\n  gv:outputHash \"blake3:8d8c…\";\n  dct:created \"2025-09-15T18:00:03Z\"^^xsd:dateTime ;\n  gv:commit [ a gv:GitCommit ; gv:sha \"abc123…\" ; gv:onBranch \"main\" ] ;\n  gv:resultsNoteRef \"refs/notes/gitvan/results\" .\n\n# Event with repo predicates\n[] a gv:Event ;\n  dct:identifier \"changelog-on-tag\" ;\n  gv:hasTrigger [\n    a gv:EventTrigger ;\n    gv:hasPredicate [\n      a gv:Predicate ;\n      gv:predicateType gv:semverTag ;\n      gv:booleanFlag true\n    ]\n  ] ;\n  gv:triggersAction [\n    a gv:CLICall ;\n    gv:command \"bash\" ;\n    gv:argv \"-lc|git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'* %s' > CHANGELOG.md && git add CHANGELOG.md && git commit -m 'chore: changelog'\"\n  ] .\n\n# Recipe step: Synchronization pattern via merge\n[] a gv:Step ;\n  dct:identifier \"sync-feat-A\" ;\n  prov:wasDerivedFrom gv:SynchronizationPattern ;\n  gv:triggersAction [ a gv:GitMerge ; gv:command \"git\" ; gv:argv \"merge --no-ff feat-A\" ] .\n\nYou said:\n\nSkip to content\nNavigation Menu\nseanchatmangpt\ngitvan\n\nType / to search\n\nCode\nIssues\nPull requests\nActions\nProjects\nWiki\nSecurity\nInsights\nSettings\nOwner avatar\ngitvan\nPublic\ngenerated from unjs/template\nseanchatmangpt/gitvan\nGo to file\nt\nName\t\t\nseanchatmangpt\nseanchatmangpt\nInitial commit\n5169669\n · \n1 minute ago\n.github/workflows\nInitial commit\n1 minute ago\nsrc\nInitial commit\n1 minute ago\ntest\nInitial commit\n1 minute ago\n.editorconfig\nInitial commit\n1 minute ago\n.gitignore\nInitial commit\n1 minute ago\n.prettierrc\nInitial commit\n1 minute ago\nLICENSE\nInitial commit\n1 minute ago\nREADME.md\nInitial commit\n1 minute ago\nbuild.config.mjs\nInitial commit\n1 minute ago\neslint.config.mjs\nInitial commit\n1 minute ago\npackage.json\nInitial commit\n1 minute ago\nrenovate.json\nInitial commit\n1 minute ago\ntsconfig.json\nInitial commit\n1 minute ago\nRepository files navigation\nREADME\nMIT license\npackageName\nnpm version npm downloads\n\nThis is my package description.\n\nUsage\nInstall the package:\n\n# ✨ Auto-detect (supports npm, yarn, pnpm, deno and bun)\nnpx nypm install packageName\nImport:\n\nESM (Node.js, Bun, Deno)\n\nimport {} from \"pkg\";\nCDN (Deno, Bun and Browsers)\n\nimport {} from \"https://esm.sh/pkg\";\nDevelopment\nlocal development\nLicense\nPublished under the MIT license. Made by community 💛\n\n\n\n🤖 auto updated with automd\n\nAbout\nGit as Runtime\n\nResources\n Readme\nLicense\n MIT license\n Activity\nStars\n 0 stars\nWatchers\n 0 watching\nForks\n 0 forks\nReleases\nNo releases published\nCreate a new release\nPackages\nNo packages published\nPublish your first package\nLanguages\nJavaScript\n60.9%\n \nTypeScript\n39.1%\nFooter\n© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nGitHub Community\nDocs\nContact\nManage cookies\nDo not share my personal information\n\n\n\nI cloned the unjs template so what should the gitvan repo look like now? We are not going to be doing the monorepo for now\nChatGPT said:\nThought for 21s\n\nTarget: single-package repo, pure ESM JS, UnJS libs, no monorepo. Here’s the shape and the minimum you need.\n\nFolder layout\ngitvan/\n  bin/\n    gitvan.mjs\n  src/\n    config.mjs\n    normalize.mjs\n    events.mjs\n    hooks.mjs\n    ctx.mjs\n    git.mjs\n    notes.mjs\n    predicates.mjs\n    actions.mjs\n    daemon/\n      loop.mjs\n  README.md\n  package.json\n  .editorconfig\n  .gitignore\n  eslint.config.mjs\n  LICENSE\n\npackage.json (core CLI package)\n{\n  \"name\": \"gitvan\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"bin\": { \"gitvan\": \"bin/gitvan.mjs\" },\n  \"engines\": { \"node\": \">=18\" },\n  \"scripts\": {\n    \"dev\": \"node bin/gitvan.mjs diagnose\",\n    \"lint\": \"eslint .\",\n    \"build\": \"echo skip\",\n    \"test\": \"node bin/gitvan.mjs --help\"\n  },\n  \"dependencies\": {\n    \"c12\": \"^1.5.0\",\n    \"consola\": \"^3.2.3\",\n    \"defu\": \"^6.1.4\",\n    \"hookable\": \"^5.5.3\",\n    \"ofetch\": \"^1.3.4\",\n    \"pathe\": \"^1.1.2\",\n    \"unctx\": \"^2.3.0\",\n    \"unrouting\": \"^0.3.0\"\n  }\n}\n\n\nRemove TS files and tsconfig.json.\n\nbin/gitvan.mjs (noun–verb)\n#!/usr/bin/env node\nimport { defineCommand, runMain } from 'citty'; // if you prefer citty; else parse args manually\nimport { loadConfig } from '../src/config.mjs';\nimport { applyConfig } from '../src/normalize.mjs';\nimport { startLoop, once } from '../src/daemon/loop.mjs';\nimport { log } from '../src/git.mjs';\n\nconst repo = defineCommand({\n  meta: { name: 'repo' },\n  subCommands: {\n    init: defineCommand({\n      meta: { name: 'init' },\n      async run() {\n        const { exec } = await import('../src/git.mjs');\n        await exec('init');\n        await exec('commit --allow-empty -m \"init\"');\n        log.success('repo init');\n      }\n    })\n  }\n});\n\nconst cfg = defineCommand({\n  meta: { name: 'config' },\n  subCommands: {\n    show: defineCommand({ async run(){ console.log(JSON.stringify(await loadConfig(), null, 2)); } }),\n    apply: defineCommand({ async run(){ const cfg = await loadConfig(); const wrote = await applyConfig(cfg); log.success(`applied ${wrote} notes`); } })\n  }\n});\n\nconst daemon = defineCommand({\n  meta: { name: 'daemon' },\n  subCommands: {\n    start: defineCommand({ async run(){ await startLoop(); } }),\n    once: defineCommand({ async run(){ const ran = await once(); log.success(`ran ${ran}`); } })\n  }\n});\n\nconst diagnose = defineCommand({\n  meta: { name: 'diagnose' },\n  async run() {\n    const cfg = await loadConfig();\n    console.log({ notesRef: cfg.repo.notesRef, resultsRef: cfg.repo.resultsRef, model: cfg.llm.model });\n  }\n});\n\nconst main = defineCommand({\n  meta: { name: 'gitvan', version: '0.0.1' },\n  subCommands: { repo, config: cfg, daemon, diagnose }\n});\n\nrunMain(main);\n\nsrc/config.mjs\nimport { loadConfig as c12 } from 'c12';\nimport { defu } from 'defu';\nimport { log } from './git.mjs';\n\nconst defaults = {\n  repo: { defaultBranch: 'main', notesRef: 'refs/notes/gitvan', resultsRef: 'refs/notes/gitvan/results', signing: { require: true } },\n  llm: { baseURL: 'http://localhost:11434', model: 'llama3.2', temperature: 0.2 },\n  events: [], recipes: [], plugins: []\n};\n\nexport async function loadConfig(cwd = process.cwd()) {\n  const { config } = await c12({ name: 'gitvan', cwd, dotenv: true, defaults });\n  const out = defu(config || {}, defaults);\n  log.debug('config loaded');\n  return out;\n}\n\nsrc/normalize.mjs\nimport { loadEventsDir } from './events.mjs';\nimport { NOTES_REF } from './notes.mjs';\nimport { note } from './git.mjs';\n\nexport async function applyConfig(cfg, cwd = process.cwd()) {\n  const fromDir = await loadEventsDir(cwd);\n  const all = [...(cfg.events || []), ...fromDir].map(normalizeEvent.bind(null, cfg));\n  let wrote = 0;\n  for (const ev of all) { await note(JSON.stringify(ev), cfg.repo.notesRef || NOTES_REF); wrote++; }\n  return wrote;\n}\n\nfunction normalizeEvent(cfg, e) {\n  const wf = e.cron ? 'cron' : e.at ? 'timer' : 'event';\n  const on = normOn(e.on);\n  const run = normRun(e.run, cfg);\n  const out = { id: e.id || `ev-${Math.random().toString(36).slice(2,8)}`, wf, run };\n  if (e.cron) out.cron = e.cron;\n  if (e.at) out.at = e.at;\n  if (on) out.on = on;\n  return out;\n}\n\nfunction normOn(on) {\n  if (!on) return null;\n  const tok = t => t==='semverTag'?{semverTag:true}:t==='signed'?{signed:true}:\n    t.startsWith('mergeTo:')?{mergeTo:t.split(':')[1]}:\n    t.startsWith('pushTo:')?{pushTo:t.split(':')[1]}:\n    t.startsWith('pathChanged:')?{pathChanged:t.split(':')[1]}:{message:t};\n  if (typeof on === 'string') return tok(on);\n  if (Array.isArray(on)) return { any: on.map(tok) };\n  return on;\n}\n\nfunction normRun(run, cfg) {\n  if (!run) return null;\n  if (typeof run !== 'string') return run;\n  if (run.startsWith('cli:')) return { type:'cli-call', cmd:'bash', args:['-lc', run.slice(4)] };\n  if (run.startsWith('js:'))  { const [m,e='default']=run.slice(3).split('#'); return { type:'js-call', module:m, export:e }; }\n  if (run.startsWith('llm:')) { const body=run.slice(4); const [model,...p]=body.split('|'); return { type:'llm-call', model: model||cfg.llm.model, prompt:p.join('|') }; }\n  return { type:'cli-call', cmd:'bash', args:['-lc', run] };\n}\n\nsrc/events.mjs\nimport fs from 'node:fs';\nimport { join, relative } from 'pathe';\nimport { pathToFileURL } from 'node:url';\n\nexport async function loadEventsDir(cwd = process.cwd()) {\n  const dir = join(cwd, 'events');\n  if (!fs.existsSync(dir)) return [];\n  const files = walk(dir).filter(f => /\\.(mjs|js)$/.test(f));\n  const out = [];\n  for (const f of files) {\n    const mod = await import(pathToFileURL(f).href);\n    const raw = mod.default || mod;\n    out.push({ id: idFrom(dir, f), ...raw });\n  }\n  return out;\n}\n\nfunction walk(dir, acc=[]) {\n  for (const e of fs.readdirSync(dir, { withFileTypes:true })) {\n    const p = join(dir, e.name);\n    e.isDirectory() ? walk(p, acc) : acc.push(p);\n  }\n  return acc;\n}\nfunction idFrom(root, file) { return relative(root, file).replace(/\\.(mjs|js)$/,'').replace(/[\\\\/]/g,'-'); }\n\nsrc/hooks.mjs\nimport { createHooks } from 'hookable';\nexport const hooks = createHooks();\nexport const on  = hooks.hook.bind(hooks);\nexport const run = hooks.callHook.bind(hooks);\n\nsrc/ctx.mjs\nimport { createContext } from 'unctx';\nimport { AsyncLocalStorage } from 'node:async_hooks';\nconst gv = createContext({ asyncContext: true, AsyncLocalStorage });\nexport const useVan = gv.use;\nexport const callVan = gv.call.bind(gv);\nexport const callVanAsync = gv.callAsync?.bind(gv) || ((v,fn)=>Promise.resolve(gv.call(v,fn)));\n\nsrc/git.mjs\nimport { execSync } from 'node:child_process';\nimport { createConsola } from 'consola';\nexport const log = createConsola({ level: 3 });\n\nexport function sh(s){ return execSync(`git -C \"${process.cwd()}\" ${s}`, { stdio:['ignore','pipe','inherit'] }).toString().trim(); }\nexport async function exec(args){ return sh(args); }\nexport async function note(message, ref){ try { sh(`notes --ref=${ref} add -m '${message.replace(/'/g,\"'\\\\''\")}'`); } catch { sh(`notes --ref=${ref} append -m '${message.replace(/'/g,\"'\\\\''\")}'`); } }\n\nsrc/notes.mjs\nexport const NOTES_REF   = 'refs/notes/gitvan';\nexport const RESULTS_REF = 'refs/notes/gitvan/results';\n\nsrc/predicates.mjs\nexport function isTimerDue(n, now = new Date()){ if (n.wf==='cron') return matchCron(n.cron, now); if (n.wf==='timer' && n.at) return new Date(n.at) <= now; return false; }\nexport async function eventFires(n, sha, meta){ if (n.wf!=='event' || !n.on) return false; const p=n.on;\n  if (p.semverTag) return meta.tags.some(t=>/^v?\\d+\\.\\d+\\.\\d+/.test(t));\n  if (p.mergeTo)   return meta.isMerge && meta.branches.includes(p.mergeTo);\n  if (p.pushTo)    return meta.branches.some(b=>glob(p.pushTo,b));\n  if (p.pathChanged) return meta.changes.some(c=>glob(p.pathChanged,c.path));\n  if (p.any) return p.any.some(x=>eventFires({ wf:'event', on:x }, sha, meta));\n  return false;\n}\n\nexport async function commitMeta(sha){\n  const { exec } = await import('./git.mjs');\n  const parents = (await exec(`rev-list --parents -n 1 ${sha}`)).split(' ').slice(1);\n  const isMerge = parents.length >= 2;\n  const branches = (await exec(`branch --contains ${sha} --format=\"%(refname:short)\"`)).split('\\n').filter(Boolean);\n  const tags = (await exec(`tag --contains ${sha}`)).split('\\n').filter(Boolean);\n  const diff = await exec(`diff-tree --no-commit-id --name-status -r ${sha}`);\n  const changes = diff.split('\\n').filter(Boolean).map(l => { const [s, ...r] = l.split(/\\s+/); return { status:s, path:r.pop()||'' }; });\n  return { isMerge, branches, tags, changes };\n}\n\nfunction glob(glob, s){ const r = new RegExp('^'+glob.split('*').map(escape).join('.*')+'$'); return r.test(s); }\nfunction escape(x){ return x.replace(/[.+?^${}()|[\\]\\\\]/g,'\\\\$&'); }\nfunction matchCron(spec,d){ const [m,h,dom,mon,dow]=spec.trim().split(/\\s+/); const M=d.getUTCMinutes(),H=d.getUTCHours(),D=d.getUTCDate(),O=d.getUTCMonth()+1,W=d.getUTCDay();\n  const ok=(f,v)=>f==='*'||f.split(',').some(t=>t.startsWith('*/')?(v%Number(t.slice(2))===0):t.includes('-')?(v>=+t.split('-')[0]&&v<=+t.split('-')[1]):(+t===v));\n  return ok(m,M)&&ok(h,H)&&ok(dom,D)&&ok(mon,O)&&ok(dow,W);\n}\n\nsrc/actions.mjs\nimport { exec } from './git.mjs';\nimport { generate } from './llm.mjs';\n\nexport async function runAction(note){\n  const r = note.run || {};\n  if (r.type === 'cli-call') { await exec(`${r.cmd} ${(r.args||[]).join(' ')}`); return { kind:'cli' }; }\n  if (r.type === 'js-call')  { const mod = await import(new URL(r.module, `file://${process.cwd()}/`).href); const fn = r.export==='default'?mod.default:mod[r.export]; await fn(r.input||{}); return { kind:'js' }; }\n  if (r.type === 'llm-call') { const out = await generate({ model:r.model, prompt:r.prompt, options:r.options||{} }); return { kind:'llm', output: out }; }\n  return { kind:'noop' };\n}\n\nsrc/llm.mjs\nimport { ofetch } from 'ofetch';\nimport { loadConfig } from './config.mjs';\nexport async function generate({ model, prompt, options = {} }) {\n  const cfg = await loadConfig();\n  const base = cfg.llm.baseURL;\n  const res = await ofetch(`${base}/api/generate`, { method:'POST', body:{ model: model||cfg.llm.model, prompt, options, stream:false } });\n  return res.response || '';\n}\n\nsrc/daemon/loop.mjs\nimport { exec, note } from '../git.mjs';\nimport { RESULTS_REF } from '../notes.mjs';\nimport { loadConfig } from '../config.mjs';\nimport { isTimerDue, eventFires, commitMeta } from '../predicates.mjs';\nimport { runAction } from '../actions.mjs';\n\nexport async function once(){\n  const cfg = await loadConfig();\n  const shas = (await exec('log --pretty=%H -n 300 --no-show-signature')).split('\\n').filter(Boolean);\n  let ran = 0;\n  for (const sha of shas) {\n    const raw = await exec(`notes --ref=${cfg.repo.notesRef} show ${sha}`).catch(()=>null);\n    if (!raw) continue;\n    const meta = await commitMeta(sha);\n    const list = Array.isArray(JSON.parse(raw))?JSON.parse(raw):[JSON.parse(raw)];\n    for (const n of list) {\n      const due = isTimerDue(n) || await eventFires(n, sha, meta);\n      if (!due) continue;\n      const out = await runAction(n);\n      const receipt = { role:\"receipt\", id:n.id, status:\"OK\", ts:new Date().toISOString(), commit:sha, action:out.kind, output: out.output||\"\" };\n      await note(JSON.stringify(receipt), cfg.repo.resultsRef || RESULTS_REF);\n      ran++;\n    }\n  }\n  return ran;\n}\n\nexport async function startLoop(intervalMs = 1500){\n  for (;;) { await once(); await new Promise(r=>setTimeout(r, intervalMs)); }\n}\n\n\nThis gives you a clean single-package gitvan repo that:\n\nLoads gitvan.config.* and an events/ dir from the caller repo.\n\nWrites canonical event notes.\n\nRuns a minimal daemon loop.\n\nSupports cli/js/llm actions.\n\nStays pure JS, UnJS-first, Git-only."
        }
    ]
}