{
    "sourceFile": ".cursorrules",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1758045807388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758143563304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,13 +97,34 @@\n 2. **Show actual test output**\n 3. **Admit when things are untested**\n 4. **Verify before claiming success**\n \n+## CRITICAL: Error Checking Protocol\n+- **ALWAYS CHECK CONSOLE OUTPUT FOR ERRORS** before declaring success\n+- **NEVER declare success if there are ANY error messages** (❌, ⚠️, Error:, Failed:, etc.)\n+- **READ THE FULL OUTPUT** - don't just look for ✅ symbols\n+- **VERIFY EXIT CODES** - commands must exit with code 0\n+- **CHECK FOR WARNINGS** - warnings indicate potential issues\n+- **VALIDATE ACTUAL FUNCTIONALITY** - not just that commands run\n+\n+### Error Detection Patterns\n+- Look for: `❌`, `⚠️`, `Error:`, `Failed:`, `Cannot`, `TypeError`, `ReferenceError`\n+- Check exit codes: `exit code: 0` = success, anything else = failure\n+- Verify no warnings: `warning:`, `WARN:`, `⚠️`\n+- Ensure clean output: no stack traces or error messages\n+\n+### Success Criteria\n+- ✅ **ALL** console output shows success indicators\n+- ✅ **ZERO** error messages or warnings\n+- ✅ **ZERO** exit code (success)\n+- ✅ **ACTUAL** functionality verified, not just \"command ran\"\n+\n **REMEMBER:**\n - Writing a file to disk DOES NOT mean it works\n - Finishing a TODO is NOT enough without verification\n - You MUST verify with actual command execution\n-- Always test before claiming completion\n+- **NEVER declare success without checking ALL console output for errors**\n+- **ALWAYS read the full output before claiming anything works**\n \n ## Quick Commands\n ```bash\n # Run tests\n"
                },
                {
                    "date": 1758210105654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,14 +117,33 @@\n - ✅ **ZERO** error messages or warnings\n - ✅ **ZERO** exit code (success)\n - ✅ **ACTUAL** functionality verified, not just \"command ran\"\n \n+### MANDATORY: Pre-Declaration Checklist\n+Before declaring ANY task complete, you MUST:\n+\n+1. **SCAN FOR FAILURE INDICATORS**: Run `grep -E \"(❌|ERROR|Failed|✗|WARN|⚠️)\"` on the output\n+2. **CHECK EXIT CODE**: Verify the command exited with code 0\n+3. **READ EVERY LINE**: Don't skip any output, especially at the end\n+4. **VERIFY FUNCTIONALITY**: Test that the feature actually works, not just that a command ran\n+5. **ADMIT FAILURES**: If there are ANY errors/warnings, state them explicitly\n+\n+### FAILURE EXAMPLES TO NEVER MISS:\n+- `❌ Pre-commit hook not installed`\n+- `ERROR ✗ Not a Git repository`\n+- `WARN ✗ Git identity not configured`\n+- `⚠️ Configuration incomplete (2/6 checks passed)`\n+- `WARN Hook installation timed out`\n+- Any exit code != 0\n+- Any stack traces or error messages\n+\n **REMEMBER:**\n - Writing a file to disk DOES NOT mean it works\n - Finishing a TODO is NOT enough without verification\n - You MUST verify with actual command execution\n - **NEVER declare success without checking ALL console output for errors**\n - **ALWAYS read the full output before claiming anything works**\n+- **IF YOU SEE ANY FAILURE INDICATORS, THE TASK IS NOT COMPLETE**\n \n ## Quick Commands\n ```bash\n # Run tests\n"
                },
                {
                    "date": 1758231104748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,8 +64,9 @@\n \n ## Package Management\n - **ALWAYS USE pnpm NOT npm** for package management\n - Install dependencies with `pnpm install`\n+- **NEVER manually edit package.json** - use `pnpm install <package-name>` to add dependencies\n - Run tests with `pnpm test`\n - Build with `pnpm run build`\n \n ## Import/Export Patterns\n"
                },
                {
                    "date": 1758248327627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,8 +98,14 @@\n 2. **Show actual test output**\n 3. **Admit when things are untested**\n 4. **Verify before claiming success**\n \n+## Test Implementation Standards\n+- **NEVER create simplified or mock versions of tests** - Always implement full functionality\n+- **ALWAYS fix dependency issues properly** - Install missing packages, resolve conflicts\n+- **NEVER skip complex functionality** - Implement complete features as specified\n+- **ALWAYS resolve import/module issues** - Fix the root cause, don't work around it\n+\n ## CRITICAL: Error Checking Protocol\n - **ALWAYS CHECK CONSOLE OUTPUT FOR ERRORS** before declaring success\n - **NEVER declare success if there are ANY error messages** (❌, ⚠️, Error:, Failed:, etc.)\n - **READ THE FULL OUTPUT** - don't just look for ✅ symbols\n"
                }
            ],
            "date": 1758045807388,
            "name": "Commit-0",
            "content": "# GitVan v2 - Cursor Rules\n\n## Project Overview\nGitVan is a Git-native development automation platform that uses Git as a runtime environment. This project follows FAANG-level architecture principles with comprehensive testing and deterministic operations.\n\n## Core Development Principles\n\n### Test-Driven Development (TDD)\n- **ALWAYS TEST BEFORE CLAIMING COMPLETION** - Run actual commands, verify they work\n- **IMPLEMENT 80/20 TEST-FIX LOOP** - Test → Fix → Verify (minimum 3 iterations)\n- **NEVER REPORT \"COMPLETE\" WITHOUT TESTING** - All features must be actually working\n- Use `pnpm test` to verify functionality before claiming completion\n\n### File Organization\n- **NEVER save working files to root folder**\n- Use appropriate subdirectories:\n  - `/src` - Source code files\n  - `/tests` - Test files  \n  - `/docs` - Documentation and markdown files\n  - `/config` - Configuration files\n  - `/scripts` - Utility scripts\n  - `/examples` - Example code\n\n### Code Style & Standards\n- **Modular Design**: Files under 500 lines\n- **Environment Safety**: Never hardcode secrets\n- **Test-First**: Write tests before implementation\n- **Clean Architecture**: Separate concerns\n- **FAANG-level solutions**: Create code at the level of a FAANG solution architect\n\n## GitVan-Specific Rules\n\n### Context Management\n- Use `unctx` for async context management\n- Always wrap operations in `withGitVan(context, async () => { ... })`\n- Context must be properly bound for async operations\n- Use `useGitVan()` and `tryUseGitVan()` for context access\n\n### Template System\n- Use Nunjucks for template rendering\n- All templates must be deterministic (no `now()` or `random()` calls)\n- Use inflection filters for string transformations\n- Templates should be cached for performance\n- Support both file-based and string-based templates\n\n### Configuration Discovery\n- Use `findGitVanConfig()` to discover configuration files\n- Support multiple config formats: `.js`, `.mjs`, `.ts`\n- Search up directory tree for config files\n- Provide fallback strategies for missing config\n\n### Git Integration\n- Use Git refs/notes for metadata storage\n- Implement atomic operations where possible\n- Handle Git errors gracefully\n- Support both sync and async Git operations\n\n### Testing Requirements\n- All composables must have comprehensive tests\n- Use `withGitVan()` wrapper in tests for proper context\n- Test both success and error scenarios\n- Verify async context preservation\n- Test inflection filters thoroughly\n\n## Package Management\n- **ALWAYS USE pnpm NOT npm** for package management\n- Install dependencies with `pnpm install`\n- Run tests with `pnpm test`\n- Build with `pnpm run build`\n\n## Import/Export Patterns\n- Use ES modules (`import`/`export`)\n- Prefer named exports over default exports\n- Use absolute imports for better clarity\n- Import from `../src/` paths in tests\n\n## Error Handling\n- Implement comprehensive error handling\n- Use deterministic error messages\n- Handle async context loss gracefully\n- Provide meaningful error context\n\n## Performance Considerations\n- Cache expensive operations (template environments, config loading)\n- Use parallel operations where possible\n- Implement efficient path resolution\n- Minimize file system operations\n\n## Documentation Standards\n- Keep documentation updated with code changes\n- Use clear, concise descriptions\n- Document async context requirements\n- Explain configuration options\n\n## Trust Building Protocol\n1. **Under-promise, over-deliver**\n2. **Show actual test output**\n3. **Admit when things are untested**\n4. **Verify before claiming success**\n\n**REMEMBER:**\n- Writing a file to disk DOES NOT mean it works\n- Finishing a TODO is NOT enough without verification\n- You MUST verify with actual command execution\n- Always test before claiming completion\n\n## Quick Commands\n```bash\n# Run tests\npnpm test\n\n# Run specific test file\npnpm test tests/template-simple.test.mjs\n\n# Install dependencies\npnpm install\n\n# Build project\npnpm run build\n\n# Lint code\npnpm run lint\n```\n\n## Project Structure\n```\nsrc/\n├── composables/     # Core composables (useGit, useTemplate, etc.)\n├── core/           # Core context and runtime\n├── runtime/        # Runtime configuration and daemon\n├── utils/          # Utility functions (config-finder, etc.)\n└── cli/           # CLI implementation\n\ntests/\n├── composables/    # Composable tests\n├── core/          # Core tests\n└── *.test.mjs     # Integration tests\n\ntemplates/          # Nunjucks templates\ndocs/              # Documentation\nconfig/            # Configuration files\n```\n\n## Context Usage Pattern\n```javascript\n// Correct context usage\nawait withGitVan(context, async () => {\n  const template = await useTemplate({ paths: [templatesDir] });\n  const result = template.render('template.njk', data);\n  // ... rest of operations\n});\n```\n\n## Template Usage Pattern\n```javascript\n// Correct template usage\nconst template = await useTemplate({ \n  paths: ['templates'],\n  autoescape: false,\n  noCache: true \n});\n\nconst result = template.renderString('{{ name | capitalize }}', { name: 'john' });\n```\n\n## Configuration Pattern\n```javascript\n// Correct config discovery\nconst configResult = await findGitVanConfig(process.cwd());\nif (configResult) {\n  const { config, root } = configResult;\n  // Use discovered config\n}\n```\n\nThis project prioritizes reliability, testability, and maintainability while leveraging Git as a runtime environment for development automation.\n"
        }
    ]
}