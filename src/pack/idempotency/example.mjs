/**
 * Example usage of the GitVan Idempotency and Rollback System
 *
 * This example demonstrates how to use the idempotency system
 * to safely install and manage packs with automatic rollback capabilities.
 */

import { createPackIdempotency } from './integration.mjs';
import { writeFileSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'pathe';

// Example pack installation with idempotency
async function examplePackInstallation() {
  console.log('üöÄ GitVan Idempotency System Example\n');

  // Create idempotency system
  const idempotency = createPackIdempotency({
    stateDir: '.gitvan/state',
    backupDir: '.gitvan/backups'
  });

  // Example pack specification
  const packSpec = {
    id: 'example-config-pack',
    version: '1.2.0',
    source: 'local',
    transforms: [
      {
        kind: 'json-merge',
        target: 'package.json',
        spec: {
          scripts: {
            'example:start': 'node src/example.mjs',
            'example:test': 'vitest run'
          }
        }
      }
    ],
    options: {
      backup: true,
      skipIfExists: false
    }
  };

  const targetFiles = ['package.json', 'src/example.mjs'];

  try {
    console.log('1Ô∏è‚É£ Checking if pack installation should be skipped...');

    // Track the installation operation
    const tracking = await idempotency.trackPackInstallation(packSpec, './');

    if (tracking.shouldSkip) {
      console.log('‚úÖ Pack already installed with same configuration');
      console.log('   Fingerprint:', tracking.fingerprint);
      return;
    }

    console.log('2Ô∏è‚É£ Creating pre-installation snapshots...');

    // Create snapshots of files that might be modified
    const snapshots = await idempotency.createPreInstallSnapshots(targetFiles);
    console.log(`   Created ${snapshots.size} snapshots`);

    console.log('3Ô∏è‚É£ Applying pack transformations...');

    // Simulate pack installation
    const artifacts = await simulatePackInstallation(packSpec);
    console.log(`   Applied ${artifacts.length} transformations`);

    console.log('4Ô∏è‚É£ Recording successful installation...');

    // Record the installation
    const receipt = await idempotency.recordPackInstallation(
      packSpec,
      tracking.fingerprint,
      artifacts,
      snapshots
    );

    console.log('‚úÖ Pack installation completed successfully');
    console.log('   Pack ID:', receipt.packId);
    console.log('   Version:', receipt.version);
    console.log('   Artifacts:', receipt.artifacts.length);
    console.log('   Installed at:', receipt.installedAt);

    console.log('\n5Ô∏è‚É£ Demonstrating rollback capability...');

    // Show how to rollback
    await demonstrateRollback(idempotency, packSpec.id);

  } catch (error) {
    console.error('‚ùå Pack installation failed:', error.message);

    // In a real scenario, you might want to rollback any partial changes
    console.log('üîÑ Attempting to rollback partial changes...');

    try {
      const results = await idempotency.rollbackPack(packSpec.id);
      if (results.errors.length === 0) {
        console.log('‚úÖ Rollback completed successfully');
      } else {
        console.log('‚ö†Ô∏è Rollback completed with errors:', results.errors);
      }
    } catch (rollbackError) {
      console.error('‚ùå Rollback failed:', rollbackError.message);
    }
  }
}

// Simulate applying pack transformations
async function simulatePackInstallation(packSpec) {
  const artifacts = [];

  for (const transform of packSpec.transforms) {
    if (transform.kind === 'json-merge' && transform.target === 'package.json') {
      // Read current package.json
      const packagePath = 'package.json';
      let packageData = {};

      if (existsSync(packagePath)) {
        packageData = JSON.parse(readFileSync(packagePath, 'utf8'));
      }

      // Apply merge transformation
      if (!packageData.scripts) {
        packageData.scripts = {};
      }

      Object.assign(packageData.scripts, transform.spec.scripts);

      // Write updated package.json
      writeFileSync(packagePath, JSON.stringify(packageData, null, 2));

      artifacts.push({
        type: 'transform',
        path: packagePath,
        transform: {
          kind: 'json-merge',
          spec: transform.spec,
          original: packageData.scripts
        }
      });
    }
  }

  // Create example file
  const examplePath = join('src', 'example.mjs');
  const exampleContent = `// Generated by ${packSpec.id}@${packSpec.version}
console.log('Hello from example pack!');
`;

  writeFileSync(examplePath, exampleContent);

  artifacts.push({
    type: 'file',
    path: examplePath,
    hash: null // Would be calculated in real implementation
  });

  return artifacts;
}

// Demonstrate rollback functionality
async function demonstrateRollback(idempotency, packId) {
  try {
    console.log('   Creating rollback plan...');

    const plan = await idempotency.createPackRollbackPlan(packId);
    console.log(`   Plan created with ${plan.steps.length} steps:`);

    for (const step of plan.steps) {
      console.log(`     - ${step.action}: ${step.path} (${step.reason})`);
    }

    console.log('   Executing rollback...');

    const results = await idempotency.rollbackPack(packId);

    if (results.errors.length === 0) {
      console.log('   ‚úÖ Rollback completed successfully');
      console.log('   Success operations:', results.success.length);
    } else {
      console.log('   ‚ö†Ô∏è Rollback completed with errors');
      console.log('   Success operations:', results.success.length);
      console.log('   Error operations:', results.errors.length);
    }

    console.log('\n6Ô∏è‚É£ Verifying rollback...');

    const isInstalled = await idempotency.isPackInstalled(packId);
    console.log('   Pack still installed:', isInstalled);

  } catch (error) {
    console.error('   ‚ùå Rollback demonstration failed:', error.message);
  }
}

// Example of pack management operations
async function examplePackManagement() {
  console.log('\nüìã Pack Management Operations\n');

  const idempotency = createPackIdempotency();

  // List installed packs
  console.log('1Ô∏è‚É£ Listing installed packs...');
  const packs = idempotency.listInstalledPacks();
  console.log(`   Found ${packs.length} installed packs:`);

  for (const pack of packs) {
    console.log(`     - ${pack.id}@${pack.version} (${pack.artifactCount} artifacts)`);
  }

  // Validate pack integrity
  if (packs.length > 0) {
    console.log('\n2Ô∏è‚É£ Validating pack integrity...');

    for (const pack of packs) {
      const validation = await idempotency.validatePackIntegrity(pack.id);

      if (validation.valid) {
        console.log(`   ‚úÖ ${pack.id}: Valid (${validation.artifactCount} artifacts)`);
      } else {
        console.log(`   ‚ùå ${pack.id}: Invalid (${validation.issues.length} issues)`);
        for (const issue of validation.issues) {
          console.log(`       - ${issue}`);
        }
      }
    }
  }

  // Export state for backup
  console.log('\n3Ô∏è‚É£ Exporting state for backup...');
  const state = idempotency.exportState();
  console.log(`   Exported state with ${Object.keys(state.packs).length} packs`);
  console.log(`   Operations history: ${state.operations.length} entries`);

  // Cleanup old data
  console.log('\n4Ô∏è‚É£ Cleaning up old data...');
  await idempotency.cleanup(30); // Keep 30 days
  console.log('   Cleanup completed');
}

// Run the examples
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    await examplePackInstallation();
    await examplePackManagement();

    console.log('\nüéâ Idempotency system demonstration completed!');
  } catch (error) {
    console.error('\nüí• Example failed:', error);
    process.exit(1);
  }
}