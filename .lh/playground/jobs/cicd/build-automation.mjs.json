{
    "sourceFile": "playground/jobs/cicd/build-automation.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758052882221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758052882221,
            "name": "Commit-0",
            "content": "// playground/jobs/cicd/build-automation.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\n\nconst execFileAsync = promisify(execFile);\n\nexport default defineJob({\n  meta: {\n    desc: \"Automated build process with environment-specific configuration\",\n    tags: [\"cicd\", \"build\", \"automation\", \"cookbook\"],\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n\n    // Get build configuration\n    const environment = payload?.environment || \"development\";\n    const buildType = payload?.buildType || \"production\";\n    const cleanBuild = payload?.cleanBuild !== false;\n\n    // Get repository information\n    const head = await git.head();\n    const branch = await git.getCurrentBranch();\n    const isClean = await git.isClean();\n\n    if (!isClean && !payload?.allowDirty) {\n      ctx.logger.warn(\n        \"⚠️ Repository has uncommitted changes, but continuing with build\",\n      );\n    }\n\n    const buildInfo = {\n      environment,\n      buildType,\n      timestamp: ctx.nowISO,\n      repository: {\n        head: head.substring(0, 8),\n        branch,\n        isClean,\n      },\n      system: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch,\n      },\n    };\n\n    ctx.logger.log(\n      `🚀 Starting ${buildType} build for ${environment} environment`,\n    );\n\n    // Clean build directory if requested\n    if (cleanBuild) {\n      const distDir = join(ctx.root, \"dist\", \"cicd\");\n      try {\n        await fs.rmdir(distDir, { recursive: true });\n        ctx.logger.log(\"🧹 Cleaned build directory\");\n      } catch (error) {\n        // Directory might not exist, that's okay\n      }\n    }\n\n    // Create build directory\n    const buildDir = join(ctx.root, \"dist\", \"cicd\", \"build\");\n    await fs.mkdir(buildDir, { recursive: true });\n\n    // Simulate build steps (since we don't have actual npm scripts)\n    const buildSteps = [\n      {\n        name: \"Validate Environment\",\n        command: \"node\",\n        args: [\"-e\", \"console.log('Environment validated')\"],\n      },\n      {\n        name: \"Check Dependencies\",\n        command: \"node\",\n        args: [\"-e\", \"console.log('Dependencies checked')\"],\n      },\n      {\n        name: \"Run Tests\",\n        command: \"node\",\n        args: [\"-e\", \"console.log('Tests passed')\"],\n      },\n      {\n        name: \"Build Application\",\n        command: \"node\",\n        args: [\"-e\", \"console.log('Application built')\"],\n      },\n    ];\n\n    const buildResults = [];\n    let buildSuccess = true;\n\n    for (const step of buildSteps) {\n      try {\n        ctx.logger.log(`📦 Running: ${step.name}`);\n        const startTime = Date.now();\n\n        const result = await execFileAsync(step.command, step.args, {\n          cwd: ctx.root,\n          env: {\n            ...process.env,\n            NODE_ENV: environment,\n            BUILD_TYPE: buildType,\n          },\n        });\n\n        const duration = Date.now() - startTime;\n\n        buildResults.push({\n          step: step.name,\n          command: `${step.command} ${step.args.join(\" \")}`,\n          success: true,\n          duration,\n          stdout: result.stdout,\n          stderr: result.stderr,\n        });\n\n        ctx.logger.log(`✅ ${step.name} completed in ${duration}ms`);\n      } catch (error) {\n        const duration = Date.now() - startTime;\n\n        buildResults.push({\n          step: step.name,\n          command: `${step.command} ${step.args.join(\" \")}`,\n          success: false,\n          duration,\n          error: error.message,\n          stdout: error.stdout,\n          stderr: error.stderr,\n        });\n\n        ctx.logger.error(`❌ ${step.name} failed: ${error.message}`);\n\n        if (step.name === \"Run Tests\" || step.name === \"Check Dependencies\") {\n          buildSuccess = false;\n          break; // Stop on test or dependency failures\n        }\n      }\n    }\n\n    // Generate build report\n    const buildReport = {\n      ...buildInfo,\n      success: buildSuccess,\n      steps: buildResults,\n      summary: {\n        totalSteps: buildSteps.length,\n        successfulSteps: buildResults.filter((r) => r.success).length,\n        failedSteps: buildResults.filter((r) => !r.success).length,\n        totalDuration: buildResults.reduce((sum, r) => sum + r.duration, 0),\n      },\n    };\n\n    // Save build report\n    const reportPath = join(buildDir, \"build-report.json\");\n    await fs.writeFile(reportPath, JSON.stringify(buildReport, null, 2));\n\n    // Generate HTML build report\n    const htmlReportPath = await template.renderToFile(\n      \"cicd/build-report.njk\",\n      join(buildDir, \"build-report.html\"),\n      buildReport,\n    );\n\n    ctx.logger.log(\n      `📊 Build ${buildSuccess ? \"completed successfully\" : \"failed\"}`,\n    );\n    ctx.logger.log(`📝 Build report: ${reportPath}`);\n\n    return {\n      ok: buildSuccess,\n      artifacts: [reportPath, htmlReportPath],\n      data: buildReport,\n    };\n  },\n});\n"
        }
    ]
}