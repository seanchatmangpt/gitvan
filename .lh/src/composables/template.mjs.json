{
    "sourceFile": "src/composables/template.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1758045809012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758046012307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,15 +2,12 @@\n // GitVan v2 â€” useTemplate() with inflection filters and config discovery\n \n import { promises as fs } from \"node:fs\";\n import { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\n-import nunjucks from \"nunjucks\";\n-import * as inflection from \"inflection\";\n import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n import { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n+import { getCachedEnvironment, envKey } from \"../utils/nunjucks-config.mjs\";\n \n-const _envCache = new Map(); // key -> nunjucks.Environment\n-\n /**\n  * Bind context and resolve template configuration\n  * Integrates with config discovery for robust template path resolution\n  */\n@@ -71,94 +68,8 @@\n   return { root, paths, autoescape, noCache, nowISO, ctx };\n }\n \n /**\n- * Generate cache key for environment instances\n- */\n-function envKey({ paths, autoescape, noCache }) {\n-  return JSON.stringify({ paths, autoescape, noCache });\n-}\n-\n-/**\n- * Create Nunjucks environment with all filters and guards\n- */\n-function createEnv({ paths, autoescape, noCache }) {\n-  const loader = new nunjucks.FileSystemLoader(paths, { noCache });\n-  const env = new nunjucks.Environment(loader, {\n-    autoescape,\n-    throwOnUndefined: true,\n-  });\n-\n-  // Determinism guards - prevent non-deterministic operations\n-  env.addGlobal(\"now\", () => {\n-    throw new Error(\"Templates must not call now(); inject a value.\");\n-  });\n-  env.addGlobal(\"random\", () => {\n-    throw new Error(\"Templates must not use random(); inject values.\");\n-  });\n-\n-  // Built-in pure filters\n-  env.addFilter(\"json\", (v, space = 0) => JSON.stringify(v, null, space));\n-  env.addFilter(\"slug\", (s) =>\n-    String(s)\n-      .toLowerCase()\n-      .replace(/[^a-z0-9]+/g, \"-\")\n-      .replace(/(^-|-$)/g, \"\"),\n-  );\n-  env.addFilter(\"upper\", (s) => String(s).toUpperCase());\n-  env.addFilter(\"lower\", (s) => String(s).toLowerCase());\n-  env.addFilter(\"pad\", (s, n = 2, ch = \"0\") => String(s).padStart(n, ch));\n-\n-  // Inflection filters (direct passthrough to inflection library)\n-  env.addFilter(\"pluralize\", (s, plural) =>\n-    inflection.pluralize(String(s), plural),\n-  );\n-  env.addFilter(\"singularize\", (s, singular) =>\n-    inflection.singularize(String(s), singular),\n-  );\n-  env.addFilter(\"inflect\", (s, count, singular, plural) =>\n-    inflection.inflect(String(s), Number(count), singular, plural),\n-  );\n-  env.addFilter(\"camelize\", (s, lowFirst = false) =>\n-    inflection.camelize(String(s), !!lowFirst),\n-  );\n-  env.addFilter(\"underscore\", (s, allUpper = false) =>\n-    inflection.underscore(String(s), !!allUpper),\n-  );\n-  env.addFilter(\"humanize\", (s, lowFirst = false) =>\n-    inflection.humanize(String(s), !!lowFirst),\n-  );\n-  env.addFilter(\"capitalize\", (s) => inflection.capitalize(String(s)));\n-  env.addFilter(\"dasherize\", (s) => inflection.dasherize(String(s)));\n-  env.addFilter(\"titleize\", (s) => inflection.titleize(String(s)));\n-  env.addFilter(\"demodulize\", (s) => inflection.demodulize(String(s)));\n-  env.addFilter(\"tableize\", (s) => inflection.tableize(String(s)));\n-  env.addFilter(\"classify\", (s) => inflection.classify(String(s)));\n-  env.addFilter(\"foreign_key\", (s, dropIdUBar = false) =>\n-    inflection.foreign_key(String(s), !!dropIdUBar),\n-  );\n-  env.addFilter(\"ordinalize\", (s) => inflection.ordinalize(String(s)));\n-  env.addFilter(\"transform\", (s, arr = []) =>\n-    inflection.transform(String(s), Array.isArray(arr) ? arr : [arr]),\n-  );\n-\n-  return env;\n-}\n-\n-/**\n- * Get or create cached environment instance\n- */\n-function getEnv(binding) {\n-  const key = envKey(binding);\n-  let env = _envCache.get(key);\n-  if (!env) {\n-    env = createEnv(binding);\n-    _envCache.set(key, env);\n-  }\n-  return env;\n-}\n-\n-/**\n  * Ensure directory exists for file output\n  */\n async function ensureDir(filePath) {\n   await fs.mkdir(dirname(filePath), { recursive: true });\n@@ -177,9 +88,13 @@\n  * @returns {Object} Template engine instance\n  */\n export async function useTemplate(opts = {}) {\n   const binding = await bindContext(opts);\n-  const env = getEnv(binding);\n+  const env = getCachedEnvironment({\n+    paths: binding.paths,\n+    autoescape: binding.autoescape,\n+    noCache: binding.noCache,\n+  });\n \n   /**\n    * Prepare base data for template rendering\n    * Includes context data and deterministic timestamps\n@@ -291,9 +206,13 @@\n   const nowISO =\n     typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n \n   const binding = { root, paths, autoescape, noCache, nowISO, ctx };\n-  const env = getEnv(binding);\n+  const env = getCachedEnvironment({\n+    paths: binding.paths,\n+    autoescape: binding.autoescape,\n+    noCache: binding.noCache,\n+  });\n \n   function baseData(extra) {\n     const common = {};\n     if (binding.nowISO) common.nowISO = binding.nowISO;\n"
                },
                {
                    "date": 1758046934671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,14 +3,14 @@\n \n import { promises as fs } from \"node:fs\";\n import { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\n import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n-import { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n-import { getCachedEnvironment, envKey } from \"../utils/nunjucks-config.mjs\";\n+import { loadOptions } from \"../config/loader.mjs\";\n+import { getCachedEnvironment } from \"../utils/nunjucks-config.mjs\";\n \n /**\n  * Bind context and resolve template configuration\n- * Integrates with config discovery for robust template path resolution\n+ * Integrates with new config system for robust template path resolution\n  */\n async function bindContext(opts = {}) {\n   let ctx;\n   try {\n@@ -20,53 +20,37 @@\n   }\n \n   const root = (ctx && ctx.cwd) || process.cwd();\n \n-  // Try to discover templates directory from config if not explicitly provided\n+  // Load configuration using new config system\n+  const config = await loadOptions({ rootDir: root });\n+\n+  // Resolve template paths\n   let templatePaths = [];\n   if (Array.isArray(opts.paths) && opts.paths.length) {\n     templatePaths = opts.paths;\n   } else {\n-    // Use config discovery to find templates directory\n-    const templatesResult = await findTemplatesDir(root);\n-    if (templatesResult) {\n-      templatePaths = [templatesResult.templatesDir];\n-\n-      // Merge discovered config with context config\n-      if (templatesResult.config && !ctx?.config) {\n-        ctx = ctx || {};\n-        ctx.config = templatesResult.config;\n-      }\n-    } else {\n-      // Fallback to context config or default\n-      const cfgDirs =\n-        (ctx &&\n-          ctx.config &&\n-          ctx.config.templates &&\n-          ctx.config.templates.dirs) ||\n-        [];\n-      templatePaths = cfgDirs.length ? cfgDirs : [\"templates\"];\n-    }\n+    // Use config templates directories\n+    templatePaths = config.templates.dirs.map((dir) => presolve(root, dir));\n   }\n \n-  // Resolve all paths relative to root\n-  const paths = templatePaths.map((p) => presolve(root, p));\n-\n-  // Configuration options with precedence: opts > ctx.config > defaults\n+  // Configuration options with precedence: opts > config > defaults\n   const autoescape =\n     typeof opts.autoescape === \"boolean\"\n       ? opts.autoescape\n-      : getConfigValue(ctx?.config, \"templates.autoescape\", false);\n+      : config.templates.autoescape;\n \n   const noCache =\n-    typeof opts.noCache === \"boolean\"\n-      ? opts.noCache\n-      : getConfigValue(ctx?.config, \"templates.noCache\", true);\n+    typeof opts.noCache === \"boolean\" ? opts.noCache : config.templates.noCache;\n \n   const nowISO =\n-    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n+    typeof ctx?.now === \"function\"\n+      ? ctx.now()\n+      : typeof config.now === \"function\"\n+        ? config.now()\n+        : process.env.GITVAN_NOW || null;\n \n-  return { root, paths, autoescape, noCache, nowISO, ctx };\n+  return { root, paths: templatePaths, autoescape, noCache, nowISO, ctx };\n }\n \n /**\n  * Ensure directory exists for file output\n@@ -181,28 +165,19 @@\n     ctx = tryUseGitVan?.() || null;\n   }\n \n   const root = (ctx && ctx.cwd) || process.cwd();\n-  const cfgDirs =\n-    (ctx && ctx.config && ctx.config.templates && ctx.config.templates.dirs) ||\n-    [];\n-  const paths = (\n-    Array.isArray(opts.paths) && opts.paths.length\n-      ? opts.paths\n-      : cfgDirs.length\n-        ? cfgDirs\n-        : [\"templates\"]\n-  ).map((p) => presolve(root, p));\n \n+  // Use default template configuration for sync version\n+  const templatePaths =\n+    Array.isArray(opts.paths) && opts.paths.length ? opts.paths : [\"templates\"];\n+\n+  const paths = templatePaths.map((p) => presolve(root, p));\n+\n   const autoescape =\n-    typeof opts.autoescape === \"boolean\"\n-      ? opts.autoescape\n-      : ((ctx && ctx.config?.templates?.autoescape) ?? false);\n+    typeof opts.autoescape === \"boolean\" ? opts.autoescape : false;\n \n-  const noCache =\n-    typeof opts.noCache === \"boolean\"\n-      ? opts.noCache\n-      : ((ctx && ctx.config?.templates?.noCache) ?? true);\n+  const noCache = typeof opts.noCache === \"boolean\" ? opts.noCache : true;\n \n   const nowISO =\n     typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n \n"
                },
                {
                    "date": 1758074347127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,19 @@\n // src/composables/template.mjs\n // GitVan v2 â€” useTemplate() with inflection filters and config discovery\n \n import { promises as fs } from \"node:fs\";\n-import { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\n+import { join, dirname, resolve as presolve, isAbsolute, relative } from \"pathe\";\n import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n import { loadOptions } from \"../config/loader.mjs\";\n import { getCachedEnvironment } from \"../utils/nunjucks-config.mjs\";\n+import { parseFrontmatter } from \"../utils/frontmatter.mjs\";\n+import { injectString } from \"../utils/inject.mjs\";\n+import { runShellHooks } from \"../utils/shell.mjs\";\n+import { writeReceipt } from \"../runtime/receipt.mjs\";\n+import { acquireLock, releaseLock, generateLockRef } from \"../runtime/locks.mjs\";\n+import { FrontmatterSchema } from \"../schemas/frontmatter.zod.mjs\";\n+import { sha256Hex } from \"../utils/crypto.mjs\";\n \n /**\n  * Bind context and resolve template configuration\n  * Integrates with new config system for robust template path resolution\n@@ -59,8 +66,28 @@\n   await fs.mkdir(dirname(filePath), { recursive: true });\n }\n \n /**\n+ * Helper to render any string values inside an object with Nunjucks\n+ * @param {Object} env - Nunjucks environment\n+ * @param {Object} obj - Object to render\n+ * @param {Object} context - Template context\n+ * @returns {Object} Rendered object\n+ */\n+function renderObjectValues(env, obj, context) {\n+  if (!obj) return obj;\n+  const walk = (v) => {\n+    if (typeof v === 'string') return env.renderString(v, context);\n+    if (Array.isArray(v)) return v.map(walk);\n+    if (v && typeof v === 'object') {\n+      return Object.fromEntries(Object.entries(v).map(([k, vv]) => [k, walk(vv)]));\n+    }\n+    return v;\n+  };\n+  return walk(obj);\n+}\n+\n+/**\n  * GitVan Template Engine\n  *\n  * Provides template rendering with inflection filters, config discovery,\n  * and deterministic environment for reproducible builds.\n@@ -149,8 +176,212 @@\n      */\n     get root() {\n       return binding.root;\n     },\n+\n+    /**\n+     * Creates a verifiable, dry-run plan of all intended operations.\n+     * Supports Hygen-style front-matter with to, inject, copy, sh, when, force directives.\n+     * @param {string} templatePath - Path to template file\n+     * @param {Object} data - Template data\n+     * @returns {Promise<Object>} Plan object with operations and hooks\n+     */\n+    async plan(templatePath, data = {}) {\n+      const srcPath = binding.paths.map(p => join(p, templatePath)).find(p => fs.stat(p).catch(() => false)) || presolve(binding.root, templatePath);\n+      const raw = await fs.readFile(srcPath, 'utf8');\n+      const { data: rawFmData, body } = parseFrontmatter(raw);\n+\n+      // Validate and merge frontmatter\n+      const fmData = FrontmatterSchema.parse(rawFmData);\n+      const mergedContext = { ...baseData(), ...fmData.data, ...data };\n+      const fm = renderObjectValues(env, fmData, mergedContext);\n+      \n+      // Evaluate 'when' predicate\n+      if (fm.when === false || fm.when === 'false') {\n+        return { \n+          template: templatePath, \n+          skipped: true, \n+          reason: 'when=false', \n+          operations: [], \n+          hooks: {} \n+        };\n+      }\n+\n+      const operations = [];\n+      const renderedBody = env.renderString(body, mergedContext);\n+\n+      // Multi-Output: 'to' array and 'perFile'\n+      const targets = [].concat(fm.to || []);\n+      for (const to of targets) {\n+        operations.push({ \n+          type: 'write', \n+          to, \n+          content: renderedBody, \n+          hash: sha256Hex(renderedBody), \n+          force: fm.force \n+        });\n+      }\n+      \n+      for (const file of [].concat(fm.perFile || [])) {\n+        const perFileContext = { ...mergedContext, ...file.data };\n+        const perFileBody = env.renderString(body, perFileContext);\n+        operations.push({ \n+          type: 'write', \n+          to: file.to, \n+          content: perFileBody, \n+          hash: sha256Hex(perFileBody), \n+          force: fm.force \n+        });\n+      }\n+\n+      // Injections\n+      for (const inj of [].concat(fm.inject || [])) {\n+        const snippet = env.renderString(inj.snippet || '', mergedContext);\n+        operations.push({ \n+          type: 'inject', \n+          into: inj.into, \n+          snippet, \n+          hash: sha256Hex(snippet), \n+          ...inj \n+        });\n+      }\n+\n+      // Copies\n+      for (const c of [].concat(fm.copy || [])) {\n+        operations.push({ \n+          type: 'copy', \n+          from: presolve(binding.root, c.from), \n+          to: presolve(binding.root, c.to) \n+        });\n+      }\n+\n+      return {\n+        template: templatePath,\n+        skipped: false,\n+        operations,\n+        hooks: { before: fm.sh?.before || [], after: fm.sh?.after || [] },\n+      };\n+    },\n+\n+    /**\n+     * Executes a plan and writes receipts.\n+     * @param {Object} plan - Plan object from plan() method\n+     * @param {Object} options - Apply options\n+     * @param {boolean} options.dryRun - If true, only simulate operations\n+     * @returns {Promise<Object>} Receipt with operation results\n+     */\n+    async apply(plan, { dryRun = false } = {}) {\n+      if (plan.skipped) {\n+        return { status: 'SKIPPED', reason: plan.reason, results: [] };\n+      }\n+\n+      const results = [];\n+      const locks = new Set();\n+      const head = await binding.ctx?.head?.() || 'HEAD';\n+\n+      try {\n+        // Acquire all necessary locks first\n+        for (const op of plan.operations) {\n+          const lockPath = generateLockRef('template', op.to || op.into);\n+          if (!await acquireLock(lockPath, head)) {\n+            throw new Error(`Failed to acquire lock for: ${op.to || op.into}`);\n+          }\n+          locks.add(lockPath);\n+        }\n+\n+        // Run 'before' hooks\n+        const beforeResults = await runShellHooks(plan.hooks.before, { \n+          config: await loadOptions({ rootDir: binding.root }), \n+          context: binding \n+        });\n+        results.push(...beforeResults.map(r => ({ op: 'sh.before', ...r })));\n+\n+        // Perform file operations\n+        for (const op of plan.operations) {\n+          if (dryRun) {\n+            results.push({ ...op, status: 'DRY_RUN' });\n+            continue;\n+          }\n+          \n+          const targetPath = presolve(binding.root, op.to || op.into);\n+          \n+          // Path Sandboxing: Ensure target is within the root directory\n+          if (!targetPath.startsWith(binding.root)) {\n+            throw new Error(`Path escape violation: ${targetPath}`);\n+          }\n+\n+          if (op.type === 'write') {\n+            const exists = await fs.stat(targetPath).then(() => true).catch(() => false);\n+            if (exists && op.force === 'error') {\n+              throw new Error(`File exists and force policy is 'error': ${relative(binding.root, targetPath)}`);\n+            }\n+            if (exists && op.force === 'skip') {\n+              results.push({ ...op, status: 'SKIPPED', reason: 'File exists' });\n+              continue;\n+            }\n+            \n+            await ensureDir(targetPath);\n+            const writeMode = exists && op.force === 'append' ? fs.appendFile : fs.writeFile;\n+            await writeMode(targetPath, op.content, 'utf8');\n+            results.push({ ...op, status: 'OK' });\n+            \n+          } else if (op.type === 'inject') {\n+            const currentContent = await fs.readFile(targetPath, 'utf8').catch(() => '');\n+            const { changed, content: newContent } = injectString(currentContent, op);\n+            if (changed) {\n+              await fs.writeFile(targetPath, newContent, 'utf8');\n+            }\n+            results.push({ ...op, status: 'OK', changed });\n+            \n+          } else if (op.type === 'copy') {\n+            await ensureDir(op.to);\n+            await fs.copyFile(op.from, op.to);\n+            results.push({ ...op, status: 'OK' });\n+          }\n+        }\n+\n+        // Run 'after' hooks\n+        const afterResults = await runShellHooks(plan.hooks.after, { \n+          config: await loadOptions({ rootDir: binding.root }), \n+          context: binding \n+        });\n+        results.push(...afterResults.map(r => ({ op: 'sh.after', ...r })));\n+\n+        // Write a comprehensive receipt\n+        const receiptPayload = {\n+          kind: 'template-receipt',\n+          id: plan.template,\n+          status: results.some(r => r.status === 'ERROR') ? 'ERROR' : 'OK',\n+          dryRun,\n+          operations: results,\n+        };\n+\n+        if (!dryRun) {\n+          await writeReceipt(receiptPayload, { ref: 'refs/notes/gitvan/results' });\n+        }\n+\n+        return receiptPayload;\n+\n+      } catch (error) {\n+        const receipt = { \n+          kind: 'template-receipt', \n+          id: plan.template, \n+          status: 'ERROR', \n+          error: error.message, \n+          dryRun, \n+          operations: results \n+        };\n+        if (!dryRun) {\n+          await writeReceipt(receipt, { ref: 'refs/notes/gitvan/results' });\n+        }\n+        throw error; // Re-throw after writing receipt\n+      } finally {\n+        // Ensure all locks are released\n+        for (const lock of locks) {\n+          await releaseLock(lock);\n+        }\n+      }\n+    },\n   };\n }\n \n /**\n"
                }
            ],
            "date": 1758045809012,
            "name": "Commit-0",
            "content": "// src/composables/template.mjs\n// GitVan v2 â€” useTemplate() with inflection filters and config discovery\n\nimport { promises as fs } from \"node:fs\";\nimport { join, dirname, resolve as presolve, isAbsolute } from \"pathe\";\nimport nunjucks from \"nunjucks\";\nimport * as inflection from \"inflection\";\nimport { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\nimport { findTemplatesDir, getConfigValue } from \"../utils/config-finder.mjs\";\n\nconst _envCache = new Map(); // key -> nunjucks.Environment\n\n/**\n * Bind context and resolve template configuration\n * Integrates with config discovery for robust template path resolution\n */\nasync function bindContext(opts = {}) {\n  let ctx;\n  try {\n    ctx = useGitVan();\n  } catch {\n    ctx = tryUseGitVan?.() || null;\n  }\n\n  const root = (ctx && ctx.cwd) || process.cwd();\n\n  // Try to discover templates directory from config if not explicitly provided\n  let templatePaths = [];\n  if (Array.isArray(opts.paths) && opts.paths.length) {\n    templatePaths = opts.paths;\n  } else {\n    // Use config discovery to find templates directory\n    const templatesResult = await findTemplatesDir(root);\n    if (templatesResult) {\n      templatePaths = [templatesResult.templatesDir];\n\n      // Merge discovered config with context config\n      if (templatesResult.config && !ctx?.config) {\n        ctx = ctx || {};\n        ctx.config = templatesResult.config;\n      }\n    } else {\n      // Fallback to context config or default\n      const cfgDirs =\n        (ctx &&\n          ctx.config &&\n          ctx.config.templates &&\n          ctx.config.templates.dirs) ||\n        [];\n      templatePaths = cfgDirs.length ? cfgDirs : [\"templates\"];\n    }\n  }\n\n  // Resolve all paths relative to root\n  const paths = templatePaths.map((p) => presolve(root, p));\n\n  // Configuration options with precedence: opts > ctx.config > defaults\n  const autoescape =\n    typeof opts.autoescape === \"boolean\"\n      ? opts.autoescape\n      : getConfigValue(ctx?.config, \"templates.autoescape\", false);\n\n  const noCache =\n    typeof opts.noCache === \"boolean\"\n      ? opts.noCache\n      : getConfigValue(ctx?.config, \"templates.noCache\", true);\n\n  const nowISO =\n    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n\n  return { root, paths, autoescape, noCache, nowISO, ctx };\n}\n\n/**\n * Generate cache key for environment instances\n */\nfunction envKey({ paths, autoescape, noCache }) {\n  return JSON.stringify({ paths, autoescape, noCache });\n}\n\n/**\n * Create Nunjucks environment with all filters and guards\n */\nfunction createEnv({ paths, autoescape, noCache }) {\n  const loader = new nunjucks.FileSystemLoader(paths, { noCache });\n  const env = new nunjucks.Environment(loader, {\n    autoescape,\n    throwOnUndefined: true,\n  });\n\n  // Determinism guards - prevent non-deterministic operations\n  env.addGlobal(\"now\", () => {\n    throw new Error(\"Templates must not call now(); inject a value.\");\n  });\n  env.addGlobal(\"random\", () => {\n    throw new Error(\"Templates must not use random(); inject values.\");\n  });\n\n  // Built-in pure filters\n  env.addFilter(\"json\", (v, space = 0) => JSON.stringify(v, null, space));\n  env.addFilter(\"slug\", (s) =>\n    String(s)\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"-\")\n      .replace(/(^-|-$)/g, \"\"),\n  );\n  env.addFilter(\"upper\", (s) => String(s).toUpperCase());\n  env.addFilter(\"lower\", (s) => String(s).toLowerCase());\n  env.addFilter(\"pad\", (s, n = 2, ch = \"0\") => String(s).padStart(n, ch));\n\n  // Inflection filters (direct passthrough to inflection library)\n  env.addFilter(\"pluralize\", (s, plural) =>\n    inflection.pluralize(String(s), plural),\n  );\n  env.addFilter(\"singularize\", (s, singular) =>\n    inflection.singularize(String(s), singular),\n  );\n  env.addFilter(\"inflect\", (s, count, singular, plural) =>\n    inflection.inflect(String(s), Number(count), singular, plural),\n  );\n  env.addFilter(\"camelize\", (s, lowFirst = false) =>\n    inflection.camelize(String(s), !!lowFirst),\n  );\n  env.addFilter(\"underscore\", (s, allUpper = false) =>\n    inflection.underscore(String(s), !!allUpper),\n  );\n  env.addFilter(\"humanize\", (s, lowFirst = false) =>\n    inflection.humanize(String(s), !!lowFirst),\n  );\n  env.addFilter(\"capitalize\", (s) => inflection.capitalize(String(s)));\n  env.addFilter(\"dasherize\", (s) => inflection.dasherize(String(s)));\n  env.addFilter(\"titleize\", (s) => inflection.titleize(String(s)));\n  env.addFilter(\"demodulize\", (s) => inflection.demodulize(String(s)));\n  env.addFilter(\"tableize\", (s) => inflection.tableize(String(s)));\n  env.addFilter(\"classify\", (s) => inflection.classify(String(s)));\n  env.addFilter(\"foreign_key\", (s, dropIdUBar = false) =>\n    inflection.foreign_key(String(s), !!dropIdUBar),\n  );\n  env.addFilter(\"ordinalize\", (s) => inflection.ordinalize(String(s)));\n  env.addFilter(\"transform\", (s, arr = []) =>\n    inflection.transform(String(s), Array.isArray(arr) ? arr : [arr]),\n  );\n\n  return env;\n}\n\n/**\n * Get or create cached environment instance\n */\nfunction getEnv(binding) {\n  const key = envKey(binding);\n  let env = _envCache.get(key);\n  if (!env) {\n    env = createEnv(binding);\n    _envCache.set(key, env);\n  }\n  return env;\n}\n\n/**\n * Ensure directory exists for file output\n */\nasync function ensureDir(filePath) {\n  await fs.mkdir(dirname(filePath), { recursive: true });\n}\n\n/**\n * GitVan Template Engine\n *\n * Provides template rendering with inflection filters, config discovery,\n * and deterministic environment for reproducible builds.\n *\n * @param {Object} opts - Template options\n * @param {string[]} opts.paths - Custom template paths (overrides config discovery)\n * @param {boolean} opts.autoescape - Enable HTML auto-escaping\n * @param {boolean} opts.noCache - Disable template caching\n * @returns {Object} Template engine instance\n */\nexport async function useTemplate(opts = {}) {\n  const binding = await bindContext(opts);\n  const env = getEnv(binding);\n\n  /**\n   * Prepare base data for template rendering\n   * Includes context data and deterministic timestamps\n   */\n  function baseData(extra) {\n    const common = {};\n    if (binding.nowISO) common.nowISO = binding.nowISO;\n    if (binding.ctx) common.git = binding.ctx;\n    return { ...common, ...(extra || {}) };\n  }\n\n  return {\n    /**\n     * Render template from file\n     * @param {string} templateName - Template file name\n     * @param {Object} data - Template data\n     * @returns {string} Rendered content\n     */\n    render(templateName, data = {}) {\n      return env.render(String(templateName), baseData(data));\n    },\n\n    /**\n     * Render template from string\n     * @param {string} templateStr - Template string\n     * @param {Object} data - Template data\n     * @returns {string} Rendered content\n     */\n    renderString(templateStr, data = {}) {\n      return env.renderString(String(templateStr), baseData(data));\n    },\n\n    /**\n     * Render template to file\n     * @param {string} templateName - Template file name\n     * @param {string} outPath - Output file path\n     * @param {Object} data - Template data\n     * @returns {Object} { path: string, bytes: number }\n     */\n    async renderToFile(templateName, outPath, data = {}) {\n      const abs = isAbsolute(outPath) ? outPath : join(binding.root, outPath);\n      await ensureDir(abs);\n      const text = env.render(String(templateName), baseData(data));\n      const buf = Buffer.from(text, \"utf8\");\n      await fs.writeFile(abs, buf);\n      return { path: outPath, bytes: buf.length };\n    },\n\n    /**\n     * Get the underlying Nunjucks environment\n     * @returns {nunjucks.Environment}\n     */\n    get env() {\n      return env;\n    },\n\n    /**\n     * Get template paths being used\n     * @returns {string[]}\n     */\n    get paths() {\n      return binding.paths;\n    },\n\n    /**\n     * Get root directory\n     * @returns {string}\n     */\n    get root() {\n      return binding.root;\n    },\n  };\n}\n\n/**\n * Synchronous version for backward compatibility\n * Note: This version cannot use config discovery and relies on context only\n */\nexport function useTemplateSync(opts = {}) {\n  let ctx;\n  try {\n    ctx = useGitVan();\n  } catch {\n    ctx = tryUseGitVan?.() || null;\n  }\n\n  const root = (ctx && ctx.cwd) || process.cwd();\n  const cfgDirs =\n    (ctx && ctx.config && ctx.config.templates && ctx.config.templates.dirs) ||\n    [];\n  const paths = (\n    Array.isArray(opts.paths) && opts.paths.length\n      ? opts.paths\n      : cfgDirs.length\n        ? cfgDirs\n        : [\"templates\"]\n  ).map((p) => presolve(root, p));\n\n  const autoescape =\n    typeof opts.autoescape === \"boolean\"\n      ? opts.autoescape\n      : ((ctx && ctx.config?.templates?.autoescape) ?? false);\n\n  const noCache =\n    typeof opts.noCache === \"boolean\"\n      ? opts.noCache\n      : ((ctx && ctx.config?.templates?.noCache) ?? true);\n\n  const nowISO =\n    typeof ctx?.now === \"function\" ? ctx.now() : process.env.GITVAN_NOW || null;\n\n  const binding = { root, paths, autoescape, noCache, nowISO, ctx };\n  const env = getEnv(binding);\n\n  function baseData(extra) {\n    const common = {};\n    if (binding.nowISO) common.nowISO = binding.nowISO;\n    if (binding.ctx) common.git = binding.ctx;\n    return { ...common, ...(extra || {}) };\n  }\n\n  return {\n    render(templateName, data = {}) {\n      return env.render(String(templateName), baseData(data));\n    },\n    renderString(templateStr, data = {}) {\n      return env.renderString(String(templateStr), baseData(data));\n    },\n    async renderToFile(templateName, outPath, data = {}) {\n      const abs = isAbsolute(outPath) ? outPath : join(binding.root, outPath);\n      await ensureDir(abs);\n      const text = env.render(String(templateName), baseData(data));\n      const buf = Buffer.from(text, \"utf8\");\n      await fs.writeFile(abs, buf);\n      return { path: outPath, bytes: buf.length };\n    },\n    get env() {\n      return env;\n    },\n    get paths() {\n      return binding.paths;\n    },\n    get root() {\n      return binding.root;\n    },\n  };\n}\n"
        }
    ]
}