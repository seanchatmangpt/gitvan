{
    "sourceFile": "src/jobs/cron.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758048964986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758048964986,
            "name": "Commit-0",
            "content": "// src/jobs/cron.mjs\n// GitVan v2 — Cron Scheduler\n// Lightweight cron scheduler for job execution\n\nimport { getCronJobs } from \"./scan.mjs\";\nimport { JobRunner } from \"./runner.mjs\";\nimport { loadOptions } from \"../config/loader.mjs\";\n\n/**\n * Simple cron parser and scheduler\n */\nexport class CronScheduler {\n  constructor(options = {}) {\n    this.options = options;\n    this.config = null;\n    this.runner = null;\n    this.schedule = new Map(); // Map of cron expressions to job definitions\n    this.timers = new Map(); // Map of cron expressions to timer IDs\n    this.isRunning = false;\n    this.tickInterval = options.tickInterval || 60000; // Check every minute\n    this.tickTimer = null;\n  }\n\n  async init() {\n    this.config = await loadOptions();\n    this.runner = new JobRunner({\n      receiptsRef: this.config.receipts.ref,\n      hooks: this.config.hooks,\n    });\n  }\n\n  /**\n   * Parse cron expression into next execution time\n   * Supports basic 5-field cron: minute hour day month weekday\n   */\n  parseCron(cronExpr) {\n    const parts = cronExpr.trim().split(/\\s+/);\n    if (parts.length !== 5) {\n      throw new Error(\n        `Invalid cron expression: ${cronExpr} (expected 5 fields)`,\n      );\n    }\n\n    const [minute, hour, day, month, weekday] = parts;\n\n    return {\n      minute: this.parseField(minute, 0, 59),\n      hour: this.parseField(hour, 0, 23),\n      day: this.parseField(day, 1, 31),\n      month: this.parseField(month, 1, 12),\n      weekday: this.parseField(weekday, 0, 6), // 0 = Sunday\n    };\n  }\n\n  /**\n   * Parse a single cron field (minute, hour, etc.)\n   */\n  parseField(field, min, max) {\n    if (field === \"*\") {\n      return null; // Any value\n    }\n\n    if (field.includes(\",\")) {\n      // Comma-separated values\n      return field.split(\",\").map((v) => parseInt(v.trim(), 10));\n    }\n\n    if (field.includes(\"-\")) {\n      // Range\n      const [start, end] = field.split(\"-\").map((v) => parseInt(v.trim(), 10));\n      return { start, end };\n    }\n\n    if (field.includes(\"/\")) {\n      // Step values\n      const [base, step] = field.split(\"/\").map((v) => v.trim());\n      const baseValue = base === \"*\" ? min : parseInt(base, 10);\n      const stepValue = parseInt(step, 10);\n      return { base: baseValue, step: stepValue };\n    }\n\n    // Single value\n    const value = parseInt(field, 10);\n    if (isNaN(value) || value < min || value > max) {\n      throw new Error(`Invalid cron field: ${field} (must be ${min}-${max})`);\n    }\n    return value;\n  }\n\n  /**\n   * Check if a cron expression matches the current time\n   */\n  matchesCron(cronSpec, now = new Date()) {\n    const minute = now.getMinutes();\n    const hour = now.getHours();\n    const day = now.getDate();\n    const month = now.getMonth() + 1; // JavaScript months are 0-based\n    const weekday = now.getDay();\n\n    return (\n      this.matchesField(cronSpec.minute, minute) &&\n      this.matchesField(cronSpec.hour, hour) &&\n      this.matchesField(cronSpec.day, day) &&\n      this.matchesField(cronSpec.month, month) &&\n      this.matchesField(cronSpec.weekday, weekday)\n    );\n  }\n\n  /**\n   * Check if a field value matches the cron specification\n   */\n  matchesField(spec, value) {\n    if (spec === null) return true; // \"*\" matches any value\n    if (typeof spec === \"number\") return spec === value;\n    if (Array.isArray(spec)) return spec.includes(value);\n    if (typeof spec === \"object\") {\n      if (spec.start !== undefined && spec.end !== undefined) {\n        return value >= spec.start && value <= spec.end;\n      }\n      if (spec.base !== undefined && spec.step !== undefined) {\n        return (value - spec.base) % spec.step === 0 && value >= spec.base;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Calculate next execution time for a cron expression\n   */\n  getNextExecution(cronSpec, from = new Date()) {\n    const next = new Date(from);\n    next.setSeconds(0, 0); // Reset seconds and milliseconds\n\n    // Try every minute for the next 24 hours\n    for (let i = 0; i < 24 * 60; i++) {\n      if (this.matchesCron(cronSpec, next)) {\n        return next;\n      }\n      next.setMinutes(next.getMinutes() + 1);\n    }\n\n    // If no match found in 24 hours, return null\n    return null;\n  }\n\n  /**\n   * Load cron jobs and build schedule\n   */\n  async loadSchedule() {\n    await this.init();\n    const cronJobs = await getCronJobs({ cwd: this.config.rootDir });\n\n    this.schedule.clear();\n\n    for (const job of cronJobs) {\n      try {\n        const cronSpec = this.parseCron(job.cron);\n        this.schedule.set(job.cron, { job, spec: cronSpec });\n      } catch (error) {\n        console.warn(\n          `Invalid cron expression for job ${job.id}: ${job.cron}`,\n          error.message,\n        );\n      }\n    }\n\n    console.log(`Loaded ${this.schedule.size} cron jobs`);\n  }\n\n  /**\n   * Check for jobs that should run now\n   */\n  async checkAndRunJobs() {\n    const now = new Date();\n    const jobsToRun = [];\n\n    for (const [cronExpr, { job, spec }] of this.schedule) {\n      if (this.matchesCron(spec, now)) {\n        jobsToRun.push(job);\n      }\n    }\n\n    if (jobsToRun.length === 0) {\n      return;\n    }\n\n    console.log(\n      `Running ${jobsToRun.length} scheduled jobs at ${now.toISOString()}`,\n    );\n\n    // Run jobs in parallel\n    const promises = jobsToRun.map(async (job) => {\n      try {\n        const result = await this.runner.runJob(job, {\n          trigger: {\n            kind: \"cron\",\n            fingerprint: `cron-${now.getTime()}`,\n            data: { cronExpr: job.cron, scheduledAt: now.toISOString() },\n          },\n        });\n        console.log(`✅ Cron job ${job.id} completed successfully`);\n        return result;\n      } catch (error) {\n        console.error(`❌ Cron job ${job.id} failed:`, error.message);\n        throw error;\n      }\n    });\n\n    try {\n      await Promise.all(promises);\n    } catch (error) {\n      console.error(\"Some cron jobs failed:\", error.message);\n    }\n  }\n\n  /**\n   * Start the cron scheduler\n   */\n  async start() {\n    if (this.isRunning) {\n      console.warn(\"Cron scheduler is already running\");\n      return;\n    }\n\n    await this.loadSchedule();\n\n    this.isRunning = true;\n    console.log(\"Starting cron scheduler...\");\n\n    // Run initial check\n    await this.checkAndRunJobs();\n\n    // Set up periodic checks\n    this.tickTimer = setInterval(async () => {\n      try {\n        await this.checkAndRunJobs();\n      } catch (error) {\n        console.error(\"Cron scheduler error:\", error.message);\n      }\n    }, this.tickInterval);\n\n    console.log(\n      `Cron scheduler started (checking every ${this.tickInterval / 1000}s)`,\n    );\n  }\n\n  /**\n   * Stop the cron scheduler\n   */\n  stop() {\n    if (!this.isRunning) {\n      console.warn(\"Cron scheduler is not running\");\n      return;\n    }\n\n    this.isRunning = false;\n\n    if (this.tickTimer) {\n      clearInterval(this.tickTimer);\n      this.tickTimer = null;\n    }\n\n    console.log(\"Cron scheduler stopped\");\n  }\n\n  /**\n   * Get scheduler status\n   */\n  getStatus() {\n    return {\n      isRunning: this.isRunning,\n      scheduleSize: this.schedule.size,\n      tickInterval: this.tickInterval,\n      nextCheck: this.isRunning\n        ? new Date(Date.now() + this.tickInterval)\n        : null,\n    };\n  }\n\n  /**\n   * List scheduled jobs with next execution times\n   */\n  listSchedule() {\n    const schedule = [];\n\n    for (const [cronExpr, { job, spec }] of this.schedule) {\n      const nextExecution = this.getNextExecution(spec);\n      schedule.push({\n        id: job.id,\n        cron: cronExpr,\n        nextExecution: nextExecution?.toISOString() || \"No upcoming execution\",\n        description: job.meta?.desc || \"No description\",\n      });\n    }\n\n    return schedule.sort((a, b) => {\n      if (a.nextExecution === \"No upcoming execution\") return 1;\n      if (b.nextExecution === \"No upcoming execution\") return -1;\n      return new Date(a.nextExecution) - new Date(b.nextExecution);\n    });\n  }\n\n  /**\n   * Dry run: show what would run at a specific time\n   */\n  dryRun(at = new Date()) {\n    const jobsToRun = [];\n\n    for (const [cronExpr, { job, spec }] of this.schedule) {\n      if (this.matchesCron(spec, at)) {\n        jobsToRun.push({\n          id: job.id,\n          cron: cronExpr,\n          description: job.meta?.desc || \"No description\",\n        });\n      }\n    }\n\n    return {\n      at: at.toISOString(),\n      jobsToRun,\n      totalJobs: jobsToRun.length,\n    };\n  }\n}\n\n/**\n * Create and start a cron scheduler\n */\nexport async function startCronScheduler(options = {}) {\n  const scheduler = new CronScheduler(options);\n  await scheduler.start();\n  return scheduler;\n}\n\n/**\n * CLI command for cron operations\n */\nexport class CronCLI {\n  constructor() {\n    this.scheduler = null;\n  }\n\n  async init() {\n    this.scheduler = new CronScheduler();\n    await this.scheduler.init();\n  }\n\n  /**\n   * List cron schedule\n   */\n  async list() {\n    await this.init();\n    await this.scheduler.loadSchedule();\n\n    const schedule = this.scheduler.listSchedule();\n\n    if (schedule.length === 0) {\n      console.log(\"No cron jobs scheduled\");\n      return;\n    }\n\n    console.log(\"Cron Schedule:\");\n    console.log(\n      \"ID\".padEnd(20) +\n        \"CRON\".padEnd(20) +\n        \"NEXT EXECUTION\".padEnd(25) +\n        \"DESCRIPTION\",\n    );\n    console.log(\"-\".repeat(80));\n\n    for (const item of schedule) {\n      const id = item.id.padEnd(20);\n      const cron = item.cron.padEnd(20);\n      const next = item.nextExecution.padEnd(25);\n      const desc = item.description;\n      console.log(`${id}${cron}${next}${desc}`);\n    }\n  }\n\n  /**\n   * Dry run cron jobs\n   */\n  async dryRun(at) {\n    await this.init();\n    await this.scheduler.loadSchedule();\n\n    const targetTime = at ? new Date(at) : new Date();\n    const result = this.scheduler.dryRun(targetTime);\n\n    console.log(`Cron dry run at ${result.at}:`);\n\n    if (result.jobsToRun.length === 0) {\n      console.log(\"No jobs would run at this time\");\n      return;\n    }\n\n    console.log(`Would run ${result.totalJobs} jobs:`);\n    result.jobsToRun.forEach((job) => {\n      console.log(`  - ${job.id} (${job.cron}) - ${job.description}`);\n    });\n  }\n\n  /**\n   * Start cron scheduler\n   */\n  async start() {\n    await this.init();\n    await this.scheduler.start();\n\n    // Keep the process alive\n    process.on(\"SIGINT\", () => {\n      console.log(\"\\nShutting down cron scheduler...\");\n      this.scheduler.stop();\n      process.exit(0);\n    });\n\n    process.on(\"SIGTERM\", () => {\n      console.log(\"\\nShutting down cron scheduler...\");\n      this.scheduler.stop();\n      process.exit(0);\n    });\n  }\n}\n"
        }
    ]
}