{
    "sourceFile": "docs/cookbook/documentation/changelog-generation.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758051806640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758051806640,
            "name": "Commit-0",
            "content": "# Changelog Generation\n\n## üéØ **Recipe Overview**\n\n**Category**: Documentation  \n**Difficulty**: Beginner  \n**Time**: 20 minutes  \n**Prerequisites**: Basic GitVan knowledge, Git repository\n\n## üìã **Problem**\n\nYou need to automatically generate changelogs from your Git repository history. You want a flexible system that can create different formats and include various commit information.\n\n## üç≥ **Solution**\n\n### **Step 1: Create Basic Changelog Job**\n\n```javascript\n// jobs/docs/changelog.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Generate changelog from git commit history\",\n    tags: [\"documentation\", \"changelog\", \"git\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get commit limit from payload or default\n    const limit = payload?.limit || 50;\n    \n    // Get recent commits\n    const logOutput = await git.log(\"%h%x09%s%x09%an%x09%ad\", [\"-n\", limit.toString()]);\n    const lines = logOutput.split(\"\\n\").filter(Boolean);\n    \n    // Parse commits\n    const commits = lines.map((line) => {\n      const [hash, subject, author, date] = line.split(\"\\t\");\n      return {\n        hash,\n        subject,\n        author,\n        date: new Date(date).toISOString(),\n        shortHash: hash.substring(0, 7)\n      };\n    });\n    \n    // Group commits by type (conventional commits)\n    const groupedCommits = {\n      features: [],\n      fixes: [],\n      breaking: [],\n      other: []\n    };\n    \n    commits.forEach(commit => {\n      const subject = commit.subject.toLowerCase();\n      if (subject.startsWith('feat:')) {\n        groupedCommits.features.push(commit);\n      } else if (subject.startsWith('fix:')) {\n        groupedCommits.fixes.push(commit);\n      } else if (subject.includes('breaking change') || subject.includes('!:')) {\n        groupedCommits.breaking.push(commit);\n      } else {\n        groupedCommits.other.push(commit);\n      }\n    });\n    \n    // Prepare template data\n    const data = {\n      title: \"Changelog\",\n      subtitle: `Generated from ${commits.length} recent commits`,\n      commits,\n      groupedCommits,\n      generatedAt: ctx.nowISO,\n      totalCommits: commits.length,\n      repository: {\n        head: await git.head(),\n        branch: await git.getCurrentBranch()\n      }\n    };\n    \n    // Render template to file\n    const outputPath = await template.renderToFile(\n      \"changelog.njk\",\n      \"dist/CHANGELOG.md\",\n      data\n    );\n    \n    ctx.logger.log(`üìù Changelog generated: ${outputPath}`);\n    ctx.logger.log(`üìä Processed ${commits.length} commits`);\n    \n    return {\n      ok: true,\n      artifacts: [outputPath],\n      data: {\n        outputPath,\n        totalCommits: commits.length,\n        groupedCommits: Object.keys(groupedCommits).reduce((acc, key) => {\n          acc[key] = groupedCommits[key].length;\n          return acc;\n        }, {})\n      }\n    };\n  }\n});\n```\n\n### **Step 2: Create Changelog Template**\n\n```njk\n<!-- templates/changelog.njk -->\n# {{ title }}\n\n{{ subtitle }}\n\nGenerated at: {{ generatedAt }}\nTotal commits: {{ totalCommits }}\n\n## Recent Changes\n\n{% if groupedCommits.breaking.length > 0 %}\n### üö® Breaking Changes\n{% for commit in groupedCommits.breaking %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.features.length > 0 %}\n### ‚ú® New Features\n{% for commit in groupedCommits.features %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.fixes.length > 0 %}\n### üêõ Bug Fixes\n{% for commit in groupedCommits.fixes %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.other.length > 0 %}\n### üìù Other Changes\n{% for commit in groupedCommits.other %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n## All Commits\n\n{% for commit in commits %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n\n---\n*Generated by GitVan Jobs System*\n```\n\n### **Step 3: Create Advanced Changelog Job**\n\n```javascript\n// jobs/docs/advanced-changelog.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Generate advanced changelog with release notes and statistics\",\n    tags: [\"documentation\", \"changelog\", \"advanced\", \"releases\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get configuration\n    const since = payload?.since || \"1 month ago\";\n    const limit = payload?.limit || 100;\n    const includeStats = payload?.includeStats !== false;\n    \n    // Get commits since specified date\n    const logOutput = await git.log(\n      \"%h%x09%s%x09%an%x09%ae%x09%ad%x09%at\",\n      [\"--since\", since, \"-n\", limit.toString()]\n    );\n    \n    const lines = logOutput.split(\"\\n\").filter(Boolean);\n    const commits = lines.map((line) => {\n      const [hash, subject, author, email, date, timestamp] = line.split(\"\\t\");\n      return {\n        hash,\n        subject,\n        author,\n        email,\n        date: new Date(date).toISOString(),\n        timestamp: parseInt(timestamp),\n        shortHash: hash.substring(0, 7)\n      };\n    });\n    \n    // Analyze commits\n    const analysis = {\n      totalCommits: commits.length,\n      uniqueAuthors: [...new Set(commits.map(c => c.author))].length,\n      dateRange: {\n        first: commits[commits.length - 1]?.date,\n        last: commits[0]?.date\n      },\n      commitTypes: {},\n      authorStats: {},\n      weeklyStats: {}\n    };\n    \n    // Analyze commit types\n    commits.forEach(commit => {\n      const type = commit.subject.split(':')[0].toLowerCase();\n      analysis.commitTypes[type] = (analysis.commitTypes[type] || 0) + 1;\n      \n      // Author statistics\n      analysis.authorStats[commit.author] = (analysis.authorStats[commit.author] || 0) + 1;\n      \n      // Weekly statistics\n      const week = new Date(commit.timestamp * 1000);\n      const weekKey = `${week.getFullYear()}-W${Math.ceil(week.getDate() / 7)}`;\n      analysis.weeklyStats[weekKey] = (analysis.weeklyStats[weekKey] || 0) + 1;\n    });\n    \n    // Group commits by type\n    const groupedCommits = {\n      features: [],\n      fixes: [],\n      docs: [],\n      style: [],\n      refactor: [],\n      test: [],\n      chore: [],\n      breaking: [],\n      other: []\n    };\n    \n    commits.forEach(commit => {\n      const subject = commit.subject.toLowerCase();\n      const type = subject.split(':')[0];\n      \n      if (subject.includes('breaking change') || subject.includes('!:')) {\n        groupedCommits.breaking.push(commit);\n      } else if (type === 'feat') {\n        groupedCommits.features.push(commit);\n      } else if (type === 'fix') {\n        groupedCommits.fixes.push(commit);\n      } else if (type === 'docs') {\n        groupedCommits.docs.push(commit);\n      } else if (type === 'style') {\n        groupedCommits.style.push(commit);\n      } else if (type === 'refactor') {\n        groupedCommits.refactor.push(commit);\n      } else if (type === 'test') {\n        groupedCommits.test.push(commit);\n      } else if (type === 'chore') {\n        groupedCommits.chore.push(commit);\n      } else {\n        groupedCommits.other.push(commit);\n      }\n    });\n    \n    // Get repository information\n    const repository = {\n      head: await git.head(),\n      branch: await git.getCurrentBranch(),\n      isClean: await git.isClean()\n    };\n    \n    // Prepare template data\n    const data = {\n      title: \"Advanced Changelog\",\n      subtitle: `Generated from ${commits.length} commits since ${since}`,\n      commits,\n      groupedCommits,\n      analysis: includeStats ? analysis : null,\n      generatedAt: ctx.nowISO,\n      repository,\n      config: {\n        since,\n        limit,\n        includeStats\n      }\n    };\n    \n    // Render template to file\n    const outputPath = await template.renderToFile(\n      \"advanced-changelog.njk\",\n      \"dist/ADVANCED_CHANGELOG.md\",\n      data\n    );\n    \n    ctx.logger.log(`üìù Advanced changelog generated: ${outputPath}`);\n    ctx.logger.log(`üìä Processed ${commits.length} commits from ${analysis.uniqueAuthors} authors`);\n    \n    return {\n      ok: true,\n      artifacts: [outputPath],\n      data: {\n        outputPath,\n        analysis,\n        groupedCommits: Object.keys(groupedCommits).reduce((acc, key) => {\n          acc[key] = groupedCommits[key].length;\n          return acc;\n        }, {})\n      }\n    };\n  }\n});\n```\n\n### **Step 4: Create Advanced Changelog Template**\n\n```njk\n<!-- templates/advanced-changelog.njk -->\n# {{ title }}\n\n{{ subtitle }}\n\nGenerated at: {{ generatedAt }}\nRepository: {{ repository.branch }} ({{ repository.head.substring(0, 8) }})\n\n{% if analysis %}\n## üìä Statistics\n\n- **Total Commits**: {{ analysis.totalCommits }}\n- **Unique Authors**: {{ analysis.uniqueAuthors }}\n- **Date Range**: {{ analysis.dateRange.first | date(\"MMM DD, YYYY\") }} - {{ analysis.dateRange.last | date(\"MMM DD, YYYY\") }}\n\n### Commit Types\n{% for type, count in analysis.commitTypes %}\n- **{{ type | titleize }}**: {{ count }}\n{% endfor %}\n\n### Top Contributors\n{% for author, count in analysis.authorStats | dictsort(true, 'value') | slice(0, 5) %}\n- **{{ author }}**: {{ count }} commits\n{% endfor %}\n\n### Weekly Activity\n{% for week, count in analysis.weeklyStats | dictsort(true, 'value') | slice(0, 8) %}\n- **{{ week }}**: {{ count }} commits\n{% endfor %}\n{% endif %}\n\n## üìù Changes by Category\n\n{% if groupedCommits.breaking.length > 0 %}\n### üö® Breaking Changes\n{% for commit in groupedCommits.breaking %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.features.length > 0 %}\n### ‚ú® New Features\n{% for commit in groupedCommits.features %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.fixes.length > 0 %}\n### üêõ Bug Fixes\n{% for commit in groupedCommits.fixes %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.docs.length > 0 %}\n### üìö Documentation\n{% for commit in groupedCommits.docs %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.refactor.length > 0 %}\n### üîß Refactoring\n{% for commit in groupedCommits.refactor %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.test.length > 0 %}\n### üß™ Tests\n{% for commit in groupedCommits.test %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.chore.length > 0 %}\n### üî® Chores\n{% for commit in groupedCommits.chore %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n{% if groupedCommits.other.length > 0 %}\n### üìù Other Changes\n{% for commit in groupedCommits.other %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n{% endif %}\n\n## üìã All Commits\n\n{% for commit in commits %}\n- **{{ commit.shortHash }}** {{ commit.subject }}\n  - *{{ commit.author }} - {{ commit.date | date(\"MMM DD, YYYY\") }}*\n{% endfor %}\n\n---\n*Generated by GitVan Jobs System*\n```\n\n## üîç **Explanation**\n\n### **Commit Parsing**\n\n1. **Git Log Format**: Uses custom format string to extract commit data\n2. **Commit Types**: Categorizes commits based on conventional commit format\n3. **Author Analysis**: Tracks commit statistics per author\n4. **Date Filtering**: Filters commits by date range\n\n### **Template Features**\n\n1. **Grouped Display**: Shows commits organized by type\n2. **Statistics**: Includes commit statistics and analysis\n3. **Flexible Formatting**: Supports different output formats\n4. **Metadata**: Includes generation timestamp and repository info\n\n### **Conventional Commits**\n\n- **`feat:`**: New features\n- **`fix:`**: Bug fixes\n- **`docs:`**: Documentation changes\n- **`style:`**: Code style changes\n- **`refactor:`**: Code refactoring\n- **`test:`**: Test changes\n- **`chore:`**: Maintenance tasks\n\n## üîÑ **Variations**\n\n### **Variation 1: Release-Based Changelog**\n\n```javascript\n// jobs/docs/release-changelog.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Generate changelog for a specific release\",\n    tags: [\"documentation\", \"changelog\", \"release\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    const fromTag = payload?.fromTag || \"HEAD~10\";\n    const toTag = payload?.toTag || \"HEAD\";\n    \n    // Get commits between tags\n    const logOutput = await git.log(\n      \"%h%x09%s%x09%an%x09%ad\",\n      [`${fromTag}..${toTag}`]\n    );\n    \n    // Process commits and generate changelog\n    // ... (similar to basic changelog)\n    \n    return {\n      ok: true,\n      artifacts: [outputPath],\n      data: { fromTag, toTag, commitCount: commits.length }\n    };\n  }\n});\n```\n\n### **Variation 2: Multi-Format Changelog**\n\n```javascript\n// jobs/docs/multi-format-changelog.mjs\nimport { defineJob } from \"gitvan/define\";\nimport { useGit } from \"gitvan/useGit\";\nimport { useTemplate } from \"gitvan/useTemplate\";\n\nexport default defineJob({\n  meta: {\n    desc: \"Generate changelog in multiple formats\",\n    tags: [\"documentation\", \"changelog\", \"multi-format\"]\n  },\n  async run({ ctx, payload }) {\n    const git = useGit();\n    const template = await useTemplate();\n    \n    // Get commits (same as basic changelog)\n    const commits = await getCommits(git, payload);\n    \n    const formats = payload?.formats || ['markdown', 'html', 'json'];\n    const artifacts = [];\n    \n    // Generate Markdown\n    if (formats.includes('markdown')) {\n      const mdPath = await template.renderToFile(\n        \"changelog.njk\",\n        \"dist/CHANGELOG.md\",\n        { commits, format: 'markdown' }\n      );\n      artifacts.push(mdPath);\n    }\n    \n    // Generate HTML\n    if (formats.includes('html')) {\n      const htmlPath = await template.renderToFile(\n        \"changelog-html.njk\",\n        \"dist/CHANGELOG.html\",\n        { commits, format: 'html' }\n      );\n      artifacts.push(htmlPath);\n    }\n    \n    // Generate JSON\n    if (formats.includes('json')) {\n      const jsonPath = join(ctx.root, \"dist\", \"CHANGELOG.json\");\n      await fs.writeFile(jsonPath, JSON.stringify({ commits }, null, 2));\n      artifacts.push(jsonPath);\n    }\n    \n    return {\n      ok: true,\n      artifacts,\n      data: { formats, artifactCount: artifacts.length }\n    };\n  }\n});\n```\n\n## üéØ **Best Practices**\n\n### **Commit Messages**\n- **Conventional Commits**: Use conventional commit format\n- **Clear Descriptions**: Write clear, descriptive commit messages\n- **Breaking Changes**: Mark breaking changes appropriately\n- **Consistent Format**: Maintain consistent commit message format\n\n### **Changelog Generation**\n- **Regular Updates**: Generate changelogs regularly\n- **Automated Process**: Integrate with CI/CD pipeline\n- **Version Control**: Keep generated changelogs in version control\n- **Review Process**: Review generated changelogs before release\n\n### **Template Design**\n- **Consistent Format**: Use consistent formatting across templates\n- **Flexible Structure**: Design templates to handle various commit types\n- **Metadata Inclusion**: Include relevant metadata in changelogs\n- **Readable Format**: Ensure changelogs are easy to read and understand\n\n## üîó **Related Recipes**\n\n- [Release Notes](./release-notes.md) - Generate release notes\n- [API Documentation](./api-documentation.md) - Generate API documentation\n- [README Updates](./readme-updates.md) - Keep README files current\n\n## üìö **Resources**\n\n- [Conventional Commits](https://www.conventionalcommits.org/)\n- [GitVan Template Guide](../../docs/templates.md)\n- [Changelog Best Practices](../../docs/changelog-best-practices.md)\n\n## ü§ù **Contributors**\n\n- **Author**: GitVan Team\n- **Last Updated**: 2024-09-16\n- **Version**: 1.0.0\n\n---\n\n**Next Recipe**: [API Documentation](./api-documentation.md)\n"
        }
    ]
}