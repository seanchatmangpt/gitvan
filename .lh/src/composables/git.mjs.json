{
    "sourceFile": "src/composables/git.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1758047531803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758047917561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,27 +14,32 @@\n const execFileAsync = promisify(execFile);\n \n async function runGit(args, { cwd, env, maxBuffer = 12 * 1024 * 1024 } = {}) {\n   try {\n-    const { stdout } = await execFileAsync(\"git\", args, { cwd, env, maxBuffer });\n+    const { stdout } = await execFileAsync(\"git\", args, {\n+      cwd,\n+      env,\n+      maxBuffer,\n+    });\n     return stdout.trim();\n   } catch (error) {\n     // Handle specific cases for empty repositories\n     const command = `git ${args.join(\" \")}`;\n     const errorMsg = error.message || \"\";\n     const stderr = error.stderr || \"\";\n     const fullError = `${errorMsg} ${stderr}`;\n-    \n+\n     // Handle empty repository cases for rev-list commands\n-    if (args[0] === \"rev-list\" && (\n-      fullError.includes(\"ambiguous argument\") ||\n-      fullError.includes(\"unknown revision\") ||\n-      fullError.includes(\"not in the working tree\") ||\n-      fullError.includes(\"fatal: ambiguous argument\")\n-    )) {\n+    if (\n+      args[0] === \"rev-list\" &&\n+      (fullError.includes(\"ambiguous argument\") ||\n+        fullError.includes(\"unknown revision\") ||\n+        fullError.includes(\"not in the working tree\") ||\n+        fullError.includes(\"fatal: ambiguous argument\"))\n+    ) {\n       return \"\"; // Return empty string for empty repo\n     }\n-    \n+\n     // Re-throw with more context for other errors\n     const newError = new Error(`Command failed: ${command}\\n${error.message}`);\n     newError.originalError = error;\n     newError.command = command;\n"
                },
                {
                    "date": 1758048492172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,264 @@\n+// src/composables/git.mjs\n+// GitVan v2 â€” useGit()\n+// - POSIX-first. No external deps. ESM.\n+// - Deterministic env: TZ=UTC, LANG=C.\n+// - UnJS context-aware (unctx). Captures context once to avoid loss after await.\n+// - Happy path only. No retries. No shell string interpolation.\n+// - 80/20 commands + a few primitives used by locks/receipts.\n+\n+import { execFile } from \"node:child_process\";\n+import { promisify } from \"node:util\";\n+import path from \"node:path\";\n+import { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n+\n+const execFileAsync = promisify(execFile);\n+\n+async function runGit(args, { cwd, env, maxBuffer = 12 * 1024 * 1024 } = {}) {\n+  try {\n+    const { stdout } = await execFileAsync(\"git\", args, {\n+      cwd,\n+      env,\n+      maxBuffer,\n+    });\n+    return stdout.trim();\n+  } catch (error) {\n+    // Handle specific cases for empty repositories\n+    const command = `git ${args.join(\" \")}`;\n+    const errorMsg = error.message || \"\";\n+    const stderr = error.stderr || \"\";\n+    const fullError = `${errorMsg} ${stderr}`;\n+\n+    // Handle empty repository cases for rev-list commands\n+    if (\n+      args[0] === \"rev-list\" &&\n+      (fullError.includes(\"ambiguous argument\") ||\n+        fullError.includes(\"unknown revision\") ||\n+        fullError.includes(\"not in the working tree\") ||\n+        fullError.includes(\"fatal: ambiguous argument\"))\n+    ) {\n+      return \"\"; // Return empty string for empty repo\n+    }\n+\n+    // Re-throw with more context for other errors\n+    const newError = new Error(`Command failed: ${command}\\n${error.message}`);\n+    newError.originalError = error;\n+    newError.command = command;\n+    newError.args = args;\n+    newError.stderr = error.stderr;\n+    throw newError;\n+  }\n+}\n+\n+async function runGitVoid(args, opts) {\n+  await runGit(args, opts);\n+}\n+\n+function toArr(x) {\n+  return Array.isArray(x) ? x : [x];\n+}\n+\n+export function useGit() {\n+  // Get context from unctx - this must be called synchronously\n+  let ctx;\n+  try {\n+    ctx = useGitVan();\n+  } catch {\n+    ctx = tryUseGitVan?.() || null;\n+  }\n+\n+  // Resolve working directory\n+  const cwd = (ctx && ctx.cwd) || process.cwd();\n+\n+  // Set up deterministic environment with UTC timezone and C locale\n+  // Context env should not override TZ and LANG for determinism\n+  const env = {\n+    ...process.env,\n+    ...(ctx && ctx.env ? ctx.env : {}),\n+    TZ: \"UTC\", // Always override to UTC for determinism\n+    LANG: \"C\", // Always override to C locale for determinism\n+  };\n+\n+  const base = { cwd, env };\n+\n+  return {\n+    // Context properties (exposed for testing)\n+    cwd: base.cwd,\n+    env: base.env,\n+    // ---------- Repo info ----------\n+    async branch() {\n+      return runGit([\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], base);\n+    },\n+    async head() {\n+      return runGit([\"rev-parse\", \"HEAD\"], base);\n+    },\n+    async repoRoot() {\n+      return runGit([\"rev-parse\", \"--show-toplevel\"], base);\n+    },\n+    async worktreeGitDir() {\n+      return runGit([\"rev-parse\", \"--git-dir\"], base);\n+    },\n+    nowISO() {\n+      // Use context-provided time if available, otherwise fall back to env or current time\n+      if (ctx && typeof ctx.now === \"function\") {\n+        return ctx.now();\n+      }\n+      const forced = process.env.GITVAN_NOW;\n+      return forced || new Date().toISOString();\n+    },\n+\n+    // ---------- Read-only helpers ----------\n+    async log(format = \"%h%x09%s\", extra = []) {\n+      const extraArgs =\n+        typeof extra === \"string\"\n+          ? extra.split(/\\s+/).filter(Boolean)\n+          : toArr(extra);\n+      return runGit([\"log\", `--pretty=${format}`, ...extraArgs], base);\n+    },\n+    async statusPorcelain() {\n+      return runGit([\"status\", \"--porcelain\"], base);\n+    },\n+    async isAncestor(a, b = \"HEAD\") {\n+      try {\n+        await runGitVoid([\"merge-base\", \"--is-ancestor\", a, b], base);\n+        return true;\n+      } catch {\n+        return false;\n+      }\n+    },\n+    async mergeBase(a, b) {\n+      return runGit([\"merge-base\", a, b], base);\n+    },\n+    async revList(args = [\"--max-count=50\", \"HEAD\"]) {\n+      const argArray = toArr(args);\n+      // Ensure we always have a commit reference\n+      if (argArray.length === 1 && argArray[0].startsWith(\"--\")) {\n+        argArray.push(\"HEAD\");\n+      }\n+      return runGit([\"rev-list\", ...argArray], base);\n+    },\n+\n+    // ---------- Write helpers (happy path) ----------\n+    async add(paths) {\n+      const list = toArr(paths).filter(Boolean);\n+      if (list.length === 0) return;\n+      await runGitVoid([\"add\", \"--\", ...list], base);\n+    },\n+    async commit(message, opts = {}) {\n+      const args = [\"commit\", \"-m\", message];\n+      if (opts.sign) args.push(\"-S\");\n+      await runGitVoid(args, base);\n+    },\n+    async tag(name, msg, opts = {}) {\n+      const args = [\"tag\"];\n+      if (opts.sign) args.push(\"-s\");\n+      if (msg) args.push(\"-m\", msg);\n+      args.push(name);\n+      await runGitVoid(args, base);\n+    },\n+\n+    // ---------- Notes (receipts) ----------\n+    async noteAdd(ref, message, sha = \"HEAD\") {\n+      // git will create the notes ref if needed\n+      await runGitVoid(\n+        [\"notes\", `--ref=${ref}`, \"add\", \"-f\", \"-m\", message, sha],\n+        base,\n+      );\n+    },\n+    async noteAppend(ref, message, sha = \"HEAD\") {\n+      await runGitVoid(\n+        [\"notes\", `--ref=${ref}`, \"append\", \"-m\", message, sha],\n+        base,\n+      );\n+    },\n+    async noteShow(ref, sha = \"HEAD\") {\n+      return runGit([\"notes\", `--ref=${ref}`, \"show\", sha], base);\n+    },\n+\n+    // ---------- Atomic ref create (locks) ----------\n+    // Uses stdin protocol to atomically create a ref if absent.\n+    async updateRefCreate(ref, valueSha) {\n+      // Check if ref exists first\n+      try {\n+        await runGitVoid([\"show-ref\", \"--verify\", \"--quiet\", ref], base);\n+        // Ref exists, return false to indicate failure\n+        return false;\n+      } catch {\n+        // Ref doesn't exist, try to create it\n+        try {\n+          await runGitVoid([\"update-ref\", ref, valueSha], base);\n+          return true;\n+        } catch (error) {\n+          // If creation failed due to race condition, check if it exists now\n+          try {\n+            await runGitVoid([\"show-ref\", \"--verify\", \"--quiet\", ref], base);\n+            return false; // Someone else created it\n+          } catch {\n+            throw error; // Real error, re-throw\n+          }\n+        }\n+      }\n+    },\n+\n+    // ---------- Plumbing ----------\n+    async hashObject(filePath, { write = false } = {}) {\n+      const abs = path.isAbsolute(filePath)\n+        ? filePath\n+        : path.join(base.cwd, filePath);\n+      const args = [\"hash-object\"];\n+      if (write) args.push(\"-w\");\n+      args.push(\"--\", abs);\n+      return runGit(args, base);\n+    },\n+    async writeTree() {\n+      return runGit([\"write-tree\"], base);\n+    },\n+    async catFilePretty(sha) {\n+      try {\n+        return runGit([\"cat-file\", \"-p\", sha], base);\n+      } catch (error) {\n+        // Handle common error cases gracefully\n+        if (error.message.includes(\"Not a valid object name\")) {\n+          throw new Error(`Object ${sha} not found`);\n+        }\n+        throw error;\n+      }\n+    },\n+\n+    // ---------- Utility methods ----------\n+    async isClean() {\n+      const status = await this.statusPorcelain();\n+      return status.trim() === \"\";\n+    },\n+    async hasUncommittedChanges() {\n+      const status = await this.statusPorcelain();\n+      return status.trim() !== \"\";\n+    },\n+    async getCurrentBranch() {\n+      try {\n+        return await this.branch();\n+      } catch (error) {\n+        // Handle detached HEAD state\n+        if (error.message.includes(\"detached HEAD\")) {\n+          return \"HEAD\";\n+        }\n+        throw error;\n+      }\n+    },\n+    async getCommitCount(branch = \"HEAD\") {\n+      try {\n+        const result = await runGit([\"rev-list\", \"--count\", branch], base);\n+        return parseInt(result, 10) || 0;\n+      } catch {\n+        return 0;\n+      }\n+    },\n+\n+    // ---------- Generic runner (escape hatch) ----------\n+    async run(args) {\n+      return runGit(toArr(args), base);\n+    },\n+    async runVoid(args) {\n+      await runGitVoid(toArr(args), base);\n+    },\n+  };\n+}\n"
                }
            ],
            "date": 1758047531803,
            "name": "Commit-0",
            "content": "// src/composables/git.mjs\n// GitVan v2 â€” useGit()\n// - POSIX-first. No external deps. ESM.\n// - Deterministic env: TZ=UTC, LANG=C.\n// - UnJS context-aware (unctx). Captures context once to avoid loss after await.\n// - Happy path only. No retries. No shell string interpolation.\n// - 80/20 commands + a few primitives used by locks/receipts.\n\nimport { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\nimport path from \"node:path\";\nimport { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n\nconst execFileAsync = promisify(execFile);\n\nasync function runGit(args, { cwd, env, maxBuffer = 12 * 1024 * 1024 } = {}) {\n  const { stdout } = await execFileAsync(\"git\", args, { cwd, env, maxBuffer });\n  return stdout.trim();\n}\n\nasync function runGitVoid(args, opts) {\n  await runGit(args, opts);\n}\n\nfunction toArr(x) {\n  return Array.isArray(x) ? x : [x];\n}\n\nexport function useGit() {\n  // Get context from unctx - this must be called synchronously\n  let ctx;\n  try {\n    ctx = useGitVan();\n  } catch {\n    ctx = tryUseGitVan?.() || null;\n  }\n\n  // Resolve working directory\n  const cwd = (ctx && ctx.cwd) || process.cwd();\n\n  // Set up deterministic environment with UTC timezone and C locale\n  const env = {\n    ...process.env,\n    TZ: \"UTC\",\n    LANG: \"C\",\n    ...(ctx && ctx.env ? ctx.env : {}),\n  };\n\n  const base = { cwd, env };\n\n  return {\n    // Context properties (exposed for testing)\n    cwd: base.cwd,\n    env: base.env,\n    // ---------- Repo info ----------\n    async branch() {\n      return runGit([\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], base);\n    },\n    async head() {\n      return runGit([\"rev-parse\", \"HEAD\"], base);\n    },\n    async repoRoot() {\n      return runGit([\"rev-parse\", \"--show-toplevel\"], base);\n    },\n    async worktreeGitDir() {\n      return runGit([\"rev-parse\", \"--git-dir\"], base);\n    },\n    nowISO() {\n      // Use context-provided time if available, otherwise fall back to env or current time\n      if (ctx && typeof ctx.now === \"function\") {\n        return ctx.now();\n      }\n      const forced = process.env.GITVAN_NOW;\n      return forced || new Date().toISOString();\n    },\n\n    // ---------- Read-only helpers ----------\n    async log(format = \"%h%x09%s\", extra = []) {\n      const extraArgs =\n        typeof extra === \"string\"\n          ? extra.split(/\\s+/).filter(Boolean)\n          : toArr(extra);\n      return runGit([\"log\", `--pretty=${format}`, ...extraArgs], base);\n    },\n    async statusPorcelain() {\n      return runGit([\"status\", \"--porcelain\"], base);\n    },\n    async isAncestor(a, b = \"HEAD\") {\n      try {\n        await runGitVoid([\"merge-base\", \"--is-ancestor\", a, b], base);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    async mergeBase(a, b) {\n      return runGit([\"merge-base\", a, b], base);\n    },\n    async revList(args = [\"--max-count=50\", \"HEAD\"]) {\n      const argArray = toArr(args);\n      // Ensure we always have a commit reference\n      if (argArray.length === 1 && argArray[0].startsWith(\"--\")) {\n        argArray.push(\"HEAD\");\n      }\n      // Handle empty repository case\n      try {\n        return runGit([\"rev-list\", ...argArray], base);\n      } catch (error) {\n        // If HEAD doesn't exist (empty repo), return empty string\n        if (\n          error.message.includes(\"ambiguous argument\") ||\n          error.message.includes(\"unknown revision\")\n        ) {\n          return \"\";\n        }\n        throw error;\n      }\n    },\n\n    // ---------- Write helpers (happy path) ----------\n    async add(paths) {\n      const list = toArr(paths).filter(Boolean);\n      if (list.length === 0) return;\n      await runGitVoid([\"add\", \"--\", ...list], base);\n    },\n    async commit(message, opts = {}) {\n      const args = [\"commit\", \"-m\", message];\n      if (opts.sign) args.push(\"-S\");\n      await runGitVoid(args, base);\n    },\n    async tag(name, msg, opts = {}) {\n      const args = [\"tag\"];\n      if (opts.sign) args.push(\"-s\");\n      if (msg) args.push(\"-m\", msg);\n      args.push(name);\n      await runGitVoid(args, base);\n    },\n\n    // ---------- Notes (receipts) ----------\n    async noteAdd(ref, message, sha = \"HEAD\") {\n      // git will create the notes ref if needed\n      await runGitVoid(\n        [\"notes\", `--ref=${ref}`, \"add\", \"-m\", message, sha],\n        base,\n      );\n    },\n    async noteAppend(ref, message, sha = \"HEAD\") {\n      await runGitVoid(\n        [\"notes\", `--ref=${ref}`, \"append\", \"-m\", message, sha],\n        base,\n      );\n    },\n    async noteShow(ref, sha = \"HEAD\") {\n      return runGit([\"notes\", `--ref=${ref}`, \"show\", sha], base);\n    },\n\n    // ---------- Atomic ref create (locks) ----------\n    // Uses stdin protocol to atomically create a ref if absent.\n    async updateRefCreate(ref, valueSha) {\n      // Check if ref exists first\n      try {\n        await runGitVoid([\"show-ref\", \"--verify\", \"--quiet\", ref], base);\n        // Ref exists, return false to indicate failure\n        return false;\n      } catch {\n        // Ref doesn't exist, try to create it\n        try {\n          await runGitVoid([\"update-ref\", ref, valueSha], base);\n          return true;\n        } catch (error) {\n          // If creation failed due to race condition, check if it exists now\n          try {\n            await runGitVoid([\"show-ref\", \"--verify\", \"--quiet\", ref], base);\n            return false; // Someone else created it\n          } catch {\n            throw error; // Real error, re-throw\n          }\n        }\n      }\n    },\n\n    // ---------- Plumbing ----------\n    async hashObject(filePath, { write = false } = {}) {\n      const abs = path.isAbsolute(filePath)\n        ? filePath\n        : path.join(base.cwd, filePath);\n      const args = [\"hash-object\"];\n      if (write) args.push(\"-w\");\n      args.push(\"--\", abs);\n      return runGit(args, base);\n    },\n    async writeTree() {\n      return runGit([\"write-tree\"], base);\n    },\n    async catFilePretty(sha) {\n      try {\n        return runGit([\"cat-file\", \"-p\", sha], base);\n      } catch (error) {\n        // Handle common error cases gracefully\n        if (error.message.includes(\"Not a valid object name\")) {\n          throw new Error(`Object ${sha} not found`);\n        }\n        throw error;\n      }\n    },\n\n    // ---------- Utility methods ----------\n    async isClean() {\n      const status = await this.statusPorcelain();\n      return status.trim() === \"\";\n    },\n    async hasUncommittedChanges() {\n      const status = await this.statusPorcelain();\n      return status.trim() !== \"\";\n    },\n    async getCurrentBranch() {\n      try {\n        return await this.branch();\n      } catch (error) {\n        // Handle detached HEAD state\n        if (error.message.includes(\"detached HEAD\")) {\n          return \"HEAD\";\n        }\n        throw error;\n      }\n    },\n    async getCommitCount(branch = \"HEAD\") {\n      try {\n        const result = await runGit([\"rev-list\", \"--count\", branch], base);\n        return parseInt(result, 10) || 0;\n      } catch {\n        return 0;\n      }\n    },\n\n    // ---------- Generic runner (escape hatch) ----------\n    async run(args) {\n      return runGit(toArr(args), base);\n    },\n    async runVoid(args) {\n      await runGitVoid(toArr(args), base);\n    },\n  };\n}\n"
        }
    ]
}