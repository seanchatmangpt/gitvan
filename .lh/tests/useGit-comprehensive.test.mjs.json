{
    "sourceFile": "tests/useGit-comprehensive.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758047917559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758047917559,
            "name": "Commit-0",
            "content": "// tests/useGit-comprehensive.test.mjs\n// GitVan v2 â€” Comprehensive useGit() Tests\n// Tests all functionality with proper context integration\n\nimport { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { useGit } from \"../src/composables/git.mjs\";\nimport { withGitVan } from \"../src/composables/ctx.mjs\";\n\ndescribe(\"useGit Comprehensive Tests\", () => {\n  let tempDir;\n  let git;\n\n  beforeEach(async () => {\n    // Create temporary directory for testing\n    tempDir = join(process.cwd(), \"test-git-temp\");\n    await fs.mkdir(tempDir, { recursive: true });\n  });\n\n  afterEach(async () => {\n    // Clean up temporary directory\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  });\n\n  describe(\"basic functionality\", () => {\n    it(\"should create useGit instance without context\", () => {\n      git = useGit();\n\n      expect(git).toBeDefined();\n      expect(git.cwd).toBe(process.cwd());\n      expect(git.env.TZ).toBe(\"UTC\");\n      expect(git.env.LANG).toBe(\"C\");\n      expect(typeof git.nowISO).toBe(\"function\");\n    });\n\n    it(\"should work with context\", async () => {\n      const mockContext = {\n        cwd: tempDir,\n        env: {\n          CUSTOM_VAR: \"test-value\",\n          TZ: \"America/New_York\", // Should be overridden\n        },\n        now: () => \"2024-01-01T12:00:00.000Z\",\n      };\n\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        expect(git.cwd).toBe(tempDir);\n        expect(git.env.TZ).toBe(\"UTC\"); // Should override context\n        expect(git.env.LANG).toBe(\"C\");\n        expect(git.env.CUSTOM_VAR).toBe(\"test-value\");\n        expect(git.nowISO()).toBe(\"2024-01-01T12:00:00.000Z\");\n      });\n    });\n  });\n\n  describe(\"repository operations\", () => {\n    beforeEach(async () => {\n      // Initialize git repository\n      await fs.writeFile(join(tempDir, \"README.md\"), \"# Test Repository\\n\");\n\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n      });\n    });\n\n    it(\"should get repository information\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        const branch = await git.branch();\n        const head = await git.head();\n        const repoRoot = await git.repoRoot();\n        const gitDir = await git.worktreeGitDir();\n\n        expect(branch).toBe(\"master\"); // Default branch\n        expect(head).toMatch(/^[a-f0-9]{40}$/); // SHA hash\n        expect(repoRoot).toBe(tempDir);\n        expect(gitDir).toContain(\".git\");\n      });\n    });\n\n    it(\"should handle status operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Check clean status\n        const isClean = await git.isClean();\n        expect(isClean).toBe(true);\n\n        const hasChanges = await git.hasUncommittedChanges();\n        expect(hasChanges).toBe(false);\n\n        // Add a new file\n        await fs.writeFile(join(tempDir, \"new-file.txt\"), \"content\");\n\n        const status = await git.statusPorcelain();\n        expect(status).toContain(\"new-file.txt\");\n\n        const isCleanAfter = await git.isClean();\n        expect(isCleanAfter).toBe(false);\n      });\n    });\n\n    it(\"should handle log operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Add another commit\n        await fs.writeFile(join(tempDir, \"file2.txt\"), \"content\");\n        await git.add(\"file2.txt\");\n        await git.commit(\"Second commit\");\n\n        const log = await git.log();\n        expect(log).toContain(\"Second commit\");\n        expect(log).toContain(\"Initial commit\");\n\n        const commitCount = await git.getCommitCount();\n        expect(commitCount).toBe(2);\n      });\n    });\n\n    it(\"should handle branch operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        const currentBranch = await git.getCurrentBranch();\n        expect(currentBranch).toBe(\"master\");\n\n        // Create and switch to new branch\n        await git.runVoid([\"checkout\", \"-b\", \"feature-branch\"]);\n\n        const newBranch = await git.getCurrentBranch();\n        expect(newBranch).toBe(\"feature-branch\");\n      });\n    });\n  });\n\n  describe(\"write operations\", () => {\n    beforeEach(async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n      });\n    });\n\n    it(\"should handle add and commit operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Create and add files\n        await fs.writeFile(join(tempDir, \"file1.txt\"), \"content1\");\n        await fs.writeFile(join(tempDir, \"file2.txt\"), \"content2\");\n\n        await git.add([\"file1.txt\", \"file2.txt\"]);\n\n        const status = await git.statusPorcelain();\n        expect(status).toContain(\"file1.txt\");\n        expect(status).toContain(\"file2.txt\");\n\n        await git.commit(\"Add files\");\n\n        const isClean = await git.isClean();\n        expect(isClean).toBe(true);\n      });\n    });\n\n    it(\"should handle tag operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n\n        // Create tag\n        await git.tag(\"v1.0.0\", \"Version 1.0.0\");\n\n        // Verify tag exists\n        const tags = await git.run([\"tag\", \"-l\"]);\n        expect(tags).toContain(\"v1.0.0\");\n      });\n    });\n  });\n\n  describe(\"notes operations\", () => {\n    beforeEach(async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n      });\n    });\n\n    it(\"should handle notes operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        const notesRef = \"refs/notes/gitvan/test\";\n\n        // Add note\n        await git.noteAdd(notesRef, \"Test note\");\n\n        // Show note\n        const note = await git.noteShow(notesRef);\n        expect(note).toBe(\"Test note\");\n\n        // Append to note\n        await git.noteAppend(notesRef, \"\\nAdditional info\");\n\n        const updatedNote = await git.noteShow(notesRef);\n        expect(updatedNote).toContain(\"Test note\");\n        expect(updatedNote).toContain(\"Additional info\");\n      });\n    });\n  });\n\n  describe(\"atomic operations\", () => {\n    beforeEach(async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n      });\n    });\n\n    it(\"should handle atomic ref creation\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        const head = await git.head();\n        const lockRef = \"refs/gitvan/locks/test-lock\";\n\n        // First creation should succeed\n        const result1 = await git.updateRefCreate(lockRef, head);\n        expect(result1).toBe(true);\n\n        // Second creation should fail (ref exists)\n        const result2 = await git.updateRefCreate(lockRef, head);\n        expect(result2).toBe(false);\n\n        // Clean up\n        await git.runVoid([\"update-ref\", \"-d\", lockRef]);\n      });\n    });\n  });\n\n  describe(\"plumbing operations\", () => {\n    beforeEach(async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n      });\n    });\n\n    it(\"should handle plumbing operations\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Test hash-object\n        const hash = await git.hashObject(\"README.md\");\n        expect(hash).toMatch(/^[a-f0-9]{40}$/);\n\n        // Test write-tree\n        const treeHash = await git.writeTree();\n        expect(treeHash).toMatch(/^[a-f0-9]{40}$/);\n\n        // Test cat-file\n        const head = await git.head();\n        const content = await git.catFilePretty(head);\n        expect(content).toContain(\"Initial commit\");\n      });\n    });\n  });\n\n  describe(\"error handling\", () => {\n    it(\"should handle empty repository gracefully\", async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize empty repo\n        await git.runVoid([\"init\"]);\n\n        // These should handle empty repo gracefully\n        const revList = await git.revList();\n        expect(revList).toBe(\"\");\n\n        const commitCount = await git.getCommitCount();\n        expect(commitCount).toBe(0);\n      });\n    });\n\n    it(\"should handle invalid operations gracefully\", async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n\n        // Test invalid object\n        await expect(git.catFilePretty(\"invalid-sha\")).rejects.toThrow();\n      });\n    });\n  });\n\n  describe(\"utility methods\", () => {\n    beforeEach(async () => {\n      const mockContext = { cwd: tempDir };\n      await withGitVan(mockContext, async () => {\n        git = useGit();\n\n        // Initialize git repo\n        await git.runVoid([\"init\"]);\n        await git.runVoid([\"config\", \"user.name\", \"Test User\"]);\n        await git.runVoid([\"config\", \"user.email\", \"test@example.com\"]);\n\n        // Create initial commit\n        await fs.writeFile(join(tempDir, \"README.md\"), \"# Test\");\n        await git.add(\"README.md\");\n        await git.commit(\"Initial commit\");\n      });\n    });\n\n    it(\"should provide utility methods\", async () => {\n      await withGitVan({ cwd: tempDir }, async () => {\n        git = useGit();\n\n        // Test isClean\n        expect(await git.isClean()).toBe(true);\n\n        // Test hasUncommittedChanges\n        expect(await git.hasUncommittedChanges()).toBe(false);\n\n        // Test getCurrentBranch\n        expect(await git.getCurrentBranch()).toBe(\"master\");\n\n        // Test getCommitCount\n        expect(await git.getCommitCount()).toBe(1);\n\n        // Add uncommitted changes\n        await fs.writeFile(join(tempDir, \"new-file.txt\"), \"content\");\n\n        expect(await git.isClean()).toBe(false);\n        expect(await git.hasUncommittedChanges()).toBe(true);\n      });\n    });\n  });\n});\n"
        }
    ]
}