{
    "sourceFile": "src/cli.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1758057329115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758072829955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n import { join, extname } from \"pathe\";\n import { GitVanDaemon, startDaemon } from \"./runtime/daemon.mjs\";\n import { discoverEvents, loadEventDefinition } from \"./runtime/events.mjs\";\n import { readReceiptsRange } from \"./runtime/receipt.mjs\";\n+import { discoverJobs, findJobFile, findAllJobs, loadJobDefinition } from \"./runtime/jobs.mjs\";\n import { useGit } from \"./composables/git.mjs\";\n import { runJobWithContext } from \"./runtime/boot.mjs\";\n import { loadConfig } from \"./runtime/config.mjs\";\n \n@@ -14,8 +15,13 @@\n import { daemonCommand } from \"./cli/daemon.mjs\";\n import { eventCommand } from \"./cli/event.mjs\";\n import { auditCommand } from \"./cli/audit.mjs\";\n import { chatCommand } from \"./cli/chat.mjs\";\n+import { packCommand } from \"./cli/pack.mjs\";\n+import { scaffoldCommand } from \"./cli/scaffold.mjs\";\n+import { marketplaceCommand } from \"./cli/marketplace.mjs\";\n+import { composeCommand } from \"./cli/compose.mjs\";\n+import { ensureCommand } from \"./cli/ensure.mjs\";\n \n const commands = {\n   daemon: handleDaemon,\n   run: handleRun,\n@@ -28,10 +34,15 @@\n \n   // New v2 commands\n   cron: cronCommand,\n   audit: auditCommand,\n-  chat: chatCommand,\n+  chat: handleChat,\n   llm: handleLLM,\n+  pack: handlePack,\n+  scaffold: handleScaffold,\n+  marketplace: handleMarketplace,\n+  compose: handleCompose,\n+  ensure: handleEnsure,\n };\n \n async function main() {\n   const [, , command, ...args] = process.argv;\n@@ -97,15 +108,95 @@\n   // Use new event command handler\n   return await eventCommand(action, parseArgs(args));\n }\n \n+async function handleChat(action = \"draft\", ...args) {\n+  // Use new chat command handler\n+  return await chatCommand(action, parseArgs(args));\n+}\n+\n+async function handlePack(action = \"list\", ...args) {\n+  // Use new pack command handler\n+  const parsedArgs = parseArgs(args);\n+  const commandArgs = {\n+    args: {\n+      [action]: true,\n+      ...parsedArgs\n+    }\n+  };\n+\n+  // Handle specific pack subcommands\n+  if (action === \"apply\" || action === \"plan\" || action === \"remove\" || action === \"update\") {\n+    commandArgs.args.pack = parsedArgs.arg0 || parsedArgs.pack;\n+  }\n+\n+  return await packCommand.subCommands[action]?.run(commandArgs) || packCommand.run(commandArgs);\n+}\n+\n+async function handleScaffold(scaffold, ...args) {\n+  // Use new scaffold command handler\n+  const parsedArgs = parseArgs(args);\n+  return await scaffoldCommand.run({ args: { scaffold, ...parsedArgs } });\n+}\n+\n+async function handleMarketplace(action = 'browse', ...args) {\n+  // Use new marketplace command handler\n+  const parsedArgs = parseArgs(args);\n+\n+  // For search command, the first non-flag argument is the query\n+  if (action === 'search' && args.length > 0 && !args[0].startsWith('--')) {\n+    parsedArgs.query = args[0];\n+  }\n+\n+  // For inspect command, the first non-flag argument is the pack\n+  if (action === 'inspect' && args.length > 0 && !args[0].startsWith('--')) {\n+    parsedArgs.pack = args[0];\n+  }\n+\n+  if (marketplaceCommand.subCommands[action]) {\n+    return await marketplaceCommand.subCommands[action].run({ args: parsedArgs });\n+  }\n+\n+  return await marketplaceCommand.run({ args: parsedArgs });\n+}\n+\n+async function handleCompose(...args) {\n+  // Use new compose command handler\n+  const parsedArgs = parseArgs(args);\n+  parsedArgs.packs = args.filter(arg => !arg.startsWith('--'));\n+  return await composeCommand.run({ args: parsedArgs });\n+}\n+\n+async function handleEnsure(...args) {\n+  // Use new ensure command handler\n+  const parsedArgs = parseArgs(args);\n+  return await ensureCommand.run({ args: parsedArgs });\n+}\n+\n function parseArgs(args) {\n   const parsed = {};\n-  for (let i = 0; i < args.length; i += 2) {\n-    const key = args[i]?.replace(/^--/, \"\");\n-    const value = args[i + 1];\n-    if (key) parsed[key] = value;\n+  let positionalIndex = 0;\n+\n+  for (let i = 0; i < args.length; i++) {\n+    const arg = args[i];\n+\n+    if (arg.startsWith(\"--\")) {\n+      // Named argument\n+      const key = arg.replace(/^--/, \"\");\n+      const value = args[i + 1];\n+      if (value && !value.startsWith(\"--\")) {\n+        parsed[key] = value;\n+        i++; // Skip the value\n+      } else {\n+        parsed[key] = true;\n+      }\n+    } else {\n+      // Positional argument\n+      parsed[`arg${positionalIndex}`] = arg;\n+      positionalIndex++;\n+    }\n   }\n+\n   return parsed;\n }\n \n async function handleSchedule(action = \"apply\") {\n@@ -160,23 +251,78 @@\n   }\n }\n \n async function handleJob(action = \"list\", ...args) {\n+  const worktreePath = process.cwd();\n+  const jobsDir = join(worktreePath, \"jobs\");\n+\n   switch (action) {\n     case \"list\":\n-      console.log(\"Job listing not yet implemented\");\n-      // TODO: Discover and list available jobs\n+      if (!statSync(jobsDir).isDirectory()) {\n+        console.log(\"No jobs directory found\");\n+        return;\n+      }\n+\n+      const jobs = discoverJobs(jobsDir);\n+      if (jobs.length === 0) {\n+        console.log(\"No jobs found\");\n+        return;\n+      }\n+\n+      console.log(\"Available jobs:\");\n+      console.log(\"==============\");\n+      jobs.forEach((job) => {\n+        console.log(`${job.id}`);\n+        console.log(`  File: ${job.relativePath}`);\n+        console.log(`  Directory: ${job.directory}`);\n+        console.log();\n+      });\n       break;\n+\n     case \"run\":\n       const nameIndex = args.indexOf(\"--name\");\n       if (nameIndex === -1 || !args[nameIndex + 1]) {\n         console.error(\"Job name required: gitvan job run --name <job-name>\");\n         process.exit(1);\n       }\n       const jobName = args[nameIndex + 1];\n-      console.log(`Running job: ${jobName}`);\n-      // TODO: Implement job execution\n+\n+      const jobPath = findJobFile(jobsDir, jobName);\n+      if (!jobPath) {\n+        console.error(`Job not found: ${jobName}`);\n+        process.exit(1);\n+      }\n+\n+      try {\n+        const jobDef = await loadJobDefinition(jobPath);\n+        if (!jobDef) {\n+          console.error(`Failed to load job: ${jobName}`);\n+          process.exit(1);\n+        }\n+\n+        const ctx = {\n+          root: worktreePath,\n+          env: process.env,\n+          now: () => new Date().toISOString(),\n+          nowISO: new Date().toISOString(),\n+          id: jobName,\n+          logger: {\n+            log: console.log,\n+            warn: console.warn,\n+            error: console.error,\n+            info: console.info\n+          }\n+        };\n+\n+        console.log(`Running job: ${jobName}`);\n+        const result = await runJobWithContext(ctx, jobDef);\n+        console.log(\"Result:\", JSON.stringify(result, null, 2));\n+      } catch (error) {\n+        console.error(`Error running job ${jobName}:`, error.message);\n+        process.exit(1);\n+      }\n       break;\n+\n     default:\n       console.error(`Unknown job action: ${action}`);\n       process.exit(1);\n   }\n@@ -196,18 +342,36 @@\n     console.error(`Job not found: ${jobName}`);\n     process.exit(1);\n   }\n \n-  const jobMod = await import(`file://${jobPath}`);\n-  const ctx = {\n-    root: worktreePath,\n-    env: process.env,\n-    now: () => new Date().toISOString(),\n-  };\n+  try {\n+    const jobDef = await loadJobDefinition(jobPath);\n+    if (!jobDef) {\n+      console.error(`Failed to load job: ${jobName}`);\n+      process.exit(1);\n+    }\n \n-  console.log(`Running job: ${jobName}`);\n-  const result = await runJobWithContext(ctx, jobMod);\n-  console.log(\"Result:\", JSON.stringify(result, null, 2));\n+    const ctx = {\n+      root: worktreePath,\n+      env: process.env,\n+      now: () => new Date().toISOString(),\n+      nowISO: new Date().toISOString(),\n+      id: jobName,\n+      logger: {\n+        log: console.log,\n+        warn: console.warn,\n+        error: console.error,\n+        info: console.info\n+      }\n+    };\n+\n+    console.log(`Running job: ${jobName}`);\n+    const result = await runJobWithContext(ctx, jobDef);\n+    console.log(\"Result:\", JSON.stringify(result, null, 2));\n+  } catch (error) {\n+    console.error(`Error running job ${jobName}:`, error.message);\n+    process.exit(1);\n+  }\n }\n \n function handleList() {\n   const worktreePath = process.cwd();\n@@ -280,8 +444,13 @@\n   gitvan cron [list|start|dry-run]                       Cron job management\n   gitvan audit [build|verify|list]                       Receipt audit\n   gitvan chat [draft|generate|explain]                    AI job generation\n   gitvan llm [call|models]                               AI operations\n+  gitvan pack [list|apply|plan|remove|update|status]     Pack management\n+  gitvan scaffold <pack:scaffold> [--inputs '{}']        Run pack scaffolds\n+  gitvan marketplace [browse|search|inspect|quickstart]  Marketplace commands\n+  gitvan compose <pack1> <pack2> [--inputs '{}']         Compose multiple packs\n+  gitvan ensure [--init-config] [--skip-git]             Ensure GitVan setup\n   gitvan schedule apply                                  Apply scheduled tasks\n   gitvan worktree list                                   List all worktrees\n   gitvan run <job-name>                                  Run a specific job (legacy)\n   gitvan list                                            List available jobs (legacy)\n@@ -293,61 +462,20 @@\n   gitvan event simulate --files \"src/**\"                Simulate file change event\n   gitvan chat generate \"Create a changelog job\"         Generate job via AI\n   gitvan llm call \"Summarize recent commits\"            Call AI directly\n   gitvan audit build --out audit.json                  Build audit pack\n+  gitvan pack apply my-pack --inputs '{\"name\":\"test\"}'  Apply a pack\n+  gitvan pack plan my-pack                             Show pack plan\n+  gitvan scaffold my-pack:component --inputs '{}'       Run scaffold\n+  gitvan marketplace browse --category docs            Browse marketplace\n+  gitvan marketplace search \"changelog\"                Search for packs\n+  gitvan marketplace quickstart docs                   Get docs quickstart\n+  gitvan compose my-pack1 my-pack2                     Compose multiple packs\n+  gitvan ensure --init-config                          Initialize GitVan config\n `);\n }\n \n-function findJobFile(jobsDir, jobName) {\n-  const possiblePaths = [\n-    join(jobsDir, `${jobName}.mjs`),\n-    join(jobsDir, `${jobName}.js`),\n-    join(jobsDir, jobName, \"index.mjs\"),\n-    join(jobsDir, jobName, \"index.js\"),\n-  ];\n-\n-  for (const path of possiblePaths) {\n-    try {\n-      if (statSync(path).isFile()) {\n-        return path;\n-      }\n-    } catch (err) {\n-      // File doesn't exist, continue\n-    }\n-  }\n-\n-  return null;\n-}\n-\n-function findAllJobs(dir, prefix = \"\") {\n-  const jobs = [];\n-\n-  try {\n-    const entries = readdirSync(dir);\n-\n-    for (const entry of entries) {\n-      const fullPath = join(dir, entry);\n-      const stat = statSync(fullPath);\n-\n-      if (stat.isDirectory()) {\n-        jobs.push(\n-          ...findAllJobs(fullPath, prefix ? `${prefix}/${entry}` : entry),\n-        );\n-      } else if (stat.isFile() && [\".mjs\", \".js\"].includes(extname(entry))) {\n-        const jobName = prefix\n-          ? `${prefix}/${entry.replace(/\\.(mjs|js)$/, \"\")}`\n-          : entry.replace(/\\.(mjs|js)$/, \"\");\n-        jobs.push(jobName);\n-      }\n-    }\n-  } catch (err) {\n-    // Directory doesn't exist or is not accessible\n-  }\n-\n-  return jobs;\n-}\n-\n export { main };\n \n if (import.meta.url === `file://${process.argv[1]}`) {\n   main();\n-}\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1758072969418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,8 +426,25 @@\n         console.log(`Message: ${availability.message}`);\n       }\n       break;\n \n+    case \"help\":\n+      console.log(\"GitVan LLM Commands:\");\n+      console.log();\n+      console.log(\"  call <prompt>              Generate text using AI\");\n+      console.log(\"  models                     Show available AI models\");\n+      console.log(\"  help                       Show this help\");\n+      console.log();\n+      console.log(\"Options:\");\n+      console.log(\"  --model <name>             AI model name (default: qwen3-coder:30b)\");\n+      console.log(\"  --temp <number>            Temperature 0.0-1.0 (default: 0.7)\");\n+      console.log();\n+      console.log(\"Examples:\");\n+      console.log(\"  gitvan llm call \\\"What is GitVan?\\\"\");\n+      console.log(\"  gitvan llm call \\\"Generate a JavaScript function\\\" --model qwen3-coder:30b\");\n+      console.log(\"  gitvan llm models\");\n+      break;\n+\n     default:\n       console.error(`Unknown llm subcommand: ${subcommand}`);\n       process.exit(1);\n   }\n"
                },
                {
                    "date": 1758073006508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,14 @@\n import { join, extname } from \"pathe\";\n import { GitVanDaemon, startDaemon } from \"./runtime/daemon.mjs\";\n import { discoverEvents, loadEventDefinition } from \"./runtime/events.mjs\";\n import { readReceiptsRange } from \"./runtime/receipt.mjs\";\n-import { discoverJobs, findJobFile, findAllJobs, loadJobDefinition } from \"./runtime/jobs.mjs\";\n+import {\n+  discoverJobs,\n+  findJobFile,\n+  findAllJobs,\n+  loadJobDefinition,\n+} from \"./runtime/jobs.mjs\";\n import { useGit } from \"./composables/git.mjs\";\n import { runJobWithContext } from \"./runtime/boot.mjs\";\n import { loadConfig } from \"./runtime/config.mjs\";\n \n@@ -119,51 +124,61 @@\n   const parsedArgs = parseArgs(args);\n   const commandArgs = {\n     args: {\n       [action]: true,\n-      ...parsedArgs\n-    }\n+      ...parsedArgs,\n+    },\n   };\n \n   // Handle specific pack subcommands\n-  if (action === \"apply\" || action === \"plan\" || action === \"remove\" || action === \"update\") {\n+  if (\n+    action === \"apply\" ||\n+    action === \"plan\" ||\n+    action === \"remove\" ||\n+    action === \"update\"\n+  ) {\n     commandArgs.args.pack = parsedArgs.arg0 || parsedArgs.pack;\n   }\n \n-  return await packCommand.subCommands[action]?.run(commandArgs) || packCommand.run(commandArgs);\n+  return (\n+    (await packCommand.subCommands[action]?.run(commandArgs)) ||\n+    packCommand.run(commandArgs)\n+  );\n }\n \n async function handleScaffold(scaffold, ...args) {\n   // Use new scaffold command handler\n   const parsedArgs = parseArgs(args);\n   return await scaffoldCommand.run({ args: { scaffold, ...parsedArgs } });\n }\n \n-async function handleMarketplace(action = 'browse', ...args) {\n+async function handleMarketplace(action = \"browse\", ...args) {\n   // Use new marketplace command handler\n   const parsedArgs = parseArgs(args);\n \n   // For search command, the first non-flag argument is the query\n-  if (action === 'search' && args.length > 0 && !args[0].startsWith('--')) {\n+  if (action === \"search\" && args.length > 0 && !args[0].startsWith(\"--\")) {\n     parsedArgs.query = args[0];\n   }\n \n   // For inspect command, the first non-flag argument is the pack\n-  if (action === 'inspect' && args.length > 0 && !args[0].startsWith('--')) {\n+  if (action === \"inspect\" && args.length > 0 && !args[0].startsWith(\"--\")) {\n     parsedArgs.pack = args[0];\n   }\n \n   if (marketplaceCommand.subCommands[action]) {\n-    return await marketplaceCommand.subCommands[action].run({ args: parsedArgs });\n+    return await marketplaceCommand.subCommands[action].run({\n+      args: parsedArgs,\n+    });\n   }\n \n   return await marketplaceCommand.run({ args: parsedArgs });\n }\n \n async function handleCompose(...args) {\n   // Use new compose command handler\n   const parsedArgs = parseArgs(args);\n-  parsedArgs.packs = args.filter(arg => !arg.startsWith('--'));\n+  parsedArgs.packs = args.filter((arg) => !arg.startsWith(\"--\"));\n   return await composeCommand.run({ args: parsedArgs });\n }\n \n async function handleEnsure(...args) {\n@@ -308,10 +323,10 @@\n           logger: {\n             log: console.log,\n             warn: console.warn,\n             error: console.error,\n-            info: console.info\n-          }\n+            info: console.info,\n+          },\n         };\n \n         console.log(`Running job: ${jobName}`);\n         const result = await runJobWithContext(ctx, jobDef);\n@@ -359,10 +374,10 @@\n       logger: {\n         log: console.log,\n         warn: console.warn,\n         error: console.error,\n-        info: console.info\n-      }\n+        info: console.info,\n+      },\n     };\n \n     console.log(`Running job: ${jobName}`);\n     const result = await runJobWithContext(ctx, jobDef);\n@@ -434,14 +449,20 @@\n       console.log(\"  models                     Show available AI models\");\n       console.log(\"  help                       Show this help\");\n       console.log();\n       console.log(\"Options:\");\n-      console.log(\"  --model <name>             AI model name (default: qwen3-coder:30b)\");\n-      console.log(\"  --temp <number>            Temperature 0.0-1.0 (default: 0.7)\");\n+      console.log(\n+        \"  --model <name>             AI model name (default: qwen3-coder:30b)\",\n+      );\n+      console.log(\n+        \"  --temp <number>            Temperature 0.0-1.0 (default: 0.7)\",\n+      );\n       console.log();\n       console.log(\"Examples:\");\n-      console.log(\"  gitvan llm call \\\"What is GitVan?\\\"\");\n-      console.log(\"  gitvan llm call \\\"Generate a JavaScript function\\\" --model qwen3-coder:30b\");\n+      console.log('  gitvan llm call \"What is GitVan?\"');\n+      console.log(\n+        '  gitvan llm call \"Generate a JavaScript function\" --model qwen3-coder:30b',\n+      );\n       console.log(\"  gitvan llm models\");\n       break;\n \n     default:\n@@ -494,5 +515,5 @@\n export { main };\n \n if (import.meta.url === `file://${process.argv[1]}`) {\n   main();\n-}\n\\ No newline at end of file\n+}\n"
                }
            ],
            "date": 1758057329115,
            "name": "Commit-0",
            "content": "#!/usr/bin/env node\n\nimport { readFileSync, readdirSync, statSync } from \"node:fs\";\nimport { join, extname } from \"pathe\";\nimport { GitVanDaemon, startDaemon } from \"./runtime/daemon.mjs\";\nimport { discoverEvents, loadEventDefinition } from \"./runtime/events.mjs\";\nimport { readReceiptsRange } from \"./runtime/receipt.mjs\";\nimport { useGit } from \"./composables/git.mjs\";\nimport { runJobWithContext } from \"./runtime/boot.mjs\";\nimport { loadConfig } from \"./runtime/config.mjs\";\n\n// Import new CLI commands\nimport { cronCommand } from \"./cli/cron.mjs\";\nimport { daemonCommand } from \"./cli/daemon.mjs\";\nimport { eventCommand } from \"./cli/event.mjs\";\nimport { auditCommand } from \"./cli/audit.mjs\";\nimport { chatCommand } from \"./cli/chat.mjs\";\n\nconst commands = {\n  daemon: handleDaemon,\n  run: handleRun,\n  list: handleList,\n  event: handleEvent,\n  schedule: handleSchedule,\n  worktree: handleWorktree,\n  job: handleJob,\n  help: handleHelp,\n\n  // New v2 commands\n  cron: cronCommand,\n  audit: auditCommand,\n  chat: chatCommand,\n  llm: handleLLM,\n};\n\nasync function main() {\n  const [, , command, ...args] = process.argv;\n\n  if (!command || command === \"help\") {\n    handleHelp();\n    return;\n  }\n\n  const handler = commands[command];\n  if (!handler) {\n    console.error(`Unknown command: ${command}`);\n    handleHelp();\n    process.exit(1);\n  }\n\n  try {\n    await handler(...args);\n  } catch (err) {\n    console.error(\"Error:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function handleDaemon(action = \"start\", ...options) {\n  const worktreePath = process.cwd();\n\n  // Parse options\n  const opts = {};\n  for (let i = 0; i < options.length; i += 2) {\n    const key = options[i]?.replace(/^--/, \"\");\n    const value = options[i + 1];\n    if (key) opts[key] = value;\n  }\n\n  switch (action) {\n    case \"start\":\n      if (opts.worktrees === \"all\") {\n        console.log(\"Starting daemon for all worktrees...\");\n        await startDaemon({ rootDir: worktreePath }, null, \"all\");\n      } else {\n        const daemon = new GitVanDaemon(worktreePath);\n        await daemon.start();\n      }\n      break;\n    case \"stop\":\n      const daemon = new GitVanDaemon(worktreePath);\n      daemon.stop();\n      break;\n    case \"status\":\n      const statusDaemon = new GitVanDaemon(worktreePath);\n      console.log(\n        `Daemon ${statusDaemon.isRunning() ? \"running\" : \"not running\"} for: ${worktreePath}`,\n      );\n      break;\n    default:\n      console.error(`Unknown daemon action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleEvent(action = \"list\", ...args) {\n  // Use new event command handler\n  return await eventCommand(action, parseArgs(args));\n}\n\nfunction parseArgs(args) {\n  const parsed = {};\n  for (let i = 0; i < args.length; i += 2) {\n    const key = args[i]?.replace(/^--/, \"\");\n    const value = args[i + 1];\n    if (key) parsed[key] = value;\n  }\n  return parsed;\n}\n\nasync function handleSchedule(action = \"apply\") {\n  switch (action) {\n    case \"apply\":\n      console.log(\"Schedule management not yet implemented\");\n      // TODO: Implement cron-like scheduling\n      break;\n    default:\n      console.error(`Unknown schedule action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleWorktree(action = \"list\") {\n  switch (action) {\n    case \"list\":\n      try {\n        // We need to create a minimal context for Git operations\n        const ctx = {\n          root: process.cwd(),\n          env: process.env,\n          now: () => new Date().toISOString(),\n        };\n\n        const { withGitVan } = await import(\"./composables/ctx.mjs\");\n        await withGitVan(ctx, async () => {\n          const git = useGit();\n          const worktrees = git.listWorktrees();\n\n          if (worktrees.length === 0) {\n            console.log(\"No worktrees found\");\n            return;\n          }\n\n          console.log(\"\\nWorktrees:\");\n          console.log(\"==========\");\n          for (const wt of worktrees) {\n            console.log(`${wt.path} ${wt.isMain ? \"(main)\" : \"\"}`);\n            console.log(`  Branch: ${wt.branch || \"detached\"}`);\n            if (wt.head) console.log(`  HEAD: ${wt.head.slice(0, 8)}`);\n            console.log();\n          }\n        });\n      } catch (err) {\n        console.error(\"Error listing worktrees:\", err.message);\n      }\n      break;\n    default:\n      console.error(`Unknown worktree action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleJob(action = \"list\", ...args) {\n  switch (action) {\n    case \"list\":\n      console.log(\"Job listing not yet implemented\");\n      // TODO: Discover and list available jobs\n      break;\n    case \"run\":\n      const nameIndex = args.indexOf(\"--name\");\n      if (nameIndex === -1 || !args[nameIndex + 1]) {\n        console.error(\"Job name required: gitvan job run --name <job-name>\");\n        process.exit(1);\n      }\n      const jobName = args[nameIndex + 1];\n      console.log(`Running job: ${jobName}`);\n      // TODO: Implement job execution\n      break;\n    default:\n      console.error(`Unknown job action: ${action}`);\n      process.exit(1);\n  }\n}\n\nasync function handleRun(jobName) {\n  if (!jobName) {\n    console.error(\"Job name required\");\n    process.exit(1);\n  }\n\n  const worktreePath = process.cwd();\n  const jobsDir = join(worktreePath, \"jobs\");\n  const jobPath = findJobFile(jobsDir, jobName);\n\n  if (!jobPath) {\n    console.error(`Job not found: ${jobName}`);\n    process.exit(1);\n  }\n\n  const jobMod = await import(`file://${jobPath}`);\n  const ctx = {\n    root: worktreePath,\n    env: process.env,\n    now: () => new Date().toISOString(),\n  };\n\n  console.log(`Running job: ${jobName}`);\n  const result = await runJobWithContext(ctx, jobMod);\n  console.log(\"Result:\", JSON.stringify(result, null, 2));\n}\n\nfunction handleList() {\n  const worktreePath = process.cwd();\n  const jobsDir = join(worktreePath, \"jobs\");\n\n  if (!statSync(jobsDir).isDirectory()) {\n    console.log(\"No jobs directory found\");\n    return;\n  }\n\n  const jobs = findAllJobs(jobsDir);\n  console.log(\"Available jobs:\");\n  jobs.forEach((job) => console.log(`  ${job}`));\n}\n\n// LLM command handler\nasync function handleLLM(subcommand = \"call\", ...args) {\n  const { generateText, checkAIAvailability } = await import(\n    \"./ai/provider.mjs\"\n  );\n  const { loadOptions } = await import(\"./config/loader.mjs\");\n\n  const config = await loadOptions();\n\n  switch (subcommand) {\n    case \"call\":\n      if (!args[0]) {\n        console.error('Prompt required: gitvan llm call \"<prompt>\"');\n        process.exit(1);\n      }\n\n      const prompt = args[0];\n      const model = args.includes(\"--model\")\n        ? args[args.indexOf(\"--model\") + 1]\n        : undefined;\n\n      try {\n        const result = await generateText({ prompt, model, config });\n        console.log(result.output);\n      } catch (error) {\n        console.error(\"LLM call failed:\", error.message);\n        process.exit(1);\n      }\n      break;\n\n    case \"models\":\n      const availability = await checkAIAvailability(config);\n      console.log(`Provider: ${availability.provider}`);\n      console.log(`Model: ${availability.model}`);\n      console.log(`Available: ${availability.available ? \"Yes\" : \"No\"}`);\n      if (!availability.available) {\n        console.log(`Message: ${availability.message}`);\n      }\n      break;\n\n    default:\n      console.error(`Unknown llm subcommand: ${subcommand}`);\n      process.exit(1);\n  }\n}\n\nfunction handleHelp() {\n  console.log(`\nGitVan v2 - AI-powered Git workflow automation\n\nUsage:\n  gitvan daemon [start|stop|status] [--worktrees all]    Manage daemon\n  gitvan job [list|run] [--name <job-name>]              Job management\n  gitvan event [list|simulate|test]                      Event management\n  gitvan cron [list|start|dry-run]                       Cron job management\n  gitvan audit [build|verify|list]                       Receipt audit\n  gitvan chat [draft|generate|explain]                    AI job generation\n  gitvan llm [call|models]                               AI operations\n  gitvan schedule apply                                  Apply scheduled tasks\n  gitvan worktree list                                   List all worktrees\n  gitvan run <job-name>                                  Run a specific job (legacy)\n  gitvan list                                            List available jobs (legacy)\n  gitvan help                                            Show this help\n\nExamples:\n  gitvan daemon start                                    Start daemon for current worktree\n  gitvan cron list                                       List all cron jobs\n  gitvan event simulate --files \"src/**\"                Simulate file change event\n  gitvan chat generate \"Create a changelog job\"         Generate job via AI\n  gitvan llm call \"Summarize recent commits\"            Call AI directly\n  gitvan audit build --out audit.json                  Build audit pack\n`);\n}\n\nfunction findJobFile(jobsDir, jobName) {\n  const possiblePaths = [\n    join(jobsDir, `${jobName}.mjs`),\n    join(jobsDir, `${jobName}.js`),\n    join(jobsDir, jobName, \"index.mjs\"),\n    join(jobsDir, jobName, \"index.js\"),\n  ];\n\n  for (const path of possiblePaths) {\n    try {\n      if (statSync(path).isFile()) {\n        return path;\n      }\n    } catch (err) {\n      // File doesn't exist, continue\n    }\n  }\n\n  return null;\n}\n\nfunction findAllJobs(dir, prefix = \"\") {\n  const jobs = [];\n\n  try {\n    const entries = readdirSync(dir);\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry);\n      const stat = statSync(fullPath);\n\n      if (stat.isDirectory()) {\n        jobs.push(\n          ...findAllJobs(fullPath, prefix ? `${prefix}/${entry}` : entry),\n        );\n      } else if (stat.isFile() && [\".mjs\", \".js\"].includes(extname(entry))) {\n        const jobName = prefix\n          ? `${prefix}/${entry.replace(/\\.(mjs|js)$/, \"\")}`\n          : entry.replace(/\\.(mjs|js)$/, \"\");\n        jobs.push(jobName);\n      }\n    }\n  } catch (err) {\n    // Directory doesn't exist or is not accessible\n  }\n\n  return jobs;\n}\n\nexport { main };\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n"
        }
    ]
}