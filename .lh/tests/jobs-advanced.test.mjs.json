{
    "sourceFile": "tests/jobs-advanced.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758048967774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758048967774,
            "name": "Commit-0",
            "content": "// tests/jobs-advanced.test.mjs\n// GitVan v2 â€” Advanced Job System Tests\n// Tests cron scheduler, events, daemon, and hooks\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { CronScheduler, CronCLI } from \"../src/jobs/cron.mjs\";\nimport {\n  EventEvaluator,\n  EventJobRunner,\n  EventCLI,\n} from \"../src/jobs/events.mjs\";\nimport { JobDaemon, DaemonCLI } from \"../src/jobs/daemon.mjs\";\nimport {\n  JobHooks,\n  createJobHooks,\n  HookCLI,\n  JOB_HOOKS,\n} from \"../src/jobs/hooks.mjs\";\n\ndescribe(\"GitVan Advanced Job System Tests\", () => {\n  let tempDir;\n  let jobsDir;\n\n  beforeEach(async () => {\n    tempDir = join(process.cwd(), \"test-advanced-jobs-temp\");\n    jobsDir = join(tempDir, \"jobs\");\n    await fs.mkdir(jobsDir, { recursive: true });\n  });\n\n  afterEach(async () => {\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  });\n\n  describe(\"cron scheduler\", () => {\n    let scheduler;\n\n    beforeEach(() => {\n      scheduler = new CronScheduler();\n    });\n\n    it(\"should parse cron expressions\", () => {\n      const spec = scheduler.parseCron(\"0 2 * * *\");\n      expect(spec.minute).toBe(0);\n      expect(spec.hour).toBe(2);\n      expect(spec.day).toBe(null); // \"*\"\n      expect(spec.month).toBe(null); // \"*\"\n      expect(spec.weekday).toBe(null); // \"*\"\n    });\n\n    it(\"should parse complex cron expressions\", () => {\n      const spec = scheduler.parseCron(\"*/15 9-17 * * 1-5\");\n      expect(spec.minute).toEqual({ base: 0, step: 15 });\n      expect(spec.hour).toEqual({ start: 9, end: 17 });\n      expect(spec.weekday).toEqual({ start: 1, end: 5 });\n    });\n\n    it(\"should validate cron expressions\", () => {\n      expect(() => scheduler.parseCron(\"invalid\")).toThrow(\n        \"Invalid cron expression\",\n      );\n      expect(() => scheduler.parseCron(\"0 2\")).toThrow(\"expected 5 fields\");\n    });\n\n    it(\"should match cron expressions\", () => {\n      const spec = scheduler.parseCron(\"0 2 * * *\");\n      // Create a date that is actually 2:00 AM in local time\n      const testDate = new Date(2024, 0, 1, 2, 0, 0); // January 1, 2024, 2:00 AM local time\n\n      // Debug the matching\n      console.log(\"Test date:\", testDate);\n      console.log(\"Hour:\", testDate.getHours());\n      console.log(\"Minute:\", testDate.getMinutes());\n      console.log(\"Spec:\", spec);\n\n      // The test date is 2:00 AM local time, which should match \"0 2 * * *\"\n      expect(scheduler.matchesCron(spec, testDate)).toBe(true);\n    });\n\n    it(\"should calculate next execution time\", () => {\n      const spec = scheduler.parseCron(\"0 2 * * *\");\n      const from = new Date(\"2024-01-01T01:00:00Z\");\n      const next = scheduler.getNextExecution(spec, from);\n\n      expect(next).toBeDefined();\n      expect(next.getHours()).toBe(2);\n      expect(next.getMinutes()).toBe(0);\n    });\n\n    it(\"should create cron scheduler\", () => {\n      expect(scheduler).toBeDefined();\n      expect(scheduler.isRunning).toBe(false);\n      expect(scheduler.schedule.size).toBe(0);\n    });\n  });\n\n  describe(\"event evaluator\", () => {\n    let evaluator;\n\n    beforeEach(() => {\n      evaluator = new EventEvaluator();\n    });\n\n    it(\"should create event evaluator\", () => {\n      expect(evaluator).toBeDefined();\n    });\n\n    it(\"should match patterns\", () => {\n      expect(evaluator.matchesPattern(\"test.txt\", \"*.txt\")).toBe(true);\n      expect(evaluator.matchesPattern(\"test.txt\", \"test.*\")).toBe(true);\n      expect(evaluator.matchesPattern(\"test.txt\", \"*.md\")).toBe(false);\n      expect(evaluator.matchesPattern(\"test.txt\", \"test.txt\")).toBe(true);\n    });\n\n    it(\"should evaluate logical predicates\", async () => {\n      const predicates = {\n        any: [{ tagCreate: \"v*.*.*\" }, { message: \"release\" }],\n      };\n\n      const results = await evaluator.evaluatePredicates(predicates, {});\n      expect(results).toBeDefined();\n      expect(results.any).toBeDefined();\n    });\n\n    it(\"should check predicate truth\", () => {\n      expect(evaluator.isPredicateTrue(true)).toBe(true);\n      expect(evaluator.isPredicateTrue(false)).toBe(false);\n      expect(evaluator.isPredicateTrue({ any: true })).toBe(true);\n      expect(evaluator.isPredicateTrue({ all: false })).toBe(false);\n    });\n  });\n\n  describe(\"event job runner\", () => {\n    let runner;\n\n    beforeEach(() => {\n      runner = new EventJobRunner();\n    });\n\n    it(\"should create event job runner\", () => {\n      expect(runner).toBeDefined();\n      expect(runner.eventJobs.size).toBe(0);\n    });\n\n    it(\"should dry run event jobs\", async () => {\n      const result = await runner.dryRun({ commit: \"HEAD\" });\n      expect(result).toBeDefined();\n      expect(result.context).toBeDefined();\n      expect(result.jobsToRun).toBeDefined();\n      expect(result.totalJobs).toBeDefined();\n    });\n  });\n\n  describe(\"job daemon\", () => {\n    let daemon;\n\n    beforeEach(() => {\n      daemon = new JobDaemon();\n    });\n\n    it(\"should create job daemon\", () => {\n      expect(daemon).toBeDefined();\n      expect(daemon.isRunning).toBe(false);\n      expect(daemon.cronScheduler).toBeDefined();\n      expect(daemon.eventRunner).toBeDefined();\n    });\n\n    it(\"should get daemon status\", () => {\n      const status = daemon.getStatus();\n      expect(status).toBeDefined();\n      expect(status.isRunning).toBe(false);\n      expect(status.cronStatus).toBe(null);\n    });\n\n    it(\"should get daemon statistics\", async () => {\n      const stats = await daemon.getStats();\n      expect(stats).toBeDefined();\n      expect(stats.cronJobs).toBe(0);\n      expect(stats.eventJobs).toBe(0);\n      expect(stats.totalJobs).toBe(0);\n    });\n  });\n\n  describe(\"job hooks\", () => {\n    let hooks;\n\n    beforeEach(() => {\n      hooks = new JobHooks();\n    });\n\n    it(\"should create job hooks\", () => {\n      expect(hooks).toBeDefined();\n      expect(hooks.hooks).toBeDefined();\n      expect(hooks.hookCounts.size).toBe(0);\n    });\n\n    it(\"should add and remove hooks\", () => {\n      const testHook = vi.fn();\n\n      hooks.hook(\"test:hook\", testHook);\n      expect(hooks.hookCounts.get(\"test:hook\")).toBe(1);\n\n      hooks.unhook(\"test:hook\", testHook);\n      expect(hooks.hookCounts.get(\"test:hook\")).toBe(0);\n    });\n\n    it(\"should call hooks\", async () => {\n      const testHook = vi.fn().mockResolvedValue(undefined);\n      hooks.hook(\"test:hook\", testHook);\n\n      await hooks.callHook(\"test:hook\", { test: \"data\" });\n\n      expect(testHook).toHaveBeenCalledWith({ test: \"data\" });\n    });\n\n    it(\"should get hook statistics\", () => {\n      const testHook = vi.fn();\n      hooks.hook(\"test:hook\", testHook);\n\n      const stats = hooks.getStats();\n      expect(stats.totalHooks).toBe(1);\n      expect(stats.hookCounts[\"test:hook\"]).toBe(1);\n    });\n\n    it(\"should list hooks\", () => {\n      const testHook = vi.fn();\n      hooks.hook(\"test:hook\", testHook);\n\n      const hookList = hooks.listHooks();\n      expect(hookList).toContain(\"test:hook\");\n    });\n\n    it(\"should create hooks with defaults\", () => {\n      const hooksWithDefaults = createJobHooks();\n      expect(hooksWithDefaults).toBeDefined();\n      expect(hooksWithDefaults.hookCounts.size).toBeGreaterThan(0);\n    });\n\n    it(\"should create hooks with custom options\", () => {\n      const customHook = vi.fn();\n      const hooksWithCustom = createJobHooks({\n        hooks: { \"custom:hook\": customHook },\n      });\n\n      expect(hooksWithCustom.hookCounts.get(\"custom:hook\")).toBe(1);\n    });\n  });\n\n  describe(\"hook CLI\", () => {\n    let hookCLI;\n\n    beforeEach(() => {\n      hookCLI = new HookCLI();\n    });\n\n    it(\"should create hook CLI\", () => {\n      expect(hookCLI).toBeDefined();\n      expect(hookCLI.hooks).toBeDefined();\n    });\n\n    it(\"should list available hooks\", () => {\n      // This would normally console.log, but we can test the structure\n      expect(JOB_HOOKS).toBeDefined();\n      expect(Object.keys(JOB_HOOKS).length).toBeGreaterThan(0);\n      expect(JOB_HOOKS[\"job:before\"]).toBeDefined();\n    });\n\n    it(\"should show hook statistics\", () => {\n      const stats = hookCLI.hooks.getStats();\n      expect(stats).toBeDefined();\n      expect(stats.totalHooks).toBeGreaterThan(0);\n    });\n\n    it(\"should test hooks\", async () => {\n      const testData = { id: \"test\", payload: {} };\n\n      // This would normally console.log, but we can test the execution\n      await expect(hookCLI.test(\"job:before\", testData)).resolves.not.toThrow();\n    });\n  });\n\n  describe(\"cron CLI\", () => {\n    let cronCLI;\n\n    beforeEach(() => {\n      cronCLI = new CronCLI();\n    });\n\n    it(\"should create cron CLI\", () => {\n      expect(cronCLI).toBeDefined();\n      expect(cronCLI.scheduler).toBe(null);\n    });\n\n    it(\"should list cron schedule\", async () => {\n      // This would normally console.log, but we can test the execution\n      await expect(cronCLI.list()).resolves.not.toThrow();\n    });\n\n    it(\"should dry run cron jobs\", async () => {\n      const targetTime = new Date(\"2024-01-01T02:00:00Z\");\n\n      // This would normally console.log, but we can test the execution\n      await expect(cronCLI.dryRun(targetTime)).resolves.not.toThrow();\n    });\n  });\n\n  describe(\"event CLI\", () => {\n    let eventCLI;\n\n    beforeEach(() => {\n      eventCLI = new EventCLI();\n    });\n\n    it(\"should create event CLI\", () => {\n      expect(eventCLI).toBeDefined();\n      expect(eventCLI.runner).toBe(null);\n    });\n\n    it(\"should list event jobs\", async () => {\n      // This would normally console.log, but we can test the execution\n      await expect(eventCLI.list()).resolves.not.toThrow();\n    });\n\n    it(\"should dry run event jobs\", async () => {\n      const context = { commit: \"HEAD\", previousCommit: \"HEAD~1\" };\n\n      // This would normally console.log, but we can test the execution\n      await expect(eventCLI.dryRun(context)).resolves.not.toThrow();\n    });\n  });\n\n  describe(\"daemon CLI\", () => {\n    let daemonCLI;\n\n    beforeEach(() => {\n      daemonCLI = new DaemonCLI();\n    });\n\n    it(\"should create daemon CLI\", () => {\n      expect(daemonCLI).toBeDefined();\n      expect(daemonCLI.daemon).toBe(null);\n    });\n\n    it(\"should show daemon status\", async () => {\n      // This would normally console.log, but we can test the execution\n      await expect(daemonCLI.status()).resolves.not.toThrow();\n    });\n\n    it(\"should show daemon statistics\", async () => {\n      // This would normally console.log, but we can test the execution\n      await expect(daemonCLI.stats()).resolves.not.toThrow();\n    });\n  });\n\n  describe(\"integration tests\", () => {\n    it(\"should integrate hooks with job runner\", async () => {\n      const hooks = createJobHooks({ defaultHooks: false });\n      const testHook = vi.fn();\n      hooks.hook(\"job:before\", testHook);\n\n      // Mock job definition\n      const jobDef = {\n        id: \"test:integration\",\n        run: vi.fn().mockResolvedValue({ ok: true }),\n        version: \"1.0.0\",\n      };\n\n      // This would require a full job runner setup, but we can test the hook integration\n      expect(hooks.hookCounts.get(\"job:before\")).toBe(1);\n    });\n\n    it(\"should handle cron and event jobs together\", async () => {\n      const daemon = new JobDaemon();\n\n      // Test that daemon can handle both types\n      expect(daemon.cronScheduler).toBeDefined();\n      expect(daemon.eventRunner).toBeDefined();\n\n      const status = daemon.getStatus();\n      expect(status.isRunning).toBe(false);\n    });\n  });\n});\n"
        }
    ]
}