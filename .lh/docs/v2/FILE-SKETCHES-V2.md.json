{
    "sourceFile": "docs/v2/FILE-SKETCHES-V2.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758056699029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758056714140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -549,4 +549,82 @@\n * Zod schemas are **non-breaking** and align with your current `defineJob` contract.\n * The CLI wrappers (`cron/daemon/event/audit/chat`) avoid touching your current `src/cli/job.mjs` and `src/cli.mjs`.\n \n If you want, I can also add **mock CLI help** entries for these new commands next.\n+\n+Here’s the **target `src/` layout for GitVan v2 (complete)** — no code, just structure:\n+\n+```\n+src/\n+├─ index.mjs\n+├─ index.ts\n+│\n+├─ cli/\n+│  ├─ cli.mjs                 # entry / dispatcher for subcommands\n+│  ├─ job.mjs                 # job list/run/plan/show/locks\n+│  ├─ cron.mjs                # cron list/dry-run/start\n+│  ├─ daemon.mjs              # daemon start/status/stop\n+│  ├─ event.mjs               # event simulate/test predicates\n+│  ├─ audit.mjs               # build/verify audit pack (receipts)\n+│  └─ chat.mjs                # conversational job/event generator\n+│\n+├─ composables/\n+│  ├─ ctx.mjs                 # unctx context\n+│  ├─ git.mjs                 # git ops (notes/locks/worktree-safe)\n+│  ├─ template.mjs            # nunjucks+inflection, render/renderToFile\n+│  ├─ exec.mjs                # deterministic exec/spawn wrapper\n+│  └─ index.mjs               # re-exports\n+│\n+├─ config/\n+│  ├─ defaults.mjs            # opinionated defaults (nunjucks only)\n+│  ├─ loader.mjs              # load+merge project config\n+│  └─ runtime-config.mjs      # normalization + serializability checks\n+│\n+├─ jobs/\n+│  ├─ define.mjs              # defineJob() validation + freeze\n+│  ├─ scan.mjs                # FS discovery (.mjs, *.cron.mjs, *.evt.mjs)\n+│  ├─ runner.mjs              # execution engine + receipts\n+│  ├─ hooks.mjs               # lifecycle hooks (before/after)\n+│  ├─ cron.mjs                # scheduler core (parse/match/next)\n+│  ├─ events.mjs              # event bus (predicates → trigger)\n+│  └─ daemon.mjs              # tick loop (locks + dispatch)\n+│\n+├─ runtime/\n+│  ├─ boot.mjs                # process bootstrap (env, UTC, seeds)\n+│  ├─ config.mjs              # resolved runtime options snapshot\n+│  ├─ define-job.mjs          # job module adapter (default export)\n+│  ├─ events.mjs              # runtime predicate evaluation\n+│  ├─ locks.mjs               # refs/gitvan/locks/** atomic ops\n+│  ├─ receipt.mjs             # refs/notes/gitvan/results JSON writer\n+│  └─ utils.mjs               # shared helpers (hashing, ids, etc.)\n+│\n+├─ router/\n+│  ├─ events.mjs              # high-level matcher orchestrator\n+│  └─ matchers/\n+│     ├─ path.mjs             # pathChanged/Added/Modified\n+│     ├─ tag.mjs              # tagCreate/semverTag\n+│     ├─ merge.mjs            # mergeTo / branchCreate\n+│     └─ commit.mjs           # message/author/signed\n+│\n+├─ schemas/\n+│  ├─ job.zod.mjs             # job/meta/on/cron/run schema\n+│  ├─ event.zod.mjs           # event predicates schema\n+│  ├─ receipt.zod.mjs         # receipt/audit schema\n+│  ├─ config.zod.mjs          # gitvan.config schema\n+│  └─ chat.zod.mjs            # conversational generation I/O\n+│\n+├─ ai/\n+│  ├─ provider.mjs            # Vercel AI SDK bridge (Ollama default)\n+│  ├─ ollama.mjs              # direct Ollama HTTP client (fallback)\n+│  └─ prompts/\n+│     ├─ job-writer.njk       # “emit valid job module” prompt\n+│     ├─ event-writer.njk     # “emit valid event job” prompt\n+│     └─ refiner.njk          # schema-guided refinement\n+│\n+└─ utils/\n+   ├─ nunjucks-config.mjs     # env, loaders, filters (inflection/json)\n+   ├─ fs.mjs                  # safe FS helpers (rooted paths)\n+   ├─ time.mjs                # nowISO/cron windows/UTC\n+   ├─ crypto.mjs              # content hashes/fingerprints\n+   ├─ logger.mjs              # tagged console/logger\n+   └─ worktree.mjs            # worktree detection/scope helpers\n+```\n"
                }
            ],
            "date": 1758056699029,
            "name": "Commit-0",
            "content": "Got it — here are lean, working **implementations for the new files** (pure ESM, minimal deps, aligned with your existing modules). Drop them under `src/` as shown.\n\n---\n\n### `src/utils/logger.mjs`\n\n```js\nconst LVL = (process.env.GITVAN_LOG_LEVEL || \"info\").toLowerCase();\nconst LEVELS = { silent: 0, error: 1, warn: 2, info: 3, debug: 4 };\n\nexport function createLogger(tag = \"gitvan\") {\n  const cur = LEVELS[LVL] ?? 3;\n  const fmt = (lvl, ...a) => console[lvl](`[${tag}]`, ...a);\n  return {\n    level: LVL,\n    error: (...a) => cur >= 1 && fmt(\"error\", ...a),\n    warn: (...a) => cur >= 2 && fmt(\"warn\", ...a),\n    info: (...a) => cur >= 3 && fmt(\"log\", ...a),\n    debug: (...a) => cur >= 4 && fmt(\"log\", ...a),\n    child(sub) { return createLogger(`${tag}:${sub}`); }\n  };\n}\n```\n\n### `src/utils/time.mjs`\n\n```js\nexport const nowISO = () => new Date().toISOString();\nexport const toUTC = (d) => new Date(typeof d === \"string\" ? d : d.getTime());\nexport function clampMs(ms, min = 0, max = 60_000) {\n  return Math.max(min, Math.min(ms, max));\n}\n```\n\n### `src/utils/fs.mjs`\n\n```js\nimport { resolve, normalize, sep } from \"pathe\";\nimport { mkdirSync, writeFileSync, readFileSync } from \"node:fs\";\n\nexport function resolveSafe(root, p) {\n  const abs = normalize(resolve(root, p));\n  const normRoot = normalize(resolve(root));\n  if (!abs.startsWith(normRoot + sep) && abs !== normRoot) {\n    throw new Error(`Path escapes root: ${p}`);\n  }\n  return abs;\n}\n\nexport function writeFileSafe(root, out, contents) {\n  const abs = resolveSafe(root, out);\n  mkdirSync(abs.substring(0, abs.lastIndexOf(sep)), { recursive: true });\n  writeFileSync(abs, contents);\n  return abs;\n}\n\nexport function readFileSafe(root, p, enc = \"utf8\") {\n  return readFileSync(resolveSafe(root, p), enc);\n}\n```\n\n### `src/utils/crypto.mjs`\n\n```js\nimport { createHash } from \"node:crypto\";\n\nexport function sha256Hex(input) {\n  return createHash(\"sha256\").update(input).digest(\"hex\");\n}\n\nexport function fingerprint(obj) {\n  const stable = JSON.stringify(obj, Object.keys(obj).sort());\n  return \"fp_\" + sha256Hex(stable).slice(0, 16);\n}\n```\n\n### `src/utils/worktree.mjs`\n\n```js\nimport { useGit } from \"../composables/git.mjs\";\n\nexport async function getWorktreeInfo() {\n  const git = useGit();\n  const commonDir = await git.run(\"rev-parse --git-common-dir\");\n  const worktree = await git.run(\"rev-parse --show-toplevel\");\n  const head = await git.head();\n  const branch = await git.getCurrentBranch();\n  return { commonDir, worktree, branch, head };\n}\n\nexport async function worktreeKey() {\n  const { commonDir, worktree, branch } = await getWorktreeInfo();\n  return `${commonDir}#${worktree}#${branch}`;\n}\n```\n\n---\n\n## Router\n\n### `src/router/matchers/path.mjs`\n\n```js\nfunction anyMatch(globs = [], files = []) {\n  if (!globs?.length) return false;\n  // naive glob: \"*\" wildcard only (keep simple; your scan/events can precompute)\n  const toRe = (g) => new RegExp(\"^\" + g.split(\"*\").map(escape).join(\".*\") + \"$\");\n  const escape = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  const ress = globs.map(toRe);\n  return files.some((f) => ress.some((r) => r.test(f)));\n}\n\nexport function pathChanged(pred, meta) {\n  const files = meta.filesChanged || [];\n  return anyMatch(pred.pathChanged, files);\n}\nexport function pathAdded(pred, meta) {\n  const files = meta.filesAdded || [];\n  return anyMatch(pred.pathAdded, files);\n}\nexport function pathModified(pred, meta) {\n  const files = meta.filesModified || [];\n  return anyMatch(pred.pathModified, files);\n}\n```\n\n### `src/router/matchers/tag.mjs`\n\n```js\nexport function tagCreate(pred, meta) {\n  if (!meta.tagsCreated?.length) return false;\n  if (typeof pred.tagCreate === \"string\") {\n    const re = new RegExp(pred.tagCreate);\n    return meta.tagsCreated.some((t) => re.test(t));\n  }\n  return true;\n}\n\nexport function semverTag(pred, meta) {\n  const re = /^v?\\d+\\.\\d+\\.\\d+(?:[-+].*)?$/;\n  return (meta.tagsCreated || []).some((t) => re.test(t));\n}\n```\n\n### `src/router/matchers/merge.mjs`\n\n```js\nexport function mergeTo(pred, meta) {\n  if (!meta.mergedTo) return false;\n  const want = pred.mergeTo;\n  return typeof want === \"string\" ? meta.mergedTo === want : false;\n}\n\nexport function branchCreate(pred, meta) {\n  if (!meta.branchCreated) return false;\n  const want = pred.branchCreate;\n  if (!want) return true;\n  const re = new RegExp(want);\n  return re.test(meta.branchCreated);\n}\n```\n\n### `src/router/matchers/commit.mjs`\n\n```js\nexport function message(pred, meta) {\n  if (!pred.message) return false;\n  const re = new RegExp(pred.message, \"i\");\n  return re.test(meta.message || \"\");\n}\n\nexport function authorEmail(pred, meta) {\n  if (!pred.authorEmail) return false;\n  const re = new RegExp(pred.authorEmail, \"i\");\n  return re.test(meta.authorEmail || \"\");\n}\n\nexport function signed(pred, meta) {\n  return !!meta.signed;\n}\n```\n\n### `src/router/events.mjs`\n\n```js\nimport * as P from \"./matchers/path.mjs\";\nimport * as T from \"./matchers/tag.mjs\";\nimport * as M from \"./matchers/merge.mjs\";\nimport * as C from \"./matchers/commit.mjs\";\n\nconst handlers = {\n  pathChanged: P.pathChanged,\n  pathAdded: P.pathAdded,\n  pathModified: P.pathModified,\n  tagCreate: T.tagCreate,\n  semverTag: T.semverTag,\n  mergeTo: M.mergeTo,\n  branchCreate: M.branchCreate,\n  message: C.message,\n  authorEmail: C.authorEmail,\n  signed: C.signed,\n};\n\nexport function matches(on, meta) {\n  if (!on || typeof on !== \"object\") return false;\n  if (on.any?.length) {\n    if (on.any.some((p) => matches(p, meta))) return true;\n  }\n  if (on.all?.length) {\n    if (!on.all.every((p) => matches(p, meta))) return false;\n  }\n  for (const [k, v] of Object.entries(on)) {\n    if (k === \"any\" || k === \"all\") continue;\n    const fn = handlers[k];\n    if (fn && fn({ [k]: v }, meta)) return true;\n  }\n  // if only all[] present and passed, it's a match\n  return !!on.all?.length;\n}\n```\n\n---\n\n## Schemas (Zod)\n\n### `src/schemas/event.zod.mjs`\n\n```js\nimport { z } from \"zod\";\n\nexport const EventPredicate = z.object({\n  any: z.lazy(() => z.array(EventPredicate)).optional(),\n  all: z.lazy(() => z.array(EventPredicate)).optional(),\n\n  tagCreate: z.string().optional(),\n  semverTag: z.boolean().optional(),\n  mergeTo: z.string().optional(),\n  branchCreate: z.string().optional(),\n\n  pathChanged: z.array(z.string()).optional(),\n  pathAdded: z.array(z.string()).optional(),\n  pathModified: z.array(z.string()).optional(),\n\n  message: z.string().optional(),\n  authorEmail: z.string().optional(),\n  signed: z.boolean().optional(),\n});\n```\n\n### `src/schemas/job.zod.mjs`\n\n```js\nimport { z } from \"zod\";\nimport { EventPredicate } from \"./event.zod.mjs\";\n\nexport const JobMeta = z.object({\n  id: z.string().optional(),\n  desc: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n});\n\nexport const JobDef = z.object({\n  id: z.string().optional(),\n  kind: z.enum([\"atomic\", \"batch\", \"daemon\"]).default(\"atomic\"),\n  cron: z.string().optional(),\n  meta: JobMeta.optional(),\n  on: EventPredicate.optional(),\n  run: z.function().args(z.object({ ctx: z.any(), payload: z.any().optional() })).returns(z.any()),\n  mode: z.enum([\"on-demand\", \"cron\", \"event\"]).optional(),\n  filename: z.string().optional(),\n  filePath: z.string().optional(),\n  version: z.string().optional(),\n});\n```\n\n### `src/schemas/receipt.zod.mjs`\n\n```js\nimport { z } from \"zod\";\n\nexport const Receipt = z.object({\n  kind: z.literal(\"workflow-receipt\"),\n  id: z.string(),\n  status: z.enum([\"OK\", \"ERROR\", \"SKIP\"]),\n  ts: z.string(),\n  commit: z.string().optional(),\n  action: z.string(),\n  env: z.record(z.string(), z.any()).optional(),\n  outputHash: z.string().optional(),\n  exitCode: z.number().optional(),\n  error: z.string().optional(),\n  artifacts: z.array(z.string()).default([]),\n  fingerprint: z.string().optional(),\n});\n```\n\n### `src/schemas/config.zod.mjs`\n\n```js\nimport { z } from \"zod\";\n\nexport const ConfigSchema = z.object({\n  rootDir: z.string().default(process.cwd()),\n  jobs: z.object({ dir: z.string().default(\"jobs\") }).default({}),\n  templates: z.object({\n    engine: z.literal(\"nunjucks\").default(\"nunjucks\"),\n    dirs: z.array(z.string()).default([\"templates\"]),\n    autoescape: z.boolean().default(false)\n  }).default({}),\n  receipts: z.object({\n    ref: z.string().default(\"refs/notes/gitvan/results\")\n  }).default({}),\n  hooks: z.record(z.string(), z.any()).default({}),\n});\n```\n\n### `src/schemas/chat.zod.mjs`\n\n```js\nimport { z } from \"zod\";\n\nexport const ChatInput = z.object({\n  prompt: z.string(),\n  kind: z.enum([\"job\", \"event\"]).default(\"job\"),\n  id: z.string().optional(),\n  path: z.string().optional(),\n});\n\nexport const ChatOutput = z.object({\n  ok: z.boolean().default(true),\n  id: z.string(),\n  mode: z.enum([\"on-demand\", \"cron\", \"event\"]).default(\"on-demand\"),\n  filePath: z.string(),\n  source: z.string(), // emitted module text\n  summary: z.string().optional(),\n});\n```\n\n---\n\n## AI\n\n### `src/ai/ollama.mjs`\n\n```js\nconst BASE = process.env.OLLAMA_BASE || \"http://localhost:11434\";\n\nexport async function generate({ model, prompt, options = {}, stream = false }) {\n  const res = await fetch(`${BASE}/api/generate`, {\n    method: \"POST\",\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ model, prompt, options, stream })\n  });\n  if (!res.ok) throw new Error(`Ollama ${res.status}`);\n  const j = await res.json();\n  return j.response || \"\";\n}\n\nexport async function embed({ model, text }) {\n  const res = await fetch(`${BASE}/api/embeddings`, {\n    method: \"POST\",\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ model, prompt: text })\n  });\n  if (!res.ok) throw new Error(`Ollama ${res.status}`);\n  const j = await res.json();\n  return j.embedding || [];\n}\n```\n\n### `src/ai/provider.mjs`\n\n```js\nimport { generate as ollamaGenerate } from \"./ollama.mjs\";\n\n/**\n * Minimal provider facade; extend to Vercel AI SDK if installed.\n */\nexport async function generateText({ model = process.env.GITVAN_MODEL || \"llama3.2\", prompt, options }) {\n  return await ollamaGenerate({ model, prompt, options });\n}\n```\n\n### `src/ai/prompts/job-writer.njk`\n\n```njk\nEmit ONLY valid ESM for a GitVan job module:\n\nimport { defineJob } from \"gitvan/define\"\n\nexport default defineJob({\n  meta: { desc: \"{{ desc | default('Generated job') }}\", tags: {{ tags | default(\"[]\") }} },\n  {% if cron %}cron: \"{{ cron }}\",{% endif %}\n  {% if on %}on: {{ on | safe }},{% endif %}\n  async run({ ctx, payload }) {\n    const { useGit } = await import(\"gitvan/composables/git\")\n    const { useTemplate } = await import(\"gitvan/composables/template\")\n    const git = useGit()\n    const tpl = await useTemplate()\n    {{ body | default(\"// TODO: implement\") }}\n    return { ok: true, artifacts: [] }\n  }\n})\n```\n\n*(same pattern for `event-writer.njk`, `refiner.njk`, tailored as needed)*\n\n---\n\n## CLI\n\n### `src/cli/cron.mjs`\n\n```js\nimport { startCronScheduler, CronCLI } from \"../jobs/cron.mjs\";\n\nexport async function cronCommand(sub = \"list\", args = {}) {\n  const cli = new CronCLI();\n  if (sub === \"list\") return cli.list();\n  if (sub === \"start\") return cli.start();\n  if (sub === \"dry-run\") return cli.dryRun(args.at);\n  throw new Error(`Unknown cron subcommand: ${sub}`);\n}\n\nexport async function cronStart() { return startCronScheduler(); }\n```\n\n### `src/cli/daemon.mjs`\n\n```js\nimport { startDaemon, daemonStatus, stopDaemon } from \"../runtime/daemon.mjs\";\n\nexport async function daemonCommand(sub = \"start\", args = {}) {\n  if (sub === \"start\") return startDaemon(args);\n  if (sub === \"status\") return daemonStatus();\n  if (sub === \"stop\") return stopDaemon();\n  throw new Error(`Unknown daemon subcommand: ${sub}`);\n}\n```\n\n### `src/cli/event.mjs`\n\n```js\nimport { scanJobs } from \"../jobs/scan.mjs\";\nimport { matches } from \"../router/events.mjs\";\nimport { loadOptions } from \"../config/loader.mjs\";\n\nexport async function eventSimulate(meta = {}) {\n  const cfg = await loadOptions();\n  const jobs = await scanJobs({ cwd: cfg.rootDir });\n  const evtJobs = jobs.filter((j) => j.on);\n  const hits = evtJobs.filter((j) => matches(j.on, meta)).map((j) => j.id);\n  console.log(`Matched ${hits.length} jobs:`);\n  hits.forEach((id) => console.log(\"  -\", id));\n  return hits;\n}\n```\n\n### `src/cli/audit.mjs`\n\n```js\nimport { useGit } from \"../composables/git.mjs\";\nimport { writeFileSafe } from \"../utils/fs.mjs\";\nimport { loadOptions } from \"../config/loader.mjs\";\n\nexport async function auditBuild({ out = \"dist/audit.json\" } = {}) {\n  const cfg = await loadOptions();\n  const git = useGit();\n  const list = await git.run(`notes --ref=${cfg.receipts.ref} list`).catch(() => \"\");\n  const lines = list.split(\"\\n\").filter(Boolean);\n  const receipts = [];\n  for (const l of lines) {\n    const sha = l.split(\" \")[0];\n    const raw = await git.run(`notes --ref=${cfg.receipts.ref} show ${sha}`).catch(() => null);\n    if (!raw) continue;\n    try { receipts.push(JSON.parse(raw)); } catch {}\n  }\n  const abs = writeFileSafe(cfg.rootDir, out, JSON.stringify({ count: receipts.length, receipts }, null, 2));\n  console.log(`Audit pack written: ${abs} (${receipts.length} receipts)`);\n  return { path: abs, count: receipts.length };\n}\n```\n\n### `src/cli/chat.mjs`\n\n```js\nimport { loadOptions } from \"../config/loader.mjs\";\nimport { ensureNunjucksEnv } from \"../utils/nunjucks-config.mjs\";\nimport { writeFileSafe } from \"../utils/fs.mjs\";\nimport { ChatInput, ChatOutput } from \"../schemas/chat.zod.mjs\";\nimport { JobDef } from \"../schemas/job.zod.mjs\";\nimport { generateText } from \"../ai/provider.mjs\";\nimport { fingerprint } from \"../utils/crypto.mjs\";\nimport { join, dirname } from \"pathe\";\n\nexport async function chatGenerate(input) {\n  const cfg = await loadOptions();\n  const args = ChatInput.parse(input);\n\n  // Build prompt via Nunjucks template (job-writer)\n  const env = ensureNunjucksEnv(cfg.rootDir, { paths: [join(process.cwd(), \"src/ai/prompts\")] });\n  const tmpl = env.getTemplate(\"job-writer.njk\");\n  const prompt = tmpl.render({\n    desc: `Generate a ${args.kind} for GitVan`,\n    tags: [\"generated\",\"chat\"],\n    cron: args.kind === \"event\" ? null : undefined,\n    on: args.kind === \"event\" ? \"{ \\\"message\\\": \\\".*\\\" }\" : undefined,\n    body: \"// minimal generated body\"\n  });\n\n  const source = await generateText({ prompt });\n  // Quick structural sanity (loads module shape via regex fallback)\n  if (!/defineJob\\s*\\(/.test(source)) {\n    throw new Error(\"Generated output is not a GitVan job module\");\n  }\n\n  // Decide file path\n  const id = args.id || `chat-${fingerprint({ t: Date.now(), prompt: args.prompt })}`;\n  const subdir = args.kind === \"event\" ? \"events/chat\" : \"jobs/chat\";\n  const fname = `${id}${args.kind === \"event\" ? \".evt.mjs\" : \".mjs\"}`;\n  const rel = args.path || join(subdir, fname);\n\n  const outPath = writeFileSafe(cfg.rootDir, rel, source);\n\n  // Optionally import & validate runtime (best-effort, isolated by dynamic import)\n  try {\n    const m = await import(\"file://\" + outPath);\n    if (m?.default) JobDef.parse(m.default); // lightweight runtime check\n  } catch { /* ignore soft failures */ }\n\n  return ChatOutput.parse({\n    ok: true,\n    id,\n    mode: args.kind === \"event\" ? \"event\" : \"on-demand\",\n    filePath: outPath,\n    source,\n    summary: \"Generated via chat interface\"\n  });\n}\n```\n\n---\n\n## Notes\n\n* These modules are intentionally **thin adapters** over your existing engine (`jobs/*`, `runtime/*`, `composables/*`), keeping surface area small.\n* The router uses **minimal glob/regex** to stay dependency-light; you can later swap to your richer path diff.\n* `chat.mjs` templates look up `src/ai/prompts/*`; you already ship Nunjucks — this reuses your stack.\n* Zod schemas are **non-breaking** and align with your current `defineJob` contract.\n* The CLI wrappers (`cron/daemon/event/audit/chat`) avoid touching your current `src/cli/job.mjs` and `src/cli.mjs`.\n\nIf you want, I can also add **mock CLI help** entries for these new commands next.\n"
        }
    ]
}