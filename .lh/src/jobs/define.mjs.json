{
    "sourceFile": "src/jobs/define.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1758048492138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758049591956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       continue;\n     }\n \n     if (val !== undefined && val !== null) {\n-      if (rules.type && typeof val !== rules.type) {\n+      if (rules.type && rules.type !== \"array\" && typeof val !== rules.type) {\n         errors.push(`${currentPath} must be ${rules.type}, got ${typeof val}`);\n       }\n \n       if (rules.enum && !rules.enum.includes(val)) {\n"
                },
                {
                    "date": 1758072827531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,295 +1,65 @@\n-// src/jobs/define.mjs\n-// GitVan v2 — Job Definition System\n-// Validates and freezes job definitions with comprehensive type checking\n-\n-import { klona } from \"klona/full\";\n-import { relative, basename, extname, join } from \"pathe\";\n-\n /**\n- * Job definition schema validation\n+ * GitVan v2 Job Definition Helper\n+ * Provides a helper function for defining jobs with metadata\n  */\n-const JOB_SCHEMA = {\n-  id: { type: \"string\", required: false },\n-  kind: {\n-    type: \"string\",\n-    enum: [\"atomic\", \"batch\", \"daemon\"],\n-    required: false,\n-  },\n-  cron: { type: \"string\", required: false },\n-  meta: { type: \"object\", required: false },\n-  on: { type: \"object\", required: false },\n-  run: { type: \"function\", required: true },\n-};\n \n /**\n- * Event predicate schema validation\n+ * Define a job with metadata and run function\n+ * @param {object} definition - Job definition object\n+ * @param {object} definition.meta - Job metadata\n+ * @param {function} definition.run - Job run function\n+ * @param {string} definition.cron - Optional cron schedule\n+ * @param {object} definition.inputs - Optional input schema\n+ * @returns {object} Job definition object\n  */\n-const EVENT_PREDICATE_SCHEMA = {\n-  any: { type: \"array\", required: false },\n-  all: { type: \"array\", required: false },\n-  tagCreate: { type: \"string\", required: false },\n-  semverTag: { type: \"boolean\", required: false },\n-  mergeTo: { type: \"string\", required: false },\n-  pushTo: { type: \"string\", required: false },\n-  pathChanged: { type: \"array\", required: false },\n-  pathAdded: { type: \"array\", required: false },\n-  pathModified: { type: \"array\", required: false },\n-  message: { type: \"string\", required: false },\n-  authorEmail: { type: \"string\", required: false },\n-  signed: { type: \"boolean\", required: false },\n-};\n+export function defineJob(definition) {\n+  const {\n+    meta = {},\n+    run,\n+    cron,\n+    inputs,\n+    ...otherProps\n+  } = definition;\n \n-/**\n- * Validate a value against a schema\n- */\n-function validateSchema(value, schema, path = \"\") {\n-  const errors = [];\n-\n-  for (const [key, rules] of Object.entries(schema)) {\n-    const val = value[key];\n-    const currentPath = path ? `${path}.${key}` : key;\n-\n-    if (rules.required && (val === undefined || val === null)) {\n-      errors.push(`${currentPath} is required`);\n-      continue;\n-    }\n-\n-    if (val !== undefined && val !== null) {\n-      if (rules.type && rules.type !== \"array\" && typeof val !== rules.type) {\n-        errors.push(`${currentPath} must be ${rules.type}, got ${typeof val}`);\n-      }\n-\n-      if (rules.enum && !rules.enum.includes(val)) {\n-        errors.push(\n-          `${currentPath} must be one of ${rules.enum.join(\", \")}, got ${val}`,\n-        );\n-      }\n-\n-      if (rules.type === \"array\" && !Array.isArray(val)) {\n-        errors.push(`${currentPath} must be an array`);\n-      }\n-\n-      if (\n-        rules.type === \"object\" &&\n-        (typeof val !== \"object\" || Array.isArray(val))\n-      ) {\n-        errors.push(`${currentPath} must be an object`);\n-      }\n-\n-      if (rules.type === \"function\" && typeof val !== \"function\") {\n-        errors.push(`${currentPath} must be a function`);\n-      }\n-    }\n+  if (typeof run !== 'function') {\n+    throw new Error('Job definition must include a run function');\n   }\n \n-  return errors;\n-}\n-\n-/**\n- * Validate event predicates recursively\n- */\n-function validateEventPredicate(predicate, path = \"on\") {\n-  const errors = [];\n-\n-  if (typeof predicate !== \"object\" || predicate === null) {\n-    errors.push(`${path} must be an object`);\n-    return errors;\n-  }\n-\n-  // Check for unknown keys\n-  const allowedKeys = Object.keys(EVENT_PREDICATE_SCHEMA);\n-  const predicateKeys = Object.keys(predicate);\n-  const unknownKeys = predicateKeys.filter((key) => !allowedKeys.includes(key));\n-\n-  if (unknownKeys.length > 0) {\n-    errors.push(`${path} contains unknown keys: ${unknownKeys.join(\", \")}`);\n-  }\n-\n-  // Validate top-level predicates\n-  const topLevelErrors = validateSchema(\n-    predicate,\n-    EVENT_PREDICATE_SCHEMA,\n-    path,\n-  );\n-  errors.push(...topLevelErrors);\n-\n-  // Validate nested any/all arrays\n-  if (predicate.any && Array.isArray(predicate.any)) {\n-    predicate.any.forEach((item, index) => {\n-      const nestedErrors = validateEventPredicate(\n-        item,\n-        `${path}.any[${index}]`,\n-      );\n-      errors.push(...nestedErrors);\n-    });\n-  }\n-\n-  if (predicate.all && Array.isArray(predicate.all)) {\n-    predicate.all.forEach((item, index) => {\n-      const nestedErrors = validateEventPredicate(\n-        item,\n-        `${path}.all[${index}]`,\n-      );\n-      errors.push(...nestedErrors);\n-    });\n-  }\n-\n-  return errors;\n-}\n-\n-/**\n- * Infer job mode from filename\n- */\n-function inferModeFromFilename(filename) {\n-  if (filename.endsWith(\".cron.mjs\")) return \"cron\";\n-  if (filename.endsWith(\".evt.mjs\")) return \"event\";\n-  return \"on-demand\";\n-}\n-\n-/**\n- * Infer job ID from file path\n- */\n-function inferIdFromPath(filePath, jobsDir = \"jobs\") {\n-  // Handle both absolute and relative paths\n-  const cwd = process.cwd();\n-  const jobsDirPath = join(cwd, jobsDir);\n-\n-  // If filePath is relative to jobsDir, use it directly\n-  if (filePath.includes(jobsDir)) {\n-    const relativePath = filePath.split(jobsDir + \"/\")[1];\n-    if (relativePath) {\n-      const withoutExt = relativePath.replace(/\\.(mjs|js|ts)$/, \"\");\n-      const withoutMode = withoutExt.replace(/\\.(cron|evt)$/, \"\");\n-      return withoutMode.replace(/\\//g, \":\");\n-    }\n-  }\n-\n-  // Fallback: use filename only\n-  const filename = basename(filePath, extname(filePath));\n-  const withoutMode = filename.replace(/\\.(cron|evt)$/, \"\");\n-  return withoutMode;\n-}\n-\n-/**\n- * Define and validate a job\n- * @param {Object} definition - Job definition object\n- * @param {Object} options - Additional options\n- * @returns {Object} Validated and frozen job definition\n- */\n-export function defineJob(definition, options = {}) {\n-  const errors = [];\n-\n-  // Validate main job schema\n-  const schemaErrors = validateSchema(definition, JOB_SCHEMA);\n-  errors.push(...schemaErrors);\n-\n-  // Validate event predicates if present\n-  if (definition.on) {\n-    const eventErrors = validateEventPredicate(definition.on);\n-    errors.push(...eventErrors);\n-  }\n-\n-  // Validate cron expression if present\n-  if (definition.cron) {\n-    // Basic cron validation (5 or 6 fields)\n-    const cronParts = definition.cron.trim().split(/\\s+/);\n-    if (cronParts.length < 5 || cronParts.length > 6) {\n-      errors.push(\"cron must have 5 or 6 space-separated fields\");\n-    }\n-  }\n-\n-  // Validate meta object structure (allow additional keys for flexibility)\n-  if (definition.meta && typeof definition.meta !== \"object\") {\n-    errors.push(\"meta must be an object\");\n-  }\n-\n-  if (errors.length > 0) {\n-    throw new Error(`Job definition validation failed:\\n${errors.join(\"\\n\")}`);\n-  }\n-\n-  // Create validated job definition\n-  const jobDef = {\n-    id: definition.id || options.inferredId,\n-    kind: definition.kind || \"atomic\",\n-    cron: definition.cron,\n-    meta: definition.meta || {},\n-    on: definition.on,\n-    run: definition.run,\n-    mode: options.mode || inferModeFromFilename(options.filename || \"\"),\n-    filename: options.filename,\n-    filePath: options.filePath,\n-    version: options.version || \"1.0.0\",\n+  return {\n+    meta: {\n+      desc: 'GitVan job',\n+      tags: [],\n+      ...meta\n+    },\n+    run,\n+    cron,\n+    inputs,\n+    ...otherProps\n   };\n-\n-  // Freeze the definition to prevent modification\n-  return Object.freeze(klona(jobDef));\n }\n \n /**\n- * Create a job definition with inferred properties\n- * @param {Object} definition - Job definition\n- * @param {string} filePath - Full file path\n- * @param {string} jobsDir - Jobs directory (default: \"jobs\")\n- * @returns {Object} Complete job definition\n+ * Define a cron job\n+ * @param {string} cron - Cron expression\n+ * @param {object} definition - Job definition\n+ * @returns {object} Job definition with cron schedule\n  */\n-export function createJobDefinition(definition, filePath, jobsDir = \"jobs\") {\n-  const filename = filePath.split(\"/\").pop();\n-  const inferredId = inferIdFromPath(filePath, jobsDir);\n-  const mode = inferModeFromFilename(filename);\n-\n-  return defineJob(definition, {\n-    inferredId,\n-    filename,\n-    filePath,\n-    mode,\n+export function defineCronJob(cron, definition) {\n+  return defineJob({\n+    ...definition,\n+    cron\n   });\n }\n \n /**\n- * Validate job execution context\n- * @param {Object} ctx - Execution context\n- * @returns {Object} Validated context\n+ * Define an event job\n+ * @param {object} predicate - Event predicate\n+ * @param {object} definition - Job definition\n+ * @returns {object} Job definition with event predicate\n  */\n-export function validateJobContext(ctx) {\n-  const required = [\"id\", \"root\", \"nowISO\", \"env\", \"git\", \"logger\"];\n-  const missing = required.filter((key) => !(key in ctx));\n-\n-  if (missing.length > 0) {\n-    throw new Error(\n-      `Job context missing required fields: ${missing.join(\", \")}`,\n-    );\n-  }\n-\n-  if (typeof ctx.git !== \"object\" || !ctx.git.head || !ctx.git.branch) {\n-    throw new Error(\n-      \"Job context git object must have head and branch properties\",\n-    );\n-  }\n-\n-  if (typeof ctx.logger !== \"object\" || typeof ctx.logger.log !== \"function\") {\n-    throw new Error(\"Job context logger must have log method\");\n-  }\n-\n-  return ctx;\n-}\n-\n-/**\n- * Create job execution context\n- * @param {Object} jobDef - Job definition\n- * @param {Object} options - Context options\n- * @returns {Object} Execution context\n- */\n-export function createJobContext(jobDef, options = {}) {\n-  const ctx = {\n-    id: jobDef.id,\n-    root: options.root || process.cwd(),\n-    nowISO: options.nowISO || new Date().toISOString(),\n-    env: options.env || process.env,\n-    git: options.git || {},\n-    trigger: options.trigger,\n-    logger: options.logger || console,\n-    payload: options.payload || {},\n-  };\n-\n-  return validateJobContext(ctx);\n-}\n+export function defineEventJob(predicate, definition) {\n+  return defineJob({\n+    ...definition,\n+    event: predicate\n+  });\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1758048492138,
            "name": "Commit-0",
            "content": "// src/jobs/define.mjs\n// GitVan v2 — Job Definition System\n// Validates and freezes job definitions with comprehensive type checking\n\nimport { klona } from \"klona/full\";\nimport { relative, basename, extname, join } from \"pathe\";\n\n/**\n * Job definition schema validation\n */\nconst JOB_SCHEMA = {\n  id: { type: \"string\", required: false },\n  kind: {\n    type: \"string\",\n    enum: [\"atomic\", \"batch\", \"daemon\"],\n    required: false,\n  },\n  cron: { type: \"string\", required: false },\n  meta: { type: \"object\", required: false },\n  on: { type: \"object\", required: false },\n  run: { type: \"function\", required: true },\n};\n\n/**\n * Event predicate schema validation\n */\nconst EVENT_PREDICATE_SCHEMA = {\n  any: { type: \"array\", required: false },\n  all: { type: \"array\", required: false },\n  tagCreate: { type: \"string\", required: false },\n  semverTag: { type: \"boolean\", required: false },\n  mergeTo: { type: \"string\", required: false },\n  pushTo: { type: \"string\", required: false },\n  pathChanged: { type: \"array\", required: false },\n  pathAdded: { type: \"array\", required: false },\n  pathModified: { type: \"array\", required: false },\n  message: { type: \"string\", required: false },\n  authorEmail: { type: \"string\", required: false },\n  signed: { type: \"boolean\", required: false },\n};\n\n/**\n * Validate a value against a schema\n */\nfunction validateSchema(value, schema, path = \"\") {\n  const errors = [];\n\n  for (const [key, rules] of Object.entries(schema)) {\n    const val = value[key];\n    const currentPath = path ? `${path}.${key}` : key;\n\n    if (rules.required && (val === undefined || val === null)) {\n      errors.push(`${currentPath} is required`);\n      continue;\n    }\n\n    if (val !== undefined && val !== null) {\n      if (rules.type && typeof val !== rules.type) {\n        errors.push(`${currentPath} must be ${rules.type}, got ${typeof val}`);\n      }\n\n      if (rules.enum && !rules.enum.includes(val)) {\n        errors.push(\n          `${currentPath} must be one of ${rules.enum.join(\", \")}, got ${val}`,\n        );\n      }\n\n      if (rules.type === \"array\" && !Array.isArray(val)) {\n        errors.push(`${currentPath} must be an array`);\n      }\n\n      if (\n        rules.type === \"object\" &&\n        (typeof val !== \"object\" || Array.isArray(val))\n      ) {\n        errors.push(`${currentPath} must be an object`);\n      }\n\n      if (rules.type === \"function\" && typeof val !== \"function\") {\n        errors.push(`${currentPath} must be a function`);\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validate event predicates recursively\n */\nfunction validateEventPredicate(predicate, path = \"on\") {\n  const errors = [];\n\n  if (typeof predicate !== \"object\" || predicate === null) {\n    errors.push(`${path} must be an object`);\n    return errors;\n  }\n\n  // Check for unknown keys\n  const allowedKeys = Object.keys(EVENT_PREDICATE_SCHEMA);\n  const predicateKeys = Object.keys(predicate);\n  const unknownKeys = predicateKeys.filter((key) => !allowedKeys.includes(key));\n\n  if (unknownKeys.length > 0) {\n    errors.push(`${path} contains unknown keys: ${unknownKeys.join(\", \")}`);\n  }\n\n  // Validate top-level predicates\n  const topLevelErrors = validateSchema(\n    predicate,\n    EVENT_PREDICATE_SCHEMA,\n    path,\n  );\n  errors.push(...topLevelErrors);\n\n  // Validate nested any/all arrays\n  if (predicate.any && Array.isArray(predicate.any)) {\n    predicate.any.forEach((item, index) => {\n      const nestedErrors = validateEventPredicate(\n        item,\n        `${path}.any[${index}]`,\n      );\n      errors.push(...nestedErrors);\n    });\n  }\n\n  if (predicate.all && Array.isArray(predicate.all)) {\n    predicate.all.forEach((item, index) => {\n      const nestedErrors = validateEventPredicate(\n        item,\n        `${path}.all[${index}]`,\n      );\n      errors.push(...nestedErrors);\n    });\n  }\n\n  return errors;\n}\n\n/**\n * Infer job mode from filename\n */\nfunction inferModeFromFilename(filename) {\n  if (filename.endsWith(\".cron.mjs\")) return \"cron\";\n  if (filename.endsWith(\".evt.mjs\")) return \"event\";\n  return \"on-demand\";\n}\n\n/**\n * Infer job ID from file path\n */\nfunction inferIdFromPath(filePath, jobsDir = \"jobs\") {\n  // Handle both absolute and relative paths\n  const cwd = process.cwd();\n  const jobsDirPath = join(cwd, jobsDir);\n\n  // If filePath is relative to jobsDir, use it directly\n  if (filePath.includes(jobsDir)) {\n    const relativePath = filePath.split(jobsDir + \"/\")[1];\n    if (relativePath) {\n      const withoutExt = relativePath.replace(/\\.(mjs|js|ts)$/, \"\");\n      const withoutMode = withoutExt.replace(/\\.(cron|evt)$/, \"\");\n      return withoutMode.replace(/\\//g, \":\");\n    }\n  }\n\n  // Fallback: use filename only\n  const filename = basename(filePath, extname(filePath));\n  const withoutMode = filename.replace(/\\.(cron|evt)$/, \"\");\n  return withoutMode;\n}\n\n/**\n * Define and validate a job\n * @param {Object} definition - Job definition object\n * @param {Object} options - Additional options\n * @returns {Object} Validated and frozen job definition\n */\nexport function defineJob(definition, options = {}) {\n  const errors = [];\n\n  // Validate main job schema\n  const schemaErrors = validateSchema(definition, JOB_SCHEMA);\n  errors.push(...schemaErrors);\n\n  // Validate event predicates if present\n  if (definition.on) {\n    const eventErrors = validateEventPredicate(definition.on);\n    errors.push(...eventErrors);\n  }\n\n  // Validate cron expression if present\n  if (definition.cron) {\n    // Basic cron validation (5 or 6 fields)\n    const cronParts = definition.cron.trim().split(/\\s+/);\n    if (cronParts.length < 5 || cronParts.length > 6) {\n      errors.push(\"cron must have 5 or 6 space-separated fields\");\n    }\n  }\n\n  // Validate meta object structure (allow additional keys for flexibility)\n  if (definition.meta && typeof definition.meta !== \"object\") {\n    errors.push(\"meta must be an object\");\n  }\n\n  if (errors.length > 0) {\n    throw new Error(`Job definition validation failed:\\n${errors.join(\"\\n\")}`);\n  }\n\n  // Create validated job definition\n  const jobDef = {\n    id: definition.id || options.inferredId,\n    kind: definition.kind || \"atomic\",\n    cron: definition.cron,\n    meta: definition.meta || {},\n    on: definition.on,\n    run: definition.run,\n    mode: options.mode || inferModeFromFilename(options.filename || \"\"),\n    filename: options.filename,\n    filePath: options.filePath,\n    version: options.version || \"1.0.0\",\n  };\n\n  // Freeze the definition to prevent modification\n  return Object.freeze(klona(jobDef));\n}\n\n/**\n * Create a job definition with inferred properties\n * @param {Object} definition - Job definition\n * @param {string} filePath - Full file path\n * @param {string} jobsDir - Jobs directory (default: \"jobs\")\n * @returns {Object} Complete job definition\n */\nexport function createJobDefinition(definition, filePath, jobsDir = \"jobs\") {\n  const filename = filePath.split(\"/\").pop();\n  const inferredId = inferIdFromPath(filePath, jobsDir);\n  const mode = inferModeFromFilename(filename);\n\n  return defineJob(definition, {\n    inferredId,\n    filename,\n    filePath,\n    mode,\n  });\n}\n\n/**\n * Validate job execution context\n * @param {Object} ctx - Execution context\n * @returns {Object} Validated context\n */\nexport function validateJobContext(ctx) {\n  const required = [\"id\", \"root\", \"nowISO\", \"env\", \"git\", \"logger\"];\n  const missing = required.filter((key) => !(key in ctx));\n\n  if (missing.length > 0) {\n    throw new Error(\n      `Job context missing required fields: ${missing.join(\", \")}`,\n    );\n  }\n\n  if (typeof ctx.git !== \"object\" || !ctx.git.head || !ctx.git.branch) {\n    throw new Error(\n      \"Job context git object must have head and branch properties\",\n    );\n  }\n\n  if (typeof ctx.logger !== \"object\" || typeof ctx.logger.log !== \"function\") {\n    throw new Error(\"Job context logger must have log method\");\n  }\n\n  return ctx;\n}\n\n/**\n * Create job execution context\n * @param {Object} jobDef - Job definition\n * @param {Object} options - Context options\n * @returns {Object} Execution context\n */\nexport function createJobContext(jobDef, options = {}) {\n  const ctx = {\n    id: jobDef.id,\n    root: options.root || process.cwd(),\n    nowISO: options.nowISO || new Date().toISOString(),\n    env: options.env || process.env,\n    git: options.git || {},\n    trigger: options.trigger,\n    logger: options.logger || console,\n    payload: options.payload || {},\n  };\n\n  return validateJobContext(ctx);\n}\n"
        }
    ]
}