{
    "sourceFile": "src/router/events.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758072791806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758072791806,
            "name": "Commit-0",
            "content": "/**\n * GitVan v2 Event Router - High-level event predicate matching orchestrator\n * Combines all matchers and handles complex predicate logic (any/all)\n */\n\nimport * as PathMatchers from \"./matchers/path.mjs\";\nimport * as TagMatchers from \"./matchers/tag.mjs\";\nimport * as MergeMatchers from \"./matchers/merge.mjs\";\nimport * as CommitMatchers from \"./matchers/commit.mjs\";\n\n// Registry of all available matchers\nconst matchers = {\n  // Path matchers\n  pathChanged: PathMatchers.pathChanged,\n  pathAdded: PathMatchers.pathAdded,\n  pathModified: PathMatchers.pathModified,\n  pathDeleted: PathMatchers.pathDeleted,\n  \n  // Tag matchers\n  tagCreate: TagMatchers.tagCreate,\n  semverTag: TagMatchers.semverTag,\n  tagPrefix: TagMatchers.tagPrefix,\n  tagSuffix: TagMatchers.tagSuffix,\n  \n  // Merge matchers\n  mergeTo: MergeMatchers.mergeTo,\n  branchCreate: MergeMatchers.branchCreate,\n  mergeFrom: MergeMatchers.mergeFrom,\n  pullRequest: MergeMatchers.pullRequest,\n  \n  // Commit matchers\n  message: CommitMatchers.message,\n  authorEmail: CommitMatchers.authorEmail,\n  authorName: CommitMatchers.authorName,\n  signed: CommitMatchers.signed,\n  commitType: CommitMatchers.commitType,\n  commitScope: CommitMatchers.commitScope,\n};\n\n/**\n * Check if event metadata matches the given predicate\n * @param {object} predicate - Event predicate object\n * @param {object} meta - Event metadata\n * @returns {boolean} True if predicate matches\n */\nexport function matches(predicate, meta) {\n  if (!predicate || typeof predicate !== \"object\") {\n    return false;\n  }\n  \n  // Handle 'any' logic - any of the sub-predicates must match\n  if (predicate.any?.length) {\n    return predicate.any.some(subPred => matches(subPred, meta));\n  }\n  \n  // Handle 'all' logic - all sub-predicates must match\n  if (predicate.all?.length) {\n    return predicate.all.every(subPred => matches(subPred, meta));\n  }\n  \n  // Check individual matchers\n  for (const [key, value] of Object.entries(predicate)) {\n    if (key === \"any\" || key === \"all\") continue;\n    \n    const matcher = matchers[key];\n    if (matcher) {\n      const subPred = { [key]: value };\n      if (matcher(subPred, meta)) {\n        return true;\n      }\n    }\n  }\n  \n  // If only 'all' array was present and all passed, it's a match\n  return !!predicate.all?.length;\n}\n\n/**\n * Get list of all available matcher names\n * @returns {Array<string>} Array of matcher names\n */\nexport function getAvailableMatchers() {\n  return Object.keys(matchers);\n}\n\n/**\n * Validate predicate structure\n * @param {object} predicate - Predicate to validate\n * @returns {object} Validation result with isValid and errors\n */\nexport function validatePredicate(predicate) {\n  const errors = [];\n  \n  if (!predicate || typeof predicate !== \"object\") {\n    errors.push(\"Predicate must be an object\");\n    return { isValid: false, errors };\n  }\n  \n  // Check for unknown matchers\n  const availableMatchers = getAvailableMatchers();\n  for (const key of Object.keys(predicate)) {\n    if (key === \"any\" || key === \"all\") continue;\n    if (!availableMatchers.includes(key)) {\n      errors.push(`Unknown matcher: ${key}`);\n    }\n  }\n  \n  // Validate 'any' and 'all' arrays\n  if (predicate.any && !Array.isArray(predicate.any)) {\n    errors.push(\"'any' must be an array\");\n  }\n  if (predicate.all && !Array.isArray(predicate.all)) {\n    errors.push(\"'all' must be an array\");\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n"
        }
    ]
}