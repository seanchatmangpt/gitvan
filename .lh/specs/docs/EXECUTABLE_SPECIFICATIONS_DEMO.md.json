{
    "sourceFile": "specs/docs/EXECUTABLE_SPECIFICATIONS_DEMO.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758039643792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758039643792,
            "name": "Commit-0",
            "content": "# GitVan v2 Executable Specifications\n\n## Overview\n\nThis document demonstrates what executable specifications would look like for all GitVan v2 components, following the SDD methodology. These are **documentation-only** examples showing exactly what the executable test scenarios would be.\n\n## Core System Executable Specifications\n\n### 1. Job Definition System\n\n```javascript\n// specs/001-gitvan-v2-core/EXECUTABLE_TESTS.md\n\ndescribe('Job Definition System', () => {\n  describe('defineJob() Function', () => {\n    test('should create valid job objects with metadata', () => {\n      // Given: A job definition\n      const jobDef = {\n        kind: 'atomic',\n        meta: { desc: 'Test job', tags: ['test'] },\n        run: () => ({ ok: true })\n      }\n      \n      // When: Creating a job\n      const job = defineJob(jobDef)\n      \n      // Then: Job should have correct structure\n      expect(job.kind).toBe('atomic')\n      expect(job.meta.desc).toBe('Test job')\n      expect(job.meta.tags).toEqual(['test'])\n      expect(typeof job.run).toBe('function')\n    })\n    \n    test('should validate job kind', () => {\n      // Given: Invalid job kind\n      const invalidJob = { kind: 'invalid', run: () => ({}) }\n      \n      // When: Creating job\n      // Then: Should throw validation error\n      expect(() => defineJob(invalidJob)).toThrow('Invalid job kind: invalid')\n    })\n    \n    test('should extract metadata without execution', () => {\n      // Given: Job with metadata\n      const job = defineJob({\n        kind: 'composite',\n        meta: { desc: 'Composite job', schedule: '0 2 * * *' },\n        steps: []\n      })\n      \n      // When: Extracting metadata\n      const metadata = extractJobMetadata(job)\n      \n      // Then: Should return metadata only\n      expect(metadata).toEqual({\n        kind: 'composite',\n        desc: 'Composite job',\n        schedule: '0 2 * * *'\n      })\n    })\n  })\n  \n  describe('Job Discovery', () => {\n    test('should discover jobs from filesystem', async () => {\n      // Given: Repository with jobs\n      const repo = await createTestRepo({\n        'jobs/example.mjs': `\n          export default defineJob({\n            kind: 'atomic',\n            meta: { desc: 'Example job' },\n            run: () => ({ ok: true })\n          })\n        `,\n        'jobs/composite.mjs': `\n          export default defineJob({\n            kind: 'composite',\n            meta: { desc: 'Composite job' },\n            steps: []\n          })\n        `\n      })\n      \n      // When: Discovering jobs\n      const jobs = await discoverJobs(repo.root)\n      \n      // Then: Should find all jobs\n      expect(jobs).toHaveLength(2)\n      expect(jobs.find(j => j.name === 'example')).toBeDefined()\n      expect(jobs.find(j => j.name === 'composite')).toBeDefined()\n    })\n    \n    test('should filter jobs by kind', async () => {\n      // Given: Jobs of different kinds\n      const jobs = await discoverJobs(repo.root)\n      \n      // When: Filtering by kind\n      const atomicJobs = filterJobsByKind(jobs, 'atomic')\n      const compositeJobs = filterJobsByKind(jobs, 'composite')\n      \n      // Then: Should return correct jobs\n      expect(atomicJobs).toHaveLength(1)\n      expect(compositeJobs).toHaveLength(1)\n    })\n  })\n  \n  describe('Performance Contracts', () => {\n    test('job discovery should complete within 500ms', async () => {\n      // Given: Large repository with 1000 jobs\n      const repo = await createLargeTestRepo(1000)\n      \n      // When: Discovering jobs\n      const start = performance.now()\n      await discoverJobs(repo.root)\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 500ms\n      expect(duration).toBeLessThan(500)\n    })\n    \n    test('metadata extraction should complete within 10ms', () => {\n      // Given: Job with metadata\n      const job = defineJob({\n        kind: 'atomic',\n        meta: { desc: 'Test', tags: ['a', 'b', 'c'] },\n        run: () => ({})\n      })\n      \n      // When: Extracting metadata\n      const start = performance.now()\n      extractJobMetadata(job)\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 10ms\n      expect(duration).toBeLessThan(10)\n    })\n  })\n  \n  describe('Security Contracts', () => {\n    test('should prevent code injection in job definitions', () => {\n      // Given: Malicious job definition\n      const maliciousJob = {\n        kind: 'atomic',\n        meta: { desc: '{{7*7}}' },\n        run: () => ({})\n      }\n      \n      // When: Creating job\n      const job = defineJob(maliciousJob)\n      \n      // Then: Should sanitize metadata\n      expect(job.meta.desc).toBe('{{7*7}}') // Should not evaluate\n    })\n    \n    test('should validate job file permissions', async () => {\n      // Given: Job file with restricted permissions\n      const restrictedFile = 'jobs/restricted.mjs'\n      \n      // When: Loading job\n      // Then: Should throw permission error\n      await expect(loadJobFile(restrictedFile)).rejects.toThrow('Access denied')\n    })\n  })\n})\n```\n\n### 2. Composables System\n\n```javascript\n// specs/002-composables-system/EXECUTABLE_TESTS.md\n\ndescribe('Composables System', () => {\n  describe('useGit() Composable', () => {\n    test('should provide git operations', () => {\n      // Given: GitVan context\n      const context = createTestContext({\n        root: '/test/repo',\n        head: 'abc123',\n        branch: 'main'\n      })\n      \n      // When: Using git composable\n      const git = useGit()\n      \n      // Then: Should have git operations\n      expect(git.root).toBe('/test/repo')\n      expect(git.head()).toBe('abc123')\n      expect(git.branch()).toBe('main')\n      expect(typeof git.run).toBe('function')\n      expect(typeof git.note).toBe('function')\n    })\n    \n    test('should execute git commands', () => {\n      // Given: Git composable\n      const git = useGit()\n      \n      // When: Running git command\n      const result = git.run('log --oneline -5')\n      \n      // Then: Should return command output\n      expect(typeof result).toBe('string')\n      expect(result).toContain('commit')\n    })\n    \n    test('should manage git notes', () => {\n      // Given: Git composable\n      const git = useGit()\n      \n      // When: Adding note\n      git.note('refs/notes/test', 'test note')\n      \n      // Then: Should be able to read note\n      const note = git.run('notes show refs/notes/test')\n      expect(note).toBe('test note')\n    })\n  })\n  \n  describe('useTemplate() Composable', () => {\n    test('should render templates with context', () => {\n      // Given: Template composable\n      const template = useTemplate()\n      \n      // When: Rendering template\n      const result = template.render('Hello {{ name }}!', { name: 'GitVan' })\n      \n      // Then: Should render correctly\n      expect(result).toBe('Hello GitVan!')\n    })\n    \n    test('should inject git context automatically', () => {\n      // Given: Template with git context\n      const template = useTemplate()\n      \n      // When: Rendering template\n      const result = template.render('Branch: {{ git.branch() }}')\n      \n      // Then: Should include git context\n      expect(result).toContain('Branch: main')\n    })\n    \n    test('should render to file', () => {\n      // Given: Template composable\n      const template = useTemplate()\n      \n      // When: Rendering to file\n      const result = template.renderToFile(\n        'test.njk',\n        'output.txt',\n        { message: 'Hello World' }\n      )\n      \n      // Then: Should create file\n      expect(result.path).toBe('output.txt')\n      expect(result.bytes).toBeGreaterThan(0)\n    })\n  })\n  \n  describe('useExec() Composable', () => {\n    test('should execute CLI commands', async () => {\n      // Given: Exec composable\n      const exec = useExec()\n      \n      // When: Running CLI command\n      const result = exec.cli('echo', ['hello'])\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toBe('hello\\n')\n    })\n    \n    test('should execute JavaScript modules', async () => {\n      // Given: Exec composable\n      const exec = useExec()\n      \n      // When: Running JS module\n      const result = await exec.js('./test-module.mjs', 'default', { input: 'test' })\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toContain('test')\n    })\n    \n    test('should execute templates', () => {\n      // Given: Exec composable\n      const exec = useExec()\n      \n      // When: Running template\n      const result = exec.tmpl({\n        template: 'test.njk',\n        data: { name: 'GitVan' }\n      })\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toContain('GitVan')\n    })\n  })\n  \n  describe('Context Management', () => {\n    test('should provide context isolation', async () => {\n      // Given: Two different contexts\n      const context1 = createTestContext({ branch: 'feature-1' })\n      const context2 = createTestContext({ branch: 'feature-2' })\n      \n      // When: Using composables in different contexts\n      const result1 = await withGitVan(context1, () => useGit().branch())\n      const result2 = await withGitVan(context2, () => useGit().branch())\n      \n      // Then: Should have different results\n      expect(result1).toBe('feature-1')\n      expect(result2).toBe('feature-2')\n    })\n    \n    test('should handle nested context calls', async () => {\n      // Given: GitVan context\n      const context = createTestContext({ branch: 'main' })\n      \n      // When: Nested context calls\n      const result = await withGitVan(context, async () => {\n        return await withGitVan(context, () => {\n          return useGit().branch()\n        })\n      })\n      \n      // Then: Should work correctly\n      expect(result).toBe('main')\n    })\n  })\n  \n  describe('Performance Contracts', () => {\n    test('context initialization should complete within 50ms', () => {\n      // Given: Context creation\n      const start = performance.now()\n      const context = createTestContext()\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 50ms\n      expect(duration).toBeLessThan(50)\n    })\n    \n    test('composable access should complete within 10ms', () => {\n      // Given: Context\n      const context = createTestContext()\n      \n      // When: Accessing composable\n      const start = performance.now()\n      const git = useGit()\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 10ms\n      expect(duration).toBeLessThan(10)\n    })\n  })\n})\n```\n\n### 3. Template Engine\n\n```javascript\n// specs/003-template-engine/EXECUTABLE_TESTS.md\n\ndescribe('Template Engine', () => {\n  describe('Nunjucks Integration', () => {\n    test('should render templates with Nunjucks syntax', () => {\n      // Given: Template with Nunjucks syntax\n      const template = 'Hello {{ name }}! {% if show %}World{% endif %}'\n      \n      // When: Rendering template\n      const result = renderTemplate(template, { name: 'GitVan', show: true })\n      \n      // Then: Should render correctly\n      expect(result).toBe('Hello GitVan! World')\n    })\n    \n    test('should support template inheritance', () => {\n      // Given: Base template and child template\n      const baseTemplate = 'Base: {% block content %}{% endblock %}'\n      const childTemplate = '{% extends \"base\" %}{% block content %}Child content{% endblock %}'\n      \n      // When: Rendering child template\n      const result = renderTemplate(childTemplate, {})\n      \n      // Then: Should render with inheritance\n      expect(result).toBe('Base: Child content')\n    })\n    \n    test('should support macros', () => {\n      // Given: Template with macro\n      const template = `\n        {% macro greet(name) %}Hello {{ name }}!{% endmacro %}\n        {{ greet('GitVan') }}\n      `\n      \n      // When: Rendering template\n      const result = renderTemplate(template, {})\n      \n      // Then: Should render macro\n      expect(result.trim()).toBe('Hello GitVan!')\n    })\n  })\n  \n  describe('Git Context Injection', () => {\n    test('should inject git context automatically', () => {\n      // Given: Template with git context\n      const template = 'Branch: {{ git.branch() }}, Head: {{ git.head() }}'\n      \n      // When: Rendering template\n      const result = renderTemplate(template, {})\n      \n      // Then: Should include git context\n      expect(result).toContain('Branch: main')\n      expect(result).toContain('Head: abc123')\n    })\n    \n    test('should provide deterministic helpers', () => {\n      // Given: Template with helpers\n      const template = 'Now: {{ nowISO }}, Format: {{ formatDate(nowISO) }}'\n      \n      // When: Rendering template\n      const result = renderTemplate(template, {})\n      \n      // Then: Should provide helpers\n      expect(result).toContain('Now: 2024-01-01T00:00:00.000Z')\n      expect(result).toContain('Format: 2024-01-01')\n    })\n  })\n  \n  describe('File Output', () => {\n    test('should render template to file', () => {\n      // Given: Template and output path\n      const template = 'Hello {{ name }}!'\n      const outputPath = 'output.txt'\n      \n      // When: Rendering to file\n      const result = renderToFile(template, outputPath, { name: 'GitVan' })\n      \n      // Then: Should create file\n      expect(result.path).toBe(outputPath)\n      expect(result.bytes).toBeGreaterThan(0)\n      \n      // And: File should contain correct content\n      const content = readFile(outputPath)\n      expect(content).toBe('Hello GitVan!')\n    })\n    \n    test('should handle file permissions', () => {\n      // Given: Restricted output path\n      const template = 'Test content'\n      const restrictedPath = '/restricted/output.txt'\n      \n      // When: Rendering to restricted path\n      // Then: Should throw permission error\n      expect(() => renderToFile(template, restrictedPath, {})).toThrow('Permission denied')\n    })\n  })\n  \n  describe('Performance Contracts', () => {\n    test('template rendering should exceed 1000 templates/second', () => {\n      // Given: Simple template\n      const template = 'Hello {{ name }}!'\n      const data = { name: 'GitVan' }\n      \n      // When: Rendering many templates\n      const start = performance.now()\n      for (let i = 0; i < 1000; i++) {\n        renderTemplate(template, data)\n      }\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 1 second\n      expect(duration).toBeLessThan(1000)\n    })\n    \n    test('template compilation should complete within 10ms', () => {\n      // Given: Complex template\n      const template = `\n        {% for item in items %}\n          <div>{{ item.name }}: {{ item.value }}</div>\n        {% endfor %}\n      `\n      \n      // When: Compiling template\n      const start = performance.now()\n      const compiled = compileTemplate(template)\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 10ms\n      expect(duration).toBeLessThan(10)\n      expect(compiled).toBeDefined()\n    })\n  })\n  \n  describe('Security Contracts', () => {\n    test('should prevent template injection', () => {\n      // Given: Malicious input\n      const template = 'Hello {{ user_input }}!'\n      const maliciousInput = '{{7*7}}'\n      \n      // When: Rendering template\n      const result = renderTemplate(template, { user_input: maliciousInput })\n      \n      // Then: Should not evaluate malicious input\n      expect(result).toBe('Hello {{7*7}}!')\n    })\n    \n    test('should escape HTML by default', () => {\n      // Given: Template with HTML\n      const template = 'Content: {{ html_content }}'\n      const htmlContent = '<script>alert(\"xss\")</script>'\n      \n      // When: Rendering template\n      const result = renderTemplate(template, { html_content: htmlContent })\n      \n      // Then: Should escape HTML\n      expect(result).toBe('Content: &lt;script&gt;alert(\"xss\")&lt;/script&gt;')\n    })\n    \n    test('should allow HTML when explicitly enabled', () => {\n      // Given: Template with HTML autoescape disabled\n      const template = 'Content: {{ html_content }}'\n      const htmlContent = '<strong>Bold text</strong>'\n      \n      // When: Rendering template with autoescape disabled\n      const result = renderTemplate(template, { html_content: htmlContent }, { autoescape: false })\n      \n      // Then: Should not escape HTML\n      expect(result).toBe('Content: <strong>Bold text</strong>')\n    })\n  })\n})\n```\n\n## Execution Types Executable Specifications\n\n### 4. Execution Engine\n\n```javascript\n// specs/004-execution-types/EXECUTABLE_TESTS.md\n\ndescribe('Execution Engine', () => {\n  describe('CLI Execution', () => {\n    test('should execute CLI commands', async () => {\n      // Given: CLI execution spec\n      const spec = {\n        exec: 'cli',\n        cmd: 'echo',\n        args: ['hello', 'world'],\n        timeout: 5000\n      }\n      \n      // When: Executing CLI\n      const result = await executeCli(spec)\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toBe('hello world\\n')\n      expect(result.code).toBe(0)\n    })\n    \n    test('should handle CLI errors', async () => {\n      // Given: Failing CLI command\n      const spec = {\n        exec: 'cli',\n        cmd: 'false',\n        timeout: 5000\n      }\n      \n      // When: Executing CLI\n      const result = await executeCli(spec)\n      \n      // Then: Should return error\n      expect(result.ok).toBe(false)\n      expect(result.code).toBe(1)\n    })\n    \n    test('should respect timeout', async () => {\n      // Given: Long-running command\n      const spec = {\n        exec: 'cli',\n        cmd: 'sleep',\n        args: ['10'],\n        timeout: 1000\n      }\n      \n      // When: Executing CLI\n      const result = await executeCli(spec)\n      \n      // Then: Should timeout\n      expect(result.ok).toBe(false)\n      expect(result.error).toContain('timeout')\n    })\n  })\n  \n  describe('JavaScript Execution', () => {\n    test('should execute JavaScript modules', async () => {\n      // Given: JS execution spec\n      const spec = {\n        exec: 'js',\n        module: './test-module.mjs',\n        export: 'default',\n        input: { message: 'hello' }\n      }\n      \n      // When: Executing JS\n      const result = await executeJs(spec)\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toContain('hello')\n    })\n    \n    test('should handle module errors', async () => {\n      // Given: Invalid module\n      const spec = {\n        exec: 'js',\n        module: './invalid-module.mjs',\n        export: 'default'\n      }\n      \n      // When: Executing JS\n      const result = await executeJs(spec)\n      \n      // Then: Should return error\n      expect(result.ok).toBe(false)\n      expect(result.error).toContain('Module not found')\n    })\n  })\n  \n  describe('Template Execution', () => {\n    test('should execute templates', () => {\n      // Given: Template execution spec\n      const spec = {\n        exec: 'tmpl',\n        template: 'test.njk',\n        data: { name: 'GitVan' },\n        out: 'output.txt'\n      }\n      \n      // When: Executing template\n      const result = executeTemplate(spec)\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.artifact).toBe('output.txt')\n    })\n  })\n  \n  describe('Job Execution', () => {\n    test('should execute jobs recursively', async () => {\n      // Given: Job execution spec\n      const spec = {\n        exec: 'job',\n        name: 'test-job'\n      }\n      \n      // When: Executing job\n      const result = await executeJob(spec)\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.meta).toBeDefined()\n    })\n  })\n  \n  describe('LLM Execution', () => {\n    test('should execute LLM requests', async () => {\n      // Given: LLM execution spec\n      const spec = {\n        exec: 'llm',\n        model: 'test-model',\n        prompt: 'Generate test output',\n        options: { temperature: 0.7 }\n      }\n      \n      // When: Executing LLM\n      const result = await executeLlm(spec)\n      \n      // Then: Should return result\n      expect(result.ok).toBe(true)\n      expect(result.stdout).toBeDefined()\n    })\n  })\n  \n  describe('Unified Result Format', () => {\n    test('should return consistent result format', async () => {\n      // Given: Different execution types\n      const specs = [\n        { exec: 'cli', cmd: 'echo', args: ['test'] },\n        { exec: 'js', module: './test.mjs' },\n        { exec: 'tmpl', template: 'test.njk' },\n        { exec: 'job', name: 'test-job' },\n        { exec: 'llm', model: 'test', prompt: 'test' }\n      ]\n      \n      // When: Executing all types\n      const results = await Promise.all(specs.map(execute))\n      \n      // Then: All should have consistent format\n      results.forEach(result => {\n        expect(result).toHaveProperty('ok')\n        expect(result).toHaveProperty('stdout')\n        expect(result).toHaveProperty('meta')\n      })\n    })\n  })\n  \n  describe('Performance Contracts', () => {\n    test('simple job execution should complete within 100ms', async () => {\n      // Given: Simple job\n      const spec = { exec: 'cli', cmd: 'echo', args: ['test'] }\n      \n      // When: Executing job\n      const start = performance.now()\n      await execute(spec)\n      const duration = performance.now() - start\n      \n      // Then: Should complete within 100ms\n      expect(duration).toBeLessThan(100)\n    })\n  })\n})\n```\n\n## Worktree Daemon Executable Specifications\n\n### 5. Worktree Daemon\n\n```javascript\n// specs/005-worktree-daemon/EXECUTABLE_TESTS.md\n\ndescribe('Worktree Daemon', () => {\n  describe('Daemon Process Management', () => {\n    test('should start daemon process', async () => {\n      // Given: Daemon configuration\n      const config = {\n        worktrees: ['main', 'feature-1'],\n        pollInterval: 1000,\n        maxJobs: 50\n      }\n      \n      // When: Starting daemon\n      const daemon = await startDaemon(config)\n      \n      // Then: Should be running\n      expect(daemon.isRunning()).toBe(true)\n      expect(daemon.getWorktrees()).toEqual(['main', 'feature-1'])\n    })\n    \n    test('should stop daemon gracefully', async () => {\n      // Given: Running daemon\n      const daemon = await startDaemon({})\n      \n      // When: Stopping daemon\n      await daemon.stop()\n      \n      // Then: Should be stopped\n      expect(daemon.isRunning()).toBe(false)\n    })\n    \n    test('should handle daemon crashes', async () => {\n      // Given: Daemon with crash simulation\n      const daemon = await startDaemon({ crashSimulation: true })\n      \n      // When: Simulating crash\n      daemon.simulateCrash()\n      \n      // Then: Should recover gracefully\n      await waitForRecovery()\n      expect(daemon.isRunning()).toBe(true)\n    })\n  })\n  \n  describe('Commit Polling', () => {\n    test('should detect new commits', async () => {\n      // Given: Daemon and repository\n      const daemon = await startDaemon({})\n      const repo = await createTestRepo()\n      \n      // When: Making new commit\n      await makeCommit(repo, 'feat: new feature')\n      \n      // Then: Should detect commit\n      await waitForPolling()\n      const commits = daemon.getNewCommits()\n      expect(commits).toHaveLength(1)\n      expect(commits[0].message).toBe('feat: new feature')\n    })\n    \n    test('should respect polling interval', async () => {\n      // Given: Daemon with 1s polling\n      const daemon = await startDaemon({ pollInterval: 1000 })\n      \n      // When: Monitoring polling\n      const start = Date.now()\n      await waitForPolling()\n      const duration = Date.now() - start\n      \n      // Then: Should poll within interval\n      expect(duration).toBeGreaterThanOrEqual(1000)\n      expect(duration).toBeLessThan(1100)\n    })\n  })\n  \n  describe('Distributed Locking', () => {\n    test('should acquire locks atomically', async () => {\n      // Given: Multiple daemon instances\n      const daemon1 = await startDaemon({ worktrees: ['main'] })\n      const daemon2 = await startDaemon({ worktrees: ['main'] })\n      \n      // When: Both try to acquire same lock\n      const lock1 = await daemon1.acquireLock('test-lock')\n      const lock2 = await daemon2.acquireLock('test-lock')\n      \n      // Then: Only one should succeed\n      expect(lock1.acquired).toBe(true)\n      expect(lock2.acquired).toBe(false)\n    })\n    \n    test('should release locks on completion', async () => {\n      // Given: Acquired lock\n      const daemon = await startDaemon({})\n      const lock = await daemon.acquireLock('test-lock')\n      \n      // When: Releasing lock\n      await lock.release()\n      \n      // Then: Lock should be released\n      expect(lock.isReleased()).toBe(true)\n    })\n    \n    test('should handle lock timeouts', async () => {\n      // Given: Lock with timeout\n      const daemon = await startDaemon({ lockTimeout: 1000 })\n      const lock = await daemon.acquireLock('test-lock')\n      \n      // When: Waiting for timeout\n      await waitForTimeout(1100)\n      \n      // Then: Lock should timeout\n      expect(lock.isExpired()).toBe(true)\n    })\n  })\n  \n  describe('Worktree Isolation', () => {\n    test('should isolate execution per worktree', async () => {\n      // Given: Daemon with multiple worktrees\n      const daemon = await startDaemon({\n        worktrees: ['main', 'feature-1', 'feature-2']\n      })\n      \n      // When: Executing jobs in different worktrees\n      const results = await Promise.all([\n        daemon.executeJob('test-job', 'main'),\n        daemon.executeJob('test-job', 'feature-1'),\n        daemon.executeJob('test-job', 'feature-2')\n      ])\n      \n      // Then: Should execute independently\n      results.forEach(result => {\n        expect(result.ok).toBe(true)\n        expect(result.worktree).toBeDefined()\n      })\n    })\n    \n    test('should scope locks per worktree', async () => {\n      // Given: Daemon with multiple worktrees\n      const daemon = await startDaemon({\n        worktrees: ['main', 'feature-1']\n      })\n      \n      // When: Acquiring locks in different worktrees\n      const lock1 = await daemon.acquireLock('test-lock', 'main')\n      const lock2 = await daemon.acquireLock('test-lock', 'feature-1')\n      \n      // Then: Both should succeed (different worktrees)\n      expect(lock1.acquired).toBe(true)\n      expect(lock2.acquired).toBe(true)\n    })\n  })\n  \n  describe('Rate Limiting', () => {\n    test('should respect job rate limits', async () => {\n      // Given: Daemon with rate limit\n      const daemon = await startDaemon({ maxJobsPerTick: 10 })\n      \n      // When: Executing many jobs\n      const jobs = Array(20).fill().map((_, i) => \n        daemon.executeJob(`job-${i}`)\n      )\n      \n      // Then: Should respect rate limit\n      const results = await Promise.all(jobs)\n      const successful = results.filter(r => r.ok).length\n      expect(successful).toBeLessThanOrEqual(10)\n    })\n  })\n  \n  describe('Performance Contracts', () => {\n    test('daemon memory usage should stay under 50MB', async () => {\n      // Given: Running daemon\n      const daemon = await startDaemon({})\n      \n      // When: Running for extended period\n      await runExtendedTest(30000) // 30 seconds\n      \n      // Then: Memory usage should be under limit\n      const memoryUsage = daemon.getMemoryUsage()\n      expect(memoryUsage).toBeLessThan(50 * 1024 * 1024) // 50MB\n    })\n    \n    test('lock contention should resolve within 1 second', async () => {\n      // Given: Contending locks\n      const daemon1 = await startDaemon({})\n      const daemon2 = await startDaemon({})\n      \n      // When: Contending for lock\n      const start = performance.now()\n      const lock1 = await daemon1.acquireLock('contention-lock')\n      const lock2 = await daemon2.acquireLock('contention-lock')\n      const duration = performance.now() - start\n      \n      // Then: Should resolve within 1 second\n      expect(duration).toBeLessThan(1000)\n    })\n  })\n})\n```\n\n## Cross-Cutting Concerns Executable Specifications\n\n### 6. Cross-Cutting Concerns\n\n```javascript\n// specs/006-cross-cutting-concerns/EXECUTABLE_TESTS.md\n\ndescribe('Cross-Cutting Concerns', () => {\n  describe('Error Handling', () => {\n    test('should handle network failures gracefully', async () => {\n      // Given: Network failure simulation\n      const networkFailure = simulateNetworkFailure()\n      \n      // When: Executing job with network dependency\n      const result = await executeJob('network-job')\n      \n      // Then: Should handle failure gracefully\n      expect(result.ok).toBe(false)\n      expect(result.error).toContain('Network error')\n      expect(result.retryable).toBe(true)\n    })\n    \n    test('should handle file system errors', async () => {\n      // Given: File system error simulation\n      const fsError = simulateFileSystemError()\n      \n      // When: Executing file operation\n      const result = await executeJob('file-job')\n      \n      // Then: Should handle error gracefully\n      expect(result.ok).toBe(false)\n      expect(result.error).toContain('File system error')\n    })\n    \n    test('should implement retry logic', async () => {\n      // Given: Flaky operation\n      const flakyOp = createFlakyOperation(0.5) // 50% failure rate\n      \n      // When: Executing with retry\n      const result = await executeWithRetry(flakyOp, { maxRetries: 3 })\n      \n      // Then: Should eventually succeed\n      expect(result.ok).toBe(true)\n      expect(result.attempts).toBeGreaterThan(1)\n    })\n  })\n  \n  describe('Logging', () => {\n    test('should provide structured logging', () => {\n      // Given: Logger\n      const logger = createLogger()\n      \n      // When: Logging events\n      logger.info('Job started', { jobId: '123', worktree: 'main' })\n      logger.error('Job failed', { jobId: '123', error: 'Test error' })\n      \n      // Then: Should log structured data\n      const logs = logger.getLogs()\n      expect(logs).toHaveLength(2)\n      expect(logs[0].level).toBe('info')\n      expect(logs[0].message).toBe('Job started')\n      expect(logs[0].jobId).toBe('123')\n    })\n    \n    test('should respect log levels', () => {\n      // Given: Logger with level\n      const logger = createLogger({ level: 'warn' })\n      \n      // When: Logging different levels\n      logger.debug('Debug message')\n      logger.info('Info message')\n      logger.warn('Warning message')\n      logger.error('Error message')\n      \n      // Then: Should only log warn and error\n      const logs = logger.getLogs()\n      expect(logs).toHaveLength(2)\n      expect(logs.every(log => ['warn', 'error'].includes(log.level))).toBe(true)\n    })\n  })\n  \n  describe('Security', () => {\n    test('should validate input sanitization', () => {\n      // Given: Malicious input\n      const maliciousInput = '<script>alert(\"xss\")</script>'\n      \n      // When: Sanitizing input\n      const sanitized = sanitizeInput(maliciousInput)\n      \n      // Then: Should remove dangerous content\n      expect(sanitized).not.toContain('<script>')\n      expect(sanitized).not.toContain('alert')\n    })\n    \n    test('should enforce access control', async () => {\n      // Given: Restricted operation\n      const restrictedOp = createRestrictedOperation()\n      \n      // When: Executing without permission\n      // Then: Should deny access\n      await expect(restrictedOp.execute()).rejects.toThrow('Access denied')\n    })\n    \n    test('should protect sensitive data', () => {\n      // Given: Sensitive data\n      const sensitiveData = { password: 'secret', token: 'abc123' }\n      \n      // When: Logging data\n      const logEntry = createLogEntry(sensitiveData)\n      \n      // Then: Should mask sensitive fields\n      expect(logEntry.password).toBe('***')\n      expect(logEntry.token).toBe('***')\n    })\n  })\n  \n  describe('Performance Monitoring', () => {\n    test('should track performance metrics', async () => {\n      // Given: Performance monitor\n      const monitor = createPerformanceMonitor()\n      \n      // When: Executing operation\n      await monitor.track('job-execution', async () => {\n        await executeJob('test-job')\n      })\n      \n      // Then: Should record metrics\n      const metrics = monitor.getMetrics('job-execution')\n      expect(metrics.count).toBe(1)\n      expect(metrics.duration).toBeGreaterThan(0)\n      expect(metrics.memory).toBeGreaterThan(0)\n    })\n    \n    test('should alert on performance degradation', async () => {\n      // Given: Performance monitor with alerts\n      const monitor = createPerformanceMonitor({\n        thresholds: { duration: 1000, memory: 1000000 }\n      })\n      \n      // When: Executing slow operation\n      await monitor.track('slow-operation', async () => {\n        await sleep(1500) // 1.5 seconds\n      })\n      \n      // Then: Should trigger alert\n      const alerts = monitor.getAlerts()\n      expect(alerts).toHaveLength(1)\n      expect(alerts[0].type).toBe('performance')\n      expect(alerts[0].metric).toBe('duration')\n    })\n  })\n  \n  describe('Resource Management', () => {\n    test('should prevent memory leaks', async () => {\n      // Given: Memory monitor\n      const monitor = createMemoryMonitor()\n      \n      // When: Executing many operations\n      for (let i = 0; i < 1000; i++) {\n        await executeJob(`job-${i}`)\n      }\n      \n      // Then: Memory should not grow unbounded\n      const memoryUsage = monitor.getMemoryUsage()\n      expect(memoryUsage).toBeLessThan(100 * 1024 * 1024) // 100MB\n    })\n    \n    test('should clean up resources', async () => {\n      // Given: Resource manager\n      const manager = createResourceManager()\n      \n      // When: Creating and releasing resources\n      const resource = await manager.createResource()\n      await manager.releaseResource(resource)\n      \n      // Then: Resource should be cleaned up\n      expect(manager.getResourceCount()).toBe(0)\n    })\n  })\n})\n```\n\n## Summary\n\nThis document demonstrates exactly what executable specifications would look like for all GitVan v2 components. Each specification includes:\n\n1. **Comprehensive Test Coverage**: All major functionality covered with executable tests\n2. **Performance Contracts**: Measurable performance requirements with automated validation\n3. **Security Contracts**: Security requirements with automated security testing\n4. **API Contracts**: Clear API specifications with contract validation\n5. **Error Handling**: Comprehensive error scenarios and recovery testing\n\nThe specifications provide a complete picture of what the SDD process would entail, allowing you to evaluate the approach before committing to implementation.\n"
        }
    ]
}