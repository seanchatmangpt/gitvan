{
    "sourceFile": "src/runtime/daemon.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1758057329128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758096593613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import { withGitVan } from \"../composables/ctx.mjs\";\n-import { useGit } from \"../composables/git.mjs\";\n+import { useGit } from \"../composables/git/index.mjs\";\n import { useExec } from \"../composables/exec.mjs\";\n import { acquireLock, worktreeLockRef, releaseLock } from \"./locks.mjs\";\n import { writeReceipt } from \"./receipt.mjs\";\n import { recentShas, sleep, eventFires } from \"./utils.mjs\";\n"
                },
                {
                    "date": 1758097155219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,15 +40,15 @@\n \n   const git = useGit();\n   const wts =\n     sel === \"all\"\n-      ? git.listWorktrees()\n+      ? await git.listWorktrees()\n       : Array.isArray(sel)\n-        ? git.listWorktrees().filter((w) => sel.includes(w.path))\n+        ? (await git.listWorktrees()).filter((w) => sel.includes(w.path))\n         : [\n             {\n-              path: git.worktreeRoot || git.root,\n-              branch: git.branch(),\n+              path: await git.worktreeRoot || await git.root(),\n+              branch: await git.branch(),\n               isMain: true,\n             },\n           ];\n \n@@ -114,9 +114,9 @@\n \n               const git = useGit();\n               const lockRef = worktreeLockRef(\n                 opts.locksRoot || \"refs/gitvan/locks\",\n-                git.worktreeId(),\n+                await git.worktreeId(),\n                 event.id,\n                 sha,\n               );\n \n@@ -145,9 +145,9 @@\n               }\n \n               writeReceipt({\n                 resultsRef: opts.resultsRef || \"refs/notes/gitvan/results\",\n-                id: `${event.id}@${git.worktreeId()}`,\n+                id: `${event.id}@${await git.worktreeId()}`,\n                 status: res.ok ? \"OK\" : \"ERROR\",\n                 commit: sha,\n                 action: event.job ? \"job\" : event.run?.exec || \"unknown\",\n                 result: res,\n"
                },
                {
                    "date": 1758097484101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,10 +45,10 @@\n       : Array.isArray(sel)\n         ? (await git.listWorktrees()).filter((w) => sel.includes(w.path))\n         : [\n             {\n-              path: await git.worktreeRoot || await git.root(),\n-              branch: await git.branch(),\n+              path: await git.worktreeRoot,\n+              branch: await git.currentBranch(),\n               isMain: true,\n             },\n           ];\n \n"
                },
                {
                    "date": 1758142113694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import { useExec } from \"../composables/exec.mjs\";\n import { acquireLock, worktreeLockRef, releaseLock } from \"./locks.mjs\";\n import { writeReceipt } from \"./receipt.mjs\";\n import { recentShas, sleep, eventFires } from \"./utils.mjs\";\n-import { discoverEvents, loadEventDefinition } from \"./events.mjs\";\n+import { discoverHooks, loadHookDefinition } from \"./events.mjs\";\n import { loadConfig } from \"./config.mjs\";\n import { join } from \"pathe\";\n \n /**\n@@ -14,29 +14,29 @@\n export async function startDaemon(opts = {}, registry = null, sel = \"current\") {\n   const config = await loadConfig(opts.rootDir);\n   const mergedOpts = { ...config, ...opts };\n \n-  // Discover events if not provided in registry\n+  // Discover hooks if not provided in registry\n   if (!registry) {\n-    const eventsDir = join(\n+    const hooksDir = join(\n       mergedOpts.rootDir || process.cwd(),\n-      mergedOpts.events.directory,\n+      mergedOpts.hooks?.directory || \"hooks\",\n     );\n-    const eventFiles = discoverEvents(eventsDir);\n-    const events = [];\n+    const hookFiles = discoverHooks(hooksDir);\n+    const hooks = [];\n \n-    for (const eventFile of eventFiles) {\n-      const definition = await loadEventDefinition(eventFile.file);\n+    for (const hookFile of hookFiles) {\n+      const definition = await loadHookDefinition(hookFile.file);\n       if (definition) {\n-        events.push({\n-          ...eventFile,\n+        hooks.push({\n+          ...hookFile,\n           run: definition.run || definition,\n           job: definition.job,\n         });\n       }\n     }\n \n-    registry = { events, jobs: {} };\n+    registry = { hooks, jobs: {} };\n   }\n \n   const git = useGit();\n   const wts =\n@@ -104,68 +104,68 @@\n \n         for (const sha of shas) {\n           if (ran >= maxPerTick) break;\n \n-          for (const event of registry.events) {\n+          for (const hook of registry.hooks) {\n             if (ran >= maxPerTick) break;\n \n             try {\n-              const fires = await eventFires(event, sha);\n+              const fires = await eventFires(hook, sha);\n               if (!fires) continue;\n \n               const git = useGit();\n               const lockRef = worktreeLockRef(\n                 opts.locksRoot || \"refs/gitvan/locks\",\n                 await git.worktreeId(),\n-                event.id,\n+                hook.id,\n                 sha,\n               );\n \n               const acquired = acquireLock(lockRef, sha);\n               if (!acquired) {\n-                console.debug(`Lock already held for ${event.id}@${sha}`);\n+                console.debug(`Lock already held for ${hook.id}@${sha}`);\n                 continue;\n               }\n \n               console.log(\n-                `Processing ${event.id} for commit ${sha.slice(0, 8)}`,\n+                `Processing ${hook.id} for commit ${sha.slice(0, 8)}`,\n               );\n \n               let res;\n-              if (event.job && registry.jobs[event.job]) {\n+              if (hook.job && registry.jobs[hook.job]) {\n                 // Run named job\n-                res = await registry.jobs[event.job].run({\n+                res = await registry.jobs[hook.job].run({\n                   payload: ctx.payload,\n                 });\n-              } else if (event.run) {\n+              } else if (hook.run) {\n                 // Run inline action\n-                res = await runAction(event.run);\n+                res = await runAction(hook.run);\n               } else {\n-                console.warn(`No action defined for event ${event.id}`);\n+                console.warn(`No action defined for hook ${hook.id}`);\n                 continue;\n               }\n \n               writeReceipt({\n                 resultsRef: opts.resultsRef || \"refs/notes/gitvan/results\",\n-                id: `${event.id}@${await git.worktreeId()}`,\n+                id: `${hook.id}@${await git.worktreeId()}`,\n                 status: res.ok ? \"OK\" : \"ERROR\",\n                 commit: sha,\n-                action: event.job ? \"job\" : event.run?.exec || \"unknown\",\n+                action: hook.job ? \"job\" : hook.run?.exec || \"unknown\",\n                 result: res,\n                 artifact: res.artifact,\n                 meta: {\n                   worktree: wt.path,\n                   branch: wt.branch,\n-                  eventType: event.type,\n-                  pattern: event.pattern,\n+                  hookType: hook.type,\n+                  pattern: hook.pattern,\n                 },\n               });\n \n               releaseLock(lockRef);\n               ran++;\n             } catch (err) {\n               console.error(\n-                `Error processing event ${event.id} for ${sha}:`,\n+                `Error processing hook ${hook.id} for ${sha}:`,\n                 err.message,\n               );\n             }\n           }\n"
                }
            ],
            "date": 1758057329128,
            "name": "Commit-0",
            "content": "import { withGitVan } from \"../composables/ctx.mjs\";\nimport { useGit } from \"../composables/git.mjs\";\nimport { useExec } from \"../composables/exec.mjs\";\nimport { acquireLock, worktreeLockRef, releaseLock } from \"./locks.mjs\";\nimport { writeReceipt } from \"./receipt.mjs\";\nimport { recentShas, sleep, eventFires } from \"./utils.mjs\";\nimport { discoverEvents, loadEventDefinition } from \"./events.mjs\";\nimport { loadConfig } from \"./config.mjs\";\nimport { join } from \"pathe\";\n\n/**\n * Start daemon for specified worktrees\n */\nexport async function startDaemon(opts = {}, registry = null, sel = \"current\") {\n  const config = await loadConfig(opts.rootDir);\n  const mergedOpts = { ...config, ...opts };\n\n  // Discover events if not provided in registry\n  if (!registry) {\n    const eventsDir = join(\n      mergedOpts.rootDir || process.cwd(),\n      mergedOpts.events.directory,\n    );\n    const eventFiles = discoverEvents(eventsDir);\n    const events = [];\n\n    for (const eventFile of eventFiles) {\n      const definition = await loadEventDefinition(eventFile.file);\n      if (definition) {\n        events.push({\n          ...eventFile,\n          run: definition.run || definition,\n          job: definition.job,\n        });\n      }\n    }\n\n    registry = { events, jobs: {} };\n  }\n\n  const git = useGit();\n  const wts =\n    sel === \"all\"\n      ? git.listWorktrees()\n      : Array.isArray(sel)\n        ? git.listWorktrees().filter((w) => sel.includes(w.path))\n        : [\n            {\n              path: git.worktreeRoot || git.root,\n              branch: git.branch(),\n              isMain: true,\n            },\n          ];\n\n  console.log(`Starting daemon for ${wts.length} worktree(s)`);\n\n  // Start daemon loop for each worktree\n  const promises = wts.map((wt) => loopWorktree(mergedOpts, registry, wt));\n  await Promise.all(promises);\n}\n\n/**\n * Run an action specification\n */\nasync function runAction(spec) {\n  const exec = useExec();\n\n  switch (spec.exec) {\n    case \"cli\":\n      return exec.cli(spec.cmd, spec.args, spec.env);\n    case \"js\":\n      return await exec.js(spec.module, spec.export, spec.input);\n    case \"tmpl\":\n      return exec.tmpl(spec);\n    default:\n      return { ok: false, error: `Unknown exec type: ${spec.exec}` };\n  }\n}\n\n/**\n * Daemon loop for a single worktree\n */\nasync function loopWorktree(opts, registry, wt) {\n  const ctx = {\n    repoRoot: opts.rootDir,\n    worktreeRoot: wt.path,\n    root: wt.path,\n    env: opts.env || {},\n    now: () => new Date().toISOString(),\n    jobs: registry.jobs,\n    llm: opts.llm,\n    payload: {},\n    worktree: { id: wt.path.replace(/[:/\\\\]/g, \"-\"), branch: wt.branch },\n  };\n\n  console.log(`Starting daemon loop for worktree: ${wt.path} (${wt.branch})`);\n\n  await withGitVan(ctx, async () => {\n    for (;;) {\n      try {\n        const shas = recentShas(opts.daemon?.lookback || 600);\n        let ran = 0;\n        const maxPerTick = opts.daemon?.maxPerTick || 50;\n\n        for (const sha of shas) {\n          if (ran >= maxPerTick) break;\n\n          for (const event of registry.events) {\n            if (ran >= maxPerTick) break;\n\n            try {\n              const fires = await eventFires(event, sha);\n              if (!fires) continue;\n\n              const git = useGit();\n              const lockRef = worktreeLockRef(\n                opts.locksRoot || \"refs/gitvan/locks\",\n                git.worktreeId(),\n                event.id,\n                sha,\n              );\n\n              const acquired = acquireLock(lockRef, sha);\n              if (!acquired) {\n                console.debug(`Lock already held for ${event.id}@${sha}`);\n                continue;\n              }\n\n              console.log(\n                `Processing ${event.id} for commit ${sha.slice(0, 8)}`,\n              );\n\n              let res;\n              if (event.job && registry.jobs[event.job]) {\n                // Run named job\n                res = await registry.jobs[event.job].run({\n                  payload: ctx.payload,\n                });\n              } else if (event.run) {\n                // Run inline action\n                res = await runAction(event.run);\n              } else {\n                console.warn(`No action defined for event ${event.id}`);\n                continue;\n              }\n\n              writeReceipt({\n                resultsRef: opts.resultsRef || \"refs/notes/gitvan/results\",\n                id: `${event.id}@${git.worktreeId()}`,\n                status: res.ok ? \"OK\" : \"ERROR\",\n                commit: sha,\n                action: event.job ? \"job\" : event.run?.exec || \"unknown\",\n                result: res,\n                artifact: res.artifact,\n                meta: {\n                  worktree: wt.path,\n                  branch: wt.branch,\n                  eventType: event.type,\n                  pattern: event.pattern,\n                },\n              });\n\n              releaseLock(lockRef);\n              ran++;\n            } catch (err) {\n              console.error(\n                `Error processing event ${event.id} for ${sha}:`,\n                err.message,\n              );\n            }\n          }\n        }\n\n        await sleep(opts.daemon?.pollMs || 1500);\n      } catch (err) {\n        console.error(`Error in daemon loop for ${wt.path}:`, err.message);\n        await sleep(5000); // Wait longer on errors\n      }\n    }\n  });\n}\n\n// Legacy GitVanDaemon class for backward compatibility\nimport { existsSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { execSync } from \"node:child_process\";\n\nexport class GitVanDaemon {\n  constructor(worktreePath) {\n    this.worktreePath = worktreePath;\n    this.pidFile = join(worktreePath, \".git\", \"gitvan.pid\");\n    this.lockFile = join(worktreePath, \".git\", \"gitvan.lock\");\n  }\n\n  start() {\n    if (this.isRunning()) {\n      throw new Error(\n        `Daemon already running for worktree: ${this.worktreePath}`,\n      );\n    }\n\n    const pid = process.pid;\n    writeFileSync(this.pidFile, String(pid));\n\n    // Setup graceful shutdown\n    process.on(\"SIGTERM\", () => this.stop());\n    process.on(\"SIGINT\", () => this.stop());\n\n    console.log(\n      `GitVan daemon started for worktree: ${this.worktreePath} (PID: ${pid})`,\n    );\n\n    // Start new daemon implementation\n    return startDaemon({}, null, [\n      { path: this.worktreePath, branch: \"main\", isMain: true },\n    ]);\n  }\n\n  stop() {\n    if (existsSync(this.pidFile)) {\n      try {\n        const pid = parseInt(readFileSync(this.pidFile, \"utf8\"));\n        if (pid === process.pid) {\n          process.exit(0);\n        }\n      } catch (err) {\n        console.warn(\"Error stopping daemon:\", err.message);\n      }\n    }\n  }\n\n  isRunning() {\n    if (!existsSync(this.pidFile)) return false;\n\n    try {\n      const pid = parseInt(readFileSync(this.pidFile, \"utf8\"));\n      // Check if process exists\n      process.kill(pid, 0);\n      return true;\n    } catch (err) {\n      // Process doesn't exist, clean up stale pid file\n      try {\n        if (existsSync(this.pidFile)) {\n          execSync(`rm -f ${this.pidFile}`);\n        }\n      } catch (cleanupErr) {\n        console.warn(\"Error cleaning up stale pid file:\", cleanupErr.message);\n      }\n      return false;\n    }\n  }\n\n  getLock(name) {\n    return new WorktreeLock(this.worktreePath, name);\n  }\n}\n\nclass WorktreeLock {\n  constructor(worktreePath, name) {\n    this.lockFile = join(worktreePath, \".git\", `gitvan-${name}.lock`);\n  }\n\n  acquire() {\n    if (existsSync(this.lockFile)) {\n      return false;\n    }\n    writeFileSync(this.lockFile, String(process.pid));\n    return true;\n  }\n\n  release() {\n    try {\n      if (existsSync(this.lockFile)) {\n        execSync(`rm -f ${this.lockFile}`);\n      }\n    } catch (err) {\n      console.warn(\"Error releasing lock:\", err.message);\n    }\n  }\n}\n\n// Additional exports for CLI\nexport async function daemonStatus() {\n  return {\n    running: false,\n    pid: null,\n    uptime: null,\n    worktrees: [],\n    jobs: {\n      active: 0,\n      completed: 0,\n      failed: 0,\n    },\n  };\n}\n\nexport async function stopDaemon() {\n  // Implementation for stopping daemon\n  console.log(\"Daemon stop functionality not fully implemented\");\n}\n"
        }
    ]
}