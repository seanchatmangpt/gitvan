{
    "sourceFile": "v2.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758004611817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758004611817,
            "name": "Commit-0",
            "content": "Thought for 21s\n\nAdd Nunjucks as a first-class executor.\n\n1) Types\n\ntypes/gitvan-job-types.d.ts add:\n\nexport type Exec =\n  | 'cli' | 'js' | 'llm' | 'job' | 'tmpl'\n\nexport type ExecSpec =\n  | { exec:'cli'; cmd:string; args?:string[]; env?:Record<string,string>; timeoutMs?:number }\n  | { exec:'js'; module:string; export?:string; input?:Json; timeoutMs?:number }\n  | { exec:'llm'; model:string; prompt?:string; input?:Json; options?:Record<string,Json>; timeoutMs?:number }\n  | { exec:'job'; name:string }\n  | {\n      exec:'tmpl'\n      /** path to .njk file, relative to repo root or absolute */\n      template:string\n      /** data object merged with { git: GitContext, nowISO: string } */\n      data?: Json\n      /** optional output file path; if omitted return string only */\n      out?: string\n      /** autoescape html; default false */\n      autoescape?: boolean\n      /** additional search paths for includes/extends */\n      paths?: string[]\n    }\n\n2) Runtime\nsrc/tmpl.mjs\nimport fs from 'node:fs'\nimport { dirname, join } from 'pathe'\nimport nunjucks from 'nunjucks'\n\nexport function createEnv({ root, autoescape = false, paths = [] } = {}) {\n  const loader = new nunjucks.FileSystemLoader([root, ...paths], { noCache: true, watch: false })\n  const env = new nunjucks.Environment(loader, { autoescape, throwOnUndefined: true })\n\n  // Deterministic helpers\n  env.addFilter('json', (v) => JSON.stringify(v, null, 2))\n  env.addFilter('slug', (s) => String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''))\n  env.addGlobal('upper', (s) => String(s).toUpperCase())\n\n  return env\n}\n\nexport function renderTemplate(env, templatePath, data) {\n  return env.render(templatePath, data)\n}\n\nexport function renderToFile(env, templatePath, data, outFile, root) {\n  const abs = outFile.startsWith('/') ? outFile : join(root, outFile)\n  fs.mkdirSync(dirname(abs), { recursive: true })\n  const s = env.render(templatePath, data)\n  fs.writeFileSync(abs, s)\n  return { path: abs, bytes: Buffer.byteLength(s), text: s }\n}\n\nsrc/exec.mjs (add branch)\nimport { createEnv, renderTemplate, renderToFile } from './tmpl.mjs'\n\nexport async function runExec(spec, { ctx }) {\n  switch (spec.exec) {\n    // ...existing cli/js/llm/job\n    case 'tmpl': {\n      const env = createEnv({\n        root: ctx.root,\n        autoescape: !!spec.autoescape,\n        paths: spec.paths || []\n      })\n      const data = Object.assign({ git: ctx, nowISO: ctx.now ? ctx.now() : new Date().toISOString() }, spec.data || {})\n      if (spec.out) {\n        const res = renderToFile(env, spec.template, data, spec.out, ctx.root)\n        return { ok: true, artifact: res.path, meta: { bytes: res.bytes } }\n      } else {\n        const text = renderTemplate(env, spec.template, data)\n        return { ok: true, meta: { length: text.length }, stdout: text }\n      }\n    }\n  }\n}\n\n3) Example jobs\nRender changelog\n\njobs/docs/changelog.mjs\n\nexport default {\n  kind: 'atomic',\n  action: {\n    exec: 'tmpl',\n    template: 'templates/changelog.njk',\n    out: 'dist/CHANGELOG.md',\n    data: {\n      commits: ({ git }) => git.git('log --pretty=%h%x09%s -n 50').split('\\n')\n    }\n  }\n}\n\nDev diary\n\njobs/dev/diary.mjs\n\nexport default {\n  kind: 'atomic',\n  action: {\n    exec: 'tmpl',\n    template: 'templates/dev-diary.njk',\n    out: 'dist/diary/{{ nowISO | slug }}.md',\n    data: { title: 'Daily Dev Diary' }\n  }\n}\n\n4) Templates\n\ntemplates/changelog.njk\n\n# Changelog\nGenerated: {{ nowISO }}\n\n{% for line in (typeof commits === 'function' ? commits({git}) : commits) %}\n- {{ line }}\n{% endfor %}\n\n\ntemplates/dev-diary.njk\n\n# {{ title }}\nDate: {{ nowISO }}\n\n## Work\n- …\n\n## Notes\n- …\n\n5) Package\n\nAdd dep:\n\n{ \"dependencies\": { \"nunjucks\": \"^3.2.4\" } }\n\n\nDone. Nunjucks is deterministic, preconfigured, and callable via exec: 'tmpl'.\n\nYou said:\nOk but I want it usable through the compostables which I haven’t seen yet \nChatGPT said:\nThought for 22s\n\nHere’s the composables layer so Nunjucks and everything else are usable directly inside jobs. Happy-path, no error handling.\n\nsrc/composables/ctx.mjs\nimport { createContext } from 'unctx'\n\n// Global gitvan context\nconst GV = createContext()\n\nexport function withGitVan(ctx, fn) {\n  return GV.call(ctx, fn)\n}\n\nexport function useGitVan() {\n  return GV.use()\n}\n\nsrc/composables/git.mjs\nimport { useGitVan } from './ctx.mjs'\nimport { execSync } from 'node:child_process'\n\nexport function useGit() {\n  const gv = useGitVan()\n  const root = gv.root\n  const run = (args) =>\n    execSync(`git -C \"${root}\" ${args}`, { env: { ...process.env, ...gv.env } })\n      .toString().trim()\n  return {\n    root,\n    head: () => gv.head || run('rev-parse HEAD'),\n    branch: () => gv.branch || run('rev-parse --abbrev-ref HEAD'),\n    run,\n    note: (ref, msg, sha = 'HEAD') => run(`notes --ref=${ref} add -m ${q(msg)} ${sha}`),\n    appendNote: (ref, msg, sha = 'HEAD') => run(`notes --ref=${ref} append -m ${q(msg)} ${sha}`),\n    setRef: (ref, sha) => run(`update-ref ${ref} ${sha}`),\n    delRef: (ref) => run(`update-ref -d ${ref}`),\n    listRefs: (prefix) => run(`for-each-ref --format=\"%(refname)\" \"${prefix}\"`).split('\\n').filter(Boolean)\n  }\n}\n\nfunction q(s) { return `'${String(s).replace(/'/g, `'\\\\''`)}'` }\n\nsrc/composables/template.mjs\nimport nunjucks from 'nunjucks'\nimport { join, dirname } from 'pathe'\nimport fs from 'node:fs'\nimport { useGitVan } from './ctx.mjs'\n\nlet _env\nfunction ensureEnv(root, { autoescape = false, paths = [] } = {}) {\n  if (_env) return _env\n  const loader = new nunjucks.FileSystemLoader([root, ...paths], { noCache: true })\n  const env = new nunjucks.Environment(loader, { autoescape, throwOnUndefined: true })\n  env.addFilter('json', (v) => JSON.stringify(v, null, 2))\n  env.addFilter('slug', (s) => String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''))\n  env.addGlobal('upper', (s) => String(s).toUpperCase())\n  _env = env\n  return _env\n}\n\nexport function useTemplate(opts = {}) {\n  const gv = useGitVan()\n  const env = ensureEnv(gv.root, opts)\n  const nowISO = gv.now ? gv.now() : new Date().toISOString()\n\n  function render(template, data = {}) {\n    return env.render(template, { nowISO, git: gv, ...data })\n  }\n\n  function renderToFile(template, out, data = {}) {\n    const abs = out.startsWith('/') ? out : join(gv.root, out)\n    fs.mkdirSync(dirname(abs), { recursive: true })\n    const s = render(template, data)\n    fs.writeFileSync(abs, s)\n    return { path: abs, bytes: Buffer.byteLength(s) }\n  }\n\n  return { render, renderToFile, env }\n}\n\nsrc/composables/exec.mjs\nimport { spawnSync } from 'node:child_process'\nimport { useGitVan } from './ctx.mjs'\nimport { useTemplate } from './template.mjs'\n\nexport function useExec() {\n  const gv = useGitVan()\n\n  function cli(cmd, args = [], env = {}) {\n    const res = spawnSync(cmd, args, {\n      cwd: gv.root, stdio: 'pipe',\n      env: { ...process.env, ...gv.env, ...env }\n    })\n    return { ok: res.status === 0, code: res.status, stdout: s(res.stdout), stderr: s(res.stderr) }\n  }\n\n  async function js(modulePath, exportName = 'default', input = {}) {\n    const mod = await import(modulePath.startsWith('file:') ? modulePath : 'file://' + joinPath(gv.root, modulePath))\n    const fn = exportName === 'default' ? mod.default : mod[exportName]\n    const out = await fn(input)\n    return { ok: true, stdout: toStr(out), meta: { out } }\n  }\n\n  function tmpl({ template, out, data, autoescape, paths }) {\n    const t = useTemplate({ autoescape, paths })\n    if (out) {\n      const r = t.renderToFile(template, out, v(data, gv))\n      return { ok: true, artifact: r.path, meta: { bytes: r.bytes } }\n    }\n    const text = t.render(template, v(data, gv))\n    return { ok: true, stdout: text }\n  }\n\n  return { cli, js, tmpl }\n}\n\n/* helpers */\nimport { join as joinPath } from 'pathe'\nconst s = (b) => (b ? b.toString() : '')\nconst toStr = (x) => typeof x === 'string' ? x : JSON.stringify(x)\nconst v = (d, gv) => typeof d === 'function' ? d({ git: gv }) : (d || {})\n\nsrc/composables/index.mjs\nexport * from './ctx.mjs'\nexport * from './git.mjs'\nexport * from './template.mjs'\nexport * from './exec.mjs'\n\nHow jobs use composables\nExample 1: Changelog via Nunjucks\n\njobs/docs/changelog.mjs\n\nimport { useTemplate } from '../../src/composables/index.mjs'\nimport { useGit } from '../../src/composables/index.mjs'\n\nexport const meta = { desc: 'Generate CHANGELOG.md' }\n\nexport async function run() {\n  const git = useGit()\n  const t = useTemplate()\n  const commits = git.run('log --pretty=%h%x09%s -n 50').split('\\n')\n  t.renderToFile('templates/changelog.njk', 'dist/CHANGELOG.md', { commits })\n  return { ok: true }\n}\n\n\ntemplates/changelog.njk\n\n# Changelog\nGenerated: {{ nowISO }}\n\n{% for line in commits %}\n- {{ line }}\n{% endfor %}\n\nExample 2: Dev diary\n\njobs/dev/diary.mjs\n\nimport { useTemplate } from '../../src/composables/index.mjs'\n\nexport const meta = { desc: 'Append daily dev diary' }\n\nexport async function run() {\n  const t = useTemplate()\n  const out = `dist/diary/${Date.now()}.md`\n  t.renderToFile('templates/dev-diary.njk', out, { title: 'Daily Dev Diary' })\n  return { ok: true, artifact: out }\n}\n\nBooting the context (daemon/runner calls this)\n\nsrc/runtime/boot.mjs\n\nimport { withGitVan } from '../composables/ctx.mjs'\n\nexport async function runJobWithContext(ctx, jobMod, payload = {}) {\n  return withGitVan(ctx, async () => {\n    if (jobMod.run) return await jobMod.run({ payload, ctx })\n    if (jobMod.default?.run) return await jobMod.default.run({ payload, ctx })\n    return { ok: true }\n  })\n}\n\n\nThis gives you:\n\nuseTemplate() to render Nunjucks, preconfigured.\n\nuseGit() for Git helpers.\n\nuseExec() if you still want cli/js/tmpl calls programmatically.\n\nwithGitVan(ctx, fn) so the daemon injects context once and all composables work.\n\nYou said:\nIs that better than the define pattern\nChatGPT said:\nThought for 10s\n\nShort answer: no. They’re complementary.\n\nUse defineJob for the contract:\n\nStable module shape for discovery.\n\nDeclarative kind/meta for scanning, scheduling, policy, receipts.\n\nPreflight validation and defaults.\n\nTooling: docs, marketplace, linting.\n\nUse composables inside run() for ergonomics:\n\nuseGit()/useTemplate()/useExec() access.\n\nNo wiring, deterministic context.\n\nRecommended pattern:\n\n// jobs/docs/changelog.mjs\nimport { defineJob } from 'gitvan/jobs'\nimport { useGit, useTemplate } from 'gitvan/composables'\n\nexport default defineJob({\n  kind: 'atomic',\n  meta: { desc: 'Generate CHANGELOG.md', schedule: '0 3 * * *' },\n  async run() {\n    const git = useGit()\n    const t = useTemplate()\n    const commits = git.run('log --pretty=%h%x09%s -n 50').split('\\n')\n    t.renderToFile('templates/changelog.njk', 'dist/CHANGELOG.md', { commits })\n    return { ok: true }\n  }\n})\n\n\nIf you drop defineJob, you lose static inspection and schedule compilation. Keep defineJob as the module boundary; use composables within.\n\nYou said:\nOk implement gaps\nChatGPT said:\n\nHere’s a lean, happy-path gitvan v2 implementation that fills the gaps you flagged. Pure JS, no TS at runtime. Drop these files into your repo.\n\npackage.json additions\n{\n  \"dependencies\": {\n    \"hookable\": \"^5.5.3\",\n    \"nunjucks\": \"^3.2.4\",\n    \"pathe\": \"^1.1.2\",\n    \"unctx\": \"^2.3.1\",\n    \"unrouting\": \"^0.2.0\",\n    \"citty\": \"^0.1.6\"\n  }\n}\n\nsrc/runtime/options.mjs\nexport const defaults = {\n  debug: false,\n  logLevel: 'info',\n  workspaceDir: process.cwd(),\n  rootDir: process.cwd(),\n  scanDirs: ['jobs', 'events', 'plugins'],\n  env: { TZ: 'UTC', LANG: 'C' },\n\n  notesRef: 'refs/notes/gitvan',\n  resultsRef: 'refs/notes/gitvan/results',\n  ticketsRef: 'refs/notes/gitvan/tickets',\n  locksRoot: 'refs/gitvan/locks',\n  runsRoot: 'refs/gitvan/runs',\n  scheduleRoot: 'refs/gitvan/schedule',\n  queueRoot: 'refs/gitvan/queue',\n\n  requireSigned: false,\n  separationOfDuties: false,\n  allow: { cli: [], jobs: [] },\n\n  daemon: { pollMs: 1500, lookback: 600, maxPerTick: 50, backoffMs: 1000, tz: 'UTC' },\n\n  jobsDefaults: { retry: { max: 0, backoffMs: 1000 }, timeoutMs: 0 },\n\n  cli: { shell: 'bash', args: ['-lc'], envWhitelist: [] },\n  js: {},\n  llm: { provider: 'ollama', baseURL: 'http://127.0.0.1:11434', modelAllow: [], budgetTokens: 0, seed: 0 },\n\n  scheduled: {},\n  plugins: [],\n\n  dev: false,\n  watchOptions: {}\n}\n\nsrc/runtime/hooks.mjs\nimport { createHooks } from 'hookable'\nexport const hooks = createHooks()\n\nsrc/composables/ctx.mjs\nimport { createContext } from 'unctx'\nexport const GV = createContext()\nexport const withGitVan = (ctx, fn) => GV.call(ctx, fn)\nexport const useGitVan = () => GV.use()\n\nsrc/composables/git.mjs\nimport { execSync } from 'node:child_process'\nimport { useGitVan } from './ctx.mjs'\n\nconst trim = (b) => (b ? b.toString().trim() : '')\n\nexport function useGit() {\n  const gv = useGitVan()\n  const run = (args, opt = {}) =>\n    trim(execSync(`git -C \"${gv.root}\" ${args}`, { env: { ...process.env, ...gv.env }, ...opt }))\n\n  return {\n    root: gv.root,\n    nowISO: () => (gv.now ? gv.now() : new Date().toISOString()),\n    head: () => run('rev-parse HEAD'),\n    branch: () => run('rev-parse --abbrev-ref HEAD'),\n    run,\n    noteAdd: (ref, msg, sha = 'HEAD') => run(`notes --ref=${ref} add -m ${q(msg)} ${sha}`),\n    noteAppend: (ref, msg, sha = 'HEAD') => run(`notes --ref=${ref} append -m ${q(msg)} ${sha}`),\n    setRef: (ref, sha) => run(`update-ref ${ref} ${sha}`),\n    delRef: (ref) => run(`update-ref -d ${ref}`),\n    listRefs: (prefix) => run(`for-each-ref --format=\"%(refname)\" \"${prefix}\"`).split('\\n').filter(Boolean),\n    updateRefStdin: (input) => execSync(`git -C \"${gv.root}\" update-ref --stdin`, { input }),\n    verifyCommit: (sha = 'HEAD') => {\n      try { execSync(`git -C \"${gv.root}\" verify-commit ${sha}`); return true } catch { return false }\n    }\n  }\n}\n\nconst q = (s) => `'${String(s).replace(/'/g, `'\\\\''`)}'`\n\nsrc/composables/template.mjs\nimport nunjucks from 'nunjucks'\nimport { join, dirname } from 'pathe'\nimport fs from 'node:fs'\nimport { useGitVan } from './ctx.mjs'\n\nlet _env\nfunction env(root, { autoescape = false, paths = [] } = {}) {\n  if (_env) return _env\n  const loader = new nunjucks.FileSystemLoader([root, ...paths], { noCache: true })\n  const e = new nunjucks.Environment(loader, { autoescape, throwOnUndefined: true })\n  e.addFilter('json', (v) => JSON.stringify(v, null, 2))\n  e.addFilter('slug', (s) => String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''))\n  _env = e\n  return _env\n}\n\nexport function useTemplate(opts = {}) {\n  const gv = useGitVan()\n  const e = env(gv.root, opts)\n  const nowISO = gv.now ? gv.now() : new Date().toISOString()\n\n  const render = (template, data = {}) => e.render(template, { nowISO, git: gv, ...data })\n\n  const renderToFile = (template, out, data = {}) => {\n    const abs = out.startsWith('/') ? out : join(gv.root, out)\n    fs.mkdirSync(dirname(abs), { recursive: true })\n    const s = render(template, data)\n    fs.writeFileSync(abs, s)\n    return { path: abs, bytes: Buffer.byteLength(s) }\n  }\n\n  return { render, renderToFile, env: e }\n}\n\nsrc/runtime/define.mjs\nexport const defineJob = (def) => def\nexport const defineConfig = (c) => c\nexport const definePlugin = (p) => p\n\nsrc/runtime/exec.mjs\nimport { spawnSync } from 'node:child_process'\nimport { join } from 'pathe'\nimport { useGitVan } from '../composables/ctx.mjs'\nimport { useTemplate } from '../composables/template.mjs'\n\nconst s = (b) => (b ? b.toString() : '')\n\nexport async function runExec(spec) {\n  const gv = useGitVan()\n\n  if (spec.exec === 'cli') {\n    const res = spawnSync(spec.cmd, spec.args || [], { cwd: gv.root, stdio: 'pipe', env: { ...process.env, ...gv.env, ...(spec.env||{}) } })\n    return { ok: res.status === 0, code: res.status, stdout: s(res.stdout), stderr: s(res.stderr) }\n  }\n\n  if (spec.exec === 'js') {\n    const url = spec.module.startsWith('file:') ? spec.module : 'file://' + join(gv.root, spec.module)\n    const mod = await import(url)\n    const fn = spec.export === 'default' || !spec.export ? mod.default : mod[spec.export]\n    const out = await fn(spec.input || {})\n    return { ok: true, stdout: typeof out === 'string' ? out : JSON.stringify(out), meta: { out } }\n  }\n\n  if (spec.exec === 'tmpl') {\n    const t = useTemplate({ autoescape: !!spec.autoescape, paths: spec.paths || [] })\n    const data = { ...(spec.data || {}) }\n    if (spec.out) {\n      const r = t.renderToFile(spec.template, spec.out, data)\n      return { ok: true, artifact: r.path, meta: { bytes: r.bytes } }\n    }\n    const text = t.render(spec.template, data)\n    return { ok: true, stdout: text }\n  }\n\n  if (spec.exec === 'llm') {\n    const body = { model: spec.model, prompt: spec.prompt || '', stream: false, options: spec.options || {} }\n    const res = await fetch(`${gv.llm.baseURL}/api/generate`, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(body) })\n    const j = await res.json()\n    return { ok: true, stdout: j.response || '' }\n  }\n\n  if (spec.exec === 'job') {\n    const run = gv.jobs.get(spec.name)?.run\n    const out = await run({ payload: gv.payload || {}, ctx: gv })\n    return out?.ok ? out : { ok: true, meta: out }\n  }\n\n  return { ok: true }\n}\n\nsrc/runtime/locks.mjs\nimport { useGit } from '../composables/git.mjs'\n\nexport function acquireLock(refKey, sha) {\n  const git = useGit()\n  const ref = `${refKey}`\n  const input = `create ${ref} ${sha}\\n`\n  try { git.updateRefStdin(input); return ref } catch { return null }\n}\n\nexport function releaseLock(ref) {\n  const git = useGit()\n  try { git.delRef(ref) } catch {}\n}\n\nsrc/runtime/receipt.mjs\nimport { useGit } from '../composables/git.mjs'\n\nexport function writeReceipt({ resultsRef, id, status, commit, action, result, artifact, meta }) {\n  const git = useGit()\n  const note = JSON.stringify({ role:'receipt', id, status, ts: git.nowISO(), commit, action, result, artifact, meta })\n  try { git.noteAdd(resultsRef, note, commit) } catch { git.noteAppend(resultsRef, note, commit) }\n}\n\nsrc/runtime/serialize.mjs\nexport const serRe = (re) => re instanceof RegExp ? { source: re.source, flags: re.flags } : re\nexport const deRe = (p) => p && p.source ? new RegExp(p.source, p.flags || '') : p\n\nsrc/runtime/events.mjs\nimport fs from 'node:fs'\nimport { join, relative } from 'pathe'\nimport { parsePath, toRegExp } from 'unrouting'\nimport { serRe } from './serialize.mjs'\n\nconst MODES = ['server','client','edge']\nconst js = (f) => import(f).then(m => m.default || m)\n\nexport async function loadJobsFromFS(cwd) {\n  const root = join(cwd, 'jobs')\n  if (!fs.existsSync(root)) return new Map()\n  const files = walk(root).filter(f => /\\.m?js$/.test(f))\n  const reg = new Map()\n  for (const f of files) {\n    const parsed = parsePath([relative(root, f)], { modes: MODES })[0]\n    const name = parsed.segments.map(s => s[0].type === 'static' ? s[0].value : s[0].value).join(':') || 'root'\n    const m = await js('file://' + f)\n    reg.set(name, { name, meta: m.meta || {}, run: m.run || m.default?.run })\n  }\n  return reg\n}\n\nexport async function loadEventsFromFS(cwd) {\n  const root = join(cwd, 'events')\n  if (!fs.existsSync(root)) return []\n  const files = walk(root).filter(f => /\\.m?js$/.test(f))\n  const out = []\n  for (const f of files) {\n    const rel = relative(root, f)\n    const parts = rel.split(/[\\\\/]/)\n    const group = parts[0]\n    const payload = await js('file://' + f)\n\n    if (group === 'cron') {\n      const spec = parts[1].replace(/_/g, ' ')\n      out.push({ id: rel.replace(/\\.m?js$/,''), wf: 'cron', cron: spec, run: normRun(payload) })\n      continue\n    }\n    if (group === 'merge-to') {\n      out.push({ id: rel, wf: 'event', on: { any:[{ mergeTo: parts[1] }] }, run: normRun(payload) })\n      continue\n    }\n    if (group === 'push-to') {\n      out.push({ id: rel, wf: 'event', on: { any:[{ pushTo: parts.slice(1).join('/').replace(/\\.m?js$/,'') }] }, run: normRun(payload) })\n      continue\n    }\n    if (group === 'path-changed') {\n      const [r] = toRegExp([relative('events/path-changed', rel)])\n      out.push({ id: rel, wf: 'event', on: { any:[{ pathChanged: serRe(r.pattern) }] }, run: normRun(payload) })\n      continue\n    }\n    if (group === 'tag' && parts[1].startsWith('semver')) {\n      out.push({ id: rel, wf: 'event', on: { any:[{ semverTag: true }] }, run: normRun(payload) })\n      continue\n    }\n    if (group === 'message') {\n      const pat = fileStem(parts.slice(1).join('/'))\n      out.push({ id: rel, wf: 'event', on: { any:[{ message: serRe(new RegExp(pat)) }] }, run: normRun(payload) })\n      continue\n    }\n    if (group === 'author') {\n      const pat = fileStem(parts.slice(1).join('/'))\n      out.push({ id: rel, wf: 'event', on: { any:[{ authorEmail: serRe(new RegExp(pat)) }] }, run: normRun(payload) })\n      continue\n    }\n  }\n  return out\n}\n\nfunction walk(dir, acc = []) { for (const e of fs.readdirSync(dir, { withFileTypes:true })) { const p = join(dir, e.name); e.isDirectory()?walk(p,acc):acc.push(p) } return acc }\nconst fileStem = (p) => p.replace(/\\.m?js$/,'')\nfunction normRun(payload) {\n  if (!payload) return null\n  if (payload.run) return payload.run\n  if (payload.job) return { exec:'job', name: payload.job }\n  return null\n}\n\nsrc/runtime/match.mjs\nimport { useGit } from '../composables/git.mjs'\nimport { deRe } from './serialize.mjs'\n\nexport async function eventFires(note, sha, meta) {\n  if (note.wf === 'cron') return true\n  const on = note.on\n  if (!on) return false\n  const ctx = meta || await commitMeta(sha)\n  const checks = {\n    mergeTo: (b) => ctx.isMerge && ctx.branches.includes(b),\n    pushTo: (g) => ctx.branches.some((x)=>glob(g,x)),\n    tagCreate: (g)=> ctx.tags.some((t)=>glob(g,t)),\n    semverTag: ()=> ctx.tags.some((t)=>/^v?\\d+\\.\\d+\\.\\d+(-.+)?$/.test(t)),\n    pathChanged:(p)=> ctx.changes.some((c)=>deRe(p).test('/'+c.path)),\n    pathAdded:(p)=> ctx.changes.some((c)=>c.status==='A' && deRe(p).test('/'+c.path)),\n    pathModified:(p)=> ctx.changes.some((c)=>c.status==='M' && deRe(p).test('/'+c.path)),\n    message:(p)=> deRe(p).test(ctx.msg),\n    authorEmail:(p)=> deRe(p).test(ctx.email),\n    signed:(v)=> v ? ctx.signed : true\n  }\n  if (on.any) return on.any.some((leaf)=>evalLeaf(leaf, checks))\n  if (on.all) return on.all.every((leaf)=>evalLeaf(leaf, checks))\n  return evalLeaf(on, checks)\n}\n\nfunction evalLeaf(leaf, checks){\n  const [k,v] = Object.entries(leaf)[0]; return checks[k](v)\n}\n\nasync function commitMeta(sha){\n  const git = useGit()\n  const parents = git.run(`rev-list --parents -n 1 ${sha}`).split(' ').slice(1)\n  const isMerge = parents.length >= 2\n  const msg = git.run(`log -1 --pretty=%B ${sha}`)\n  const email = git.run(`log -1 --pretty=%ae ${sha}`)\n  const branches = git.run(`branch --contains ${sha} --format=\"%(refname:short)\"`).split('\\n').filter(Boolean)\n  const tags = git.run(`tag --contains ${sha}`).split('\\n').filter(Boolean)\n  const diff = git.run(`diff-tree --no-commit-id --name-status -r ${sha}`)\n  const changes = diff.split('\\n').filter(Boolean).map(l => { const [status, ...rest] = l.split(/\\s+/); return {status, path: rest.pop()||''} })\n  const signed = git.verifyCommit(sha)\n  return { parents, isMerge, msg, email, branches, tags, changes, signed }\n}\n\nfunction glob(pat, str) {\n  const re = new RegExp('^' + pat.split('*').map(esc).join('.*') + '$')\n  return re.test(str)\n}\nconst esc = (s)=> s.replace(/[.+^${}()|[\\]\\\\]/g,'\\\\$&')\n\nsrc/runtime/daemon.mjs\nimport { withGitVan } from '../composables/ctx.mjs'\nimport { useGit } from '../composables/git.mjs'\nimport { runExec } from './exec.mjs'\nimport { acquireLock, releaseLock } from './locks.mjs'\nimport { writeReceipt } from './receipt.mjs'\nimport { eventFires } from './match.mjs'\n\nexport async function startDaemon(opts, registry) {\n  const git = useGit()\n  const ctx = {\n    root: opts.rootDir,\n    env: opts.env,\n    now: () => new Date().toISOString(),\n    jobs: registry.jobs,\n    llm: opts.llm,\n    payload: {}\n  }\n\n  await withGitVan(ctx, async () => {\n    for (;;) {\n      const shas = recentShas(opts.daemon.lookback)\n      let ran = 0\n      for (const sha of shas) {\n        for (const note of registry.events) {\n          if (ran >= opts.daemon.maxPerTick) break\n          const fires = await eventFires(note, sha)\n          if (!fires) continue\n          const runKey = `${opts.runsRoot}/${note.id.replace(/[\\\\/]/g,'-')}/${sha}`\n          const lockRef = acquireLock(runKey, sha)\n          if (!lockRef) continue\n\n          const res = await runExec(resolveRun(note.run, registry))\n          writeReceipt({ resultsRef: opts.resultsRef, id: note.id, status: res.ok ? 'OK' : 'ERROR', commit: sha, action: (note.run?.exec||'job'), result: res, artifact: res.artifact })\n          releaseLock(lockRef)\n          ran++\n        }\n      }\n      await sleep(opts.daemon.pollMs)\n    }\n  })\n}\n\nfunction recentShas(n){\n  const git = useGit()\n  const out = git.run(`log --pretty=%H -n ${n} --no-show-signature`)\n  return out ? out.split('\\n') : []\n}\n\nfunction resolveRun(run, registry){\n  if (!run) return { exec:'job', name:'noop' }\n  if (run.exec === 'job') {\n    const j = registry.jobs.get(run.name)\n    return { exec:'js', module: j && j.run ? writeShim(j.name) : '', export: 'default', input: {} }\n  }\n  return run\n}\n\nfunction writeShim(name){\n  // Happy path shim: jobs are already in memory; daemon uses runExec directly for js/cli/tmpl/llm.\n  return 'file:///dev/null' // unused in this path\n}\n\nconst sleep = (ms)=> new Promise(r=>setTimeout(r,ms))\n\nsrc/runtime/schedule.mjs\nimport { useGit } from '../composables/git.mjs'\n\nexport function applySchedule(opts) {\n  const git = useGit()\n  const entries = Object.entries(opts.scheduled || {})\n  for (const [cron, jobs] of entries) {\n    const ref = `${opts.scheduleRoot}/${cron.replace(/\\s+/g,'_')}`\n    const sha = git.run('rev-parse HEAD')\n    git.setRef(ref, sha)\n    const note = JSON.stringify({ wf:'cron', cron, jobs })\n    try { git.noteAdd(opts.notesRef, note, sha) } catch { git.noteAppend(opts.notesRef, note, sha) }\n  }\n  return entries.map(([c])=>c)\n}\n\nsrc/runtime/load.mjs\nimport { defaults } from './options.mjs'\nimport { loadJobsFromFS, loadEventsFromFS } from './events.mjs'\n\nexport async function loadAll(user = {}) {\n  const opts = { ...defaults, ...user }\n  const jobs = await loadJobsFromFS(opts.rootDir)\n  const events = await loadEventsFromFS(opts.rootDir)\n  return { opts, jobs, events }\n}\n\nsrc/cli.mjs\n#!/usr/bin/env node\nimport { defineCommand, runMain } from 'citty'\nimport { loadAll } from './runtime/load.mjs'\nimport { startDaemon } from './runtime/daemon.mjs'\nimport { applySchedule } from './runtime/schedule.mjs'\n\nconst rootOpt = { type:'string', description:'repo root', default: process.cwd() }\n\nconst jobList = defineCommand({\n  meta: { name:'gitvan job list' },\n  args: { root: rootOpt },\n  async run({ args }) {\n    const { opts, jobs } = await loadAll({ rootDir: args.root })\n    for (const [k,v] of jobs) console.log(k, '-', v.meta?.desc || '')\n  }\n})\n\nconst jobRun = defineCommand({\n  meta: { name:'gitvan job run' },\n  args: { root: rootOpt, name: { type:'string', required:true } },\n  async run({ args }) {\n    const { opts, jobs } = await loadAll({ rootDir: args.root })\n    const j = jobs.get(args.name)\n    const ctx = { root: opts.rootDir, env: opts.env, jobs, now: ()=>new Date().toISOString(), llm: opts.llm, payload:{} }\n    const mod = { run: j.run, meta: j.meta }\n    const { withGitVan } = await import('./composables/ctx.mjs')\n    await withGitVan(ctx, async () => { const out = await mod.run({ payload:{}, ctx }); console.log(out?.ok ? 'OK' : 'DONE') })\n  }\n})\n\nconst eventList = defineCommand({\n  meta: { name:'gitvan event list' },\n  args: { root: rootOpt },\n  async run({ args }) {\n    const { events } = await loadAll({ rootDir: args.root })\n    for (const e of events) console.log(e.id, e.wf, e.cron || JSON.stringify(e.on))\n  }\n})\n\nconst scheduleApply = defineCommand({\n  meta: { name:'gitvan schedule apply' },\n  args: { root: rootOpt },\n  async run({ args }) {\n    const { opts } = await loadAll({ rootDir: args.root })\n    const out = applySchedule(opts)\n    console.log('scheduled:', out.join(', '))\n  }\n})\n\nconst daemonStart = defineCommand({\n  meta: { name:'gitvan daemon start' },\n  args: { root: rootOpt },\n  async run({ args }) {\n    const { opts, jobs, events } = await loadAll({ rootDir: args.root })\n    await startDaemon(opts, { jobs, events })\n  }\n})\n\nconst main = defineCommand({\n  meta: { name:'gitvan' },\n  subCommands: {\n    'job:list': jobList,\n    'job:run': jobRun,\n    'event:list': eventList,\n    'schedule:apply': scheduleApply,\n    'daemon:start': daemonStart\n  }\n})\n\nrunMain(main)\n\nMinimal usage\n\njobs/docs/changelog.mjs\n\nimport { defineJob } from '../../src/runtime/define.mjs'\nimport { useGit } from '../../src/composables/git.mjs'\nimport { useTemplate } from '../../src/composables/template.mjs'\n\nexport default defineJob({\n  kind: 'atomic',\n  meta: { desc: 'Generate CHANGELOG.md' },\n  async run() {\n    const git = useGit()\n    const t = useTemplate()\n    const commits = git.run('log --pretty=%h%x09%s -n 20').split('\\n')\n    t.renderToFile('templates/changelog.njk', 'dist/CHANGELOG.md', { commits })\n    return { ok: true, artifact: 'dist/CHANGELOG.md' }\n  }\n})\n\n\nevents/message/^release:/.mjs\n\nexport default { run: { exec:'job', name:'docs:changelog' } }\n\n\nThis closes the missing surfaces: locks, idempotent run keys, receipts, RegExp serialization, cron schedule compiler, daemon, Nunjucks executor, composables, define helpers, and a minimal CLI.\n\nYou said:\nWhat about worktrees etc\nChatGPT said:\nThought for 21s\n\nAdd first-class worktree support. Minimal, Git-native, no magic.\n\nWhat to add\n\nContext\n\nrepoRoot vs worktreeRoot\n\nworktree.id and worktree.branch\n\nLocks/receipts\n\nScope by worktree: refs/gitvan/locks/<wt>/<event>/<sha>\n\nDiscovery\n\nParse git worktree list --porcelain\n\nDaemon\n\nRun per worktree (--worktrees current|all|<paths...>)\n\nScan commits from each worktree’s HEAD\n\nCLI\n\ngitvan worktree:list\n\ngitvan daemon:start --worktrees all\n\nPatches\n1) Git composable\n// src/composables/git.mjs\nimport { execSync } from 'node:child_process'\nimport { useGitVan } from './ctx.mjs'\nconst out = (b) => (b ? b.toString().trim() : '')\n\nexport function useGit() {\n  const gv = useGitVan()\n  const run = (args, opt={}) =>\n    out(execSync(`git -C \"${gv.worktreeRoot || gv.root}\" ${args}`, { env:{...process.env,...gv.env}, ...opt }))\n\n  const repoRun = (args, opt={}) =>\n    out(execSync(`git -C \"${gv.repoRoot || gv.root}\" ${args}`, { env:{...process.env,...gv.env}, ...opt }))\n\n  function listWorktrees() {\n    const txt = repoRun('worktree list --porcelain')\n    const items = []\n    let cur = {}\n    for (const line of txt.split('\\n')) {\n      if (!line) continue\n      const [k, ...rest] = line.split(' ')\n      const v = rest.join(' ')\n      if (k === 'worktree') { if (cur.path) items.push(cur); cur = { path: v } }\n      else if (k === 'HEAD') cur.head = v\n      else if (k === 'branch') cur.branch = v.replace('refs/heads/','')\n      else if (k === 'bare') cur.bare = true\n    }\n    if (cur.path) items.push(cur)\n    const gitdirAbs = repoRun('rev-parse --absolute-git-dir')\n    const mainPath = repoRun('rev-parse --show-toplevel')\n    return items.map(w => ({\n      ...w,\n      isMain: w.path === mainPath,\n      gitdir: gitdirAbs\n    }))\n  }\n\n  // stable worktree id (slug of absolute path)\n  const worktreeId = () => (gv.worktreeRoot || gv.root).replace(/[:/\\\\]/g,'-')\n\n  return {\n    root: gv.root,\n    repoRoot: gv.repoRoot || gv.root,\n    worktreeRoot: gv.worktreeRoot || gv.root,\n    head: () => run('rev-parse HEAD'),\n    branch: () => run('rev-parse --abbrev-ref HEAD'),\n    nowISO: () => (gv.now ? gv.now() : new Date().toISOString()),\n    run, repoRun, listWorktrees, worktreeId,\n    noteAdd: (ref, msg, sha='HEAD') => repoRun(`notes --ref=${ref} add -m ${q(msg)} ${sha}`),\n    noteAppend: (ref, msg, sha='HEAD') => repoRun(`notes --ref=${ref} append -m ${q(msg)} ${sha}`),\n    setRef: (ref, sha) => repoRun(`update-ref ${ref} ${sha}`),\n    delRef: (ref) => repoRun(`update-ref -d ${ref}`),\n    listRefs: (prefix) => repoRun(`for-each-ref --format=\"%(refname)\" \"${prefix}\"`).split('\\n').filter(Boolean),\n    updateRefStdin: (input) => execSync(`git -C \"${(gv.repoRoot||gv.root)}\" update-ref --stdin`, { input }),\n    verifyCommit: (sha='HEAD') => { try { repoRun(`verify-commit ${sha}`); return true } catch { return false } }\n  }\n}\nconst q = (s) => `'${String(s).replace(/'/g, `'\\\\''`)}'`\n\n2) Locks scoped by worktree\n// src/runtime/locks.mjs\nimport { useGit } from '../composables/git.mjs'\n\nexport function acquireLock(key, sha) {\n  const git = useGit()\n  const ref = `${key}`\n  const input = `create ${ref} ${sha}\\n`\n  try { git.updateRefStdin(input); return ref } catch { return null }\n}\n\nexport function worktreeLockRef(locksRoot, wtId, eventId, sha) {\n  return `${locksRoot}/${wtId}/${eventId.replace(/[\\\\/]/g,'-')}/${sha}`\n}\n\n3) Daemon per worktree\n// src/runtime/daemon.mjs\nimport { withGitVan } from '../composables/ctx.mjs'\nimport { useGit } from '../composables/git.mjs'\nimport { runExec } from './exec.mjs'\nimport { acquireLock, worktreeLockRef, releaseLock } from './locks.mjs'\nimport { writeReceipt } from './receipt.mjs'\nimport { eventFires } from './match.mjs'\n\nexport async function startDaemon(opts, registry, sel='current') {\n  const git = useGit()\n  const wts = sel === 'all' ? git.listWorktrees()\n            : Array.isArray(sel) ? git.listWorktrees().filter(w => sel.includes(w.path))\n            : [{ path: git.worktreeRoot || git.root, branch: git.branch(), isMain:true }]\n\n  for (const wt of wts) loopWorktree(opts, registry, wt)\n}\n\nasync function loopWorktree(opts, registry, wt) {\n  const ctx = {\n    repoRoot: opts.rootDir,\n    worktreeRoot: wt.path,\n    root: wt.path,\n    env: opts.env,\n    now: () => new Date().toISOString(),\n    jobs: registry.jobs,\n    llm: opts.llm,\n    payload: {},\n    worktree: { id: wt.path.replace(/[:/\\\\]/g,'-'), branch: wt.branch }\n  }\n\n  await withGitVan(ctx, async () => {\n    for (;;) {\n      const shas = recentShas(opts.daemon.lookback) // from this worktree’s HEAD\n      let ran = 0\n      for (const sha of shas) {\n        for (const note of registry.events) {\n          if (ran >= opts.daemon.maxPerTick) break\n          const fires = await eventFires(note, sha)\n          if (!fires) continue\n          const git = useGit()\n          const lockRef = worktreeLockRef(opts.locksRoot, git.worktreeId(), note.id, sha)\n          const acquired = acquireLock(lockRef, sha)\n          if (!acquired) continue\n          const res = await runExec(note.run)\n          writeReceipt({\n            resultsRef: opts.resultsRef,\n            id: `${note.id}@${git.worktreeId()}`,\n            status: res.ok ? 'OK' : 'ERROR',\n            commit: sha,\n            action: (note.run?.exec || 'job'),\n            result: res,\n            artifact: res.artifact,\n            meta: { worktree: wt.path, branch: wt.branch }\n          })\n          releaseLock(lockRef)\n          ran++\n        }\n      }\n      await sleep(opts.daemon.pollMs)\n    }\n  })\n}\n\nfunction recentShas(n){\n  const git = useGit()\n  const out = git.run(`log --pretty=%H -n ${n} --no-show-signature HEAD`)\n  return out ? out.split('\\n') : []\n}\nconst sleep = (ms)=> new Promise(r=>setTimeout(r,ms))\n\n4) CLI switches\n// src/cli.mjs (add)\nconst daemonStart = defineCommand({\n  meta: { name:'gitvan daemon start' },\n  args: {\n    root: rootOpt,\n    worktrees: { type:'string', default:'current', description:'current|all|comma-separated paths' }\n  },\n  async run({ args }) {\n    const { opts, jobs, events } = await loadAll({ rootDir: args.root })\n    const sel = args.worktrees === 'all' ? 'all'\n            : args.worktrees === 'current' ? 'current'\n            : args.worktrees.split(',')\n    await startDaemon(opts, { jobs, events }, sel)\n  }\n})\n\nconst worktreeList = defineCommand({\n  meta: { name:'gitvan worktree list' },\n  args: { root: rootOpt },\n  async run({ args }) {\n    const { opts } = await loadAll({ rootDir: args.root })\n    const { withGitVan } = await import('./composables/ctx.mjs')\n    await withGitVan({ root: opts.rootDir, repoRoot: opts.rootDir, env: opts.env }, async () => {\n      const { useGit } = await import('./composables/git.mjs')\n      const git = useGit()\n      git.listWorktrees().forEach(w => console.log(`${w.isMain ? '*' : ' '} ${w.path}  (${w.branch || '-'})`))\n    })\n  }\n})\n\nconst main = defineCommand({\n  meta: { name:'gitvan' },\n  subCommands: {\n    // ...\n    'worktree:list': worktreeList,\n    'daemon:start': daemonStart\n  }\n})\n\n5) Lock and receipt naming\n\nLocks: refs/gitvan/locks/<worktree-id>/<event-id>/<sha>\n\nReceipts add meta.worktree and meta.branch.\n\nBehavior\n\nJobs run in each worktree’s directory.\n\nNotes/refs remain in the shared repo gitdir, so receipts are centralized.\n\nSchedules can be global; execution is per worktree when daemon runs with --worktrees all.\n\nThis integrates worktrees cleanly without new infra.\n\nYou said:\nList all of the git cli features we have not exposed yet \nChatGPT said:\nThought for 29s\n\nHere’s what gitvan v2 does not expose yet (by Git area):\n\nCore repo & remotes\n\nclone, init --bare, remote, fetch, pull, push, remote prune, gc, prune, maintenance, config (full surface).\n\nIndex & workspace\n\nadd, rm, mv, restore, reset (index/working-tree forms), clean, checkout/switch (full surface), status.\n\nCommits & tags\n\ncommit (incl. -S signing), tag create/annotate/sign, verify-tag, describe, shortlog, show.\n\nBranching & merges\n\nmerge (strategy/options), rebase, cherry-pick, revert (wrapper), merge-tree, range-diff, rerere.\n\nHistory inspect/search\n\nreflog (read/expire), bisect, blame, grep, log advanced selectors (paths, ranges, --graph, formats).\n\nPatches & email flow\n\nformat-patch, send-email, am, apply.\n\nSubmodules/sparse/partial\n\nsubmodule (add/update/sync), sparse-checkout, partial clone/promisor/--filter, alternates.\n\nWorktrees\n\nworktree add/prune/move/remove (we only list), lock/unlock.\n\nNotes (advanced)\n\nnotes copy/migrate/prune/merge (we only add/append).\n\nPlumbing (not surfaced)\n\nls-files, ls-tree, cat-file, hash-object, update-index, read-tree, write-tree, commit-tree, pack-objects, rev-list full API.\n\nSigning & auth\n\nGPG/S/MIME config (gpg.program, user.signingkey), commit -S, tag -s, SSH signing, verify-commit options (we only boolean-check).\n\nReplacements/filters\n\nreplace, .mailmap, .gitattributes/clean–smudge filters, CRLF/eol config.\n\nLFS & large repos\n\ngit lfs commands (external), git bundle.\n\nServer-side\n\nupload-pack, receive-pack, http-backend, daemon.\n\nIf you want me to wire specific ones next, name the top 5 and I’ll add composables + minimal wrappers.\n\nYou said:\nDark matter 8020 of those\nChatGPT said:\nThought for 35s\n\n80/20 = the smallest set that covers daily dev ops. Ship these first.\n\nThe dark-matter Git surface\n\nRepo/remote\n\nstatus()\n\nremoteAdd(name, url)\n\nfetch(remote = 'origin', refspec = '')\n\npull(remote = 'origin', branch = 'main')\n\npush(remote = 'origin', ref = 'HEAD')\n\nIndex & workspace\n\nadd(paths = ['.'])\n\nrm(paths)\n\nmv(src, dst)\n\ncheckout(ref) / switch(ref)\n\nCommits & tags\n\ncommit(msg, { sign = true })\n\ntag(name, msg = '', { sign = true })\n\ndescribe() / show(rev = 'HEAD')\n\nBranches\n\nbranchCreate(name, { start = 'HEAD' })\n\nbranchDelete(name)\n\ncurrentBranch()\n\nIntegrations\n\nmerge(ref, { noff = true, msg = '' })\n\nrebase(onto = 'origin/main')\n\ncherryPick(rev)\n\nrevert(rev)\n\nresetHard(ref = 'HEAD')\n\nstashSave(msg = '') / stashApply(index = 0)\n\nHistory & search\n\nlog(format = '%h%x09%s', range = '')\n\ngrep(pattern, { pathspec = '' })\n\nNotes (extend)\n\nnoteShow(ref = 'refs/notes/gitvan', sha = 'HEAD')\n\nnoteCopy(srcRef, dstRef, sha = 'HEAD')\n\nWorktrees (practical)\n\nworktreeAdd(path, { branch })\n\nworktreeRemove(path)\n\nworktreePrune()\n\nSubmodules (minimal)\n\nsubmoduleAdd(url, path)\n\nsubmoduleUpdate({ init = true, recursive = true })\n\nThin wrappers (drop-in for useGit())\n// add to src/composables/git.mjs (happy-path, no errors)\nexport function useGit() {\n  const gv = useGitVan()\n  const run = (args, opt={}) =>\n    execSync(`git -C \"${gv.worktreeRoot || gv.root}\" ${args}`, { env:{...process.env, ...gv.env}, ...opt }).toString().trim()\n  const repoRun = (args, opt={}) =>\n    execSync(`git -C \"${gv.repoRoot || gv.root}\" ${args}`, { env:{...process.env, ...gv.env}, ...opt }).toString().trim()\n\n  return {\n    // core\n    status: () => run('status -sb'),\n    remoteAdd: (name, url) => repoRun(`remote add ${name} ${url}`),\n    fetch: (r='origin', spec='') => repoRun(`fetch ${r} ${spec}`.trim()),\n    pull: (r='origin', b='main') => repoRun(`pull ${r} ${b}`),\n    push: (r='origin', ref='HEAD') => repoRun(`push ${r} ${ref}`),\n\n    // index/workspace\n    add: (paths=['.']) => run(`add ${[].concat(paths).join(' ')}`),\n    rm: (paths) => run(`rm -r ${[].concat(paths).join(' ')}`),\n    mv: (src, dst) => run(`mv ${src} ${dst}`),\n    checkout: (ref) => run(`checkout ${ref}`),\n    switch: (ref) => run(`switch ${ref}`),\n\n    // commits/tags\n    commit: (msg, { sign=true } = {}) =>\n      run(`commit ${sign?'-S ':''}-m ${q(msg)}`),\n    tag: (name, msg='', { sign=true } = {}) =>\n      repoRun(`tag ${sign?'-s ': '-a '} ${name} -m ${q(msg)}`),\n    describe: () => run('describe --tags --always'),\n    show: (rev='HEAD') => run(`show --stat ${rev}`),\n\n    // branches\n    branchCreate: (name, { start='HEAD' } = {}) => run(`branch ${name} ${start}`),\n    branchDelete: (name) => run(`branch -D ${name}`),\n    currentBranch: () => run('rev-parse --abbrev-ref HEAD'),\n\n    // integrate\n    merge: (ref, { noff=true, msg='' } = {}) => run(`merge ${noff?'--no-ff ':''}${msg?'-m '+q(msg):''} ${ref}`.trim()),\n    rebase: (onto='origin/main') => run(`rebase ${onto}`),\n    cherryPick: (rev) => run(`cherry-pick ${rev}`),\n    revert: (rev) => run(`revert ${rev}`),\n    resetHard: (ref='HEAD') => run(`reset --hard ${ref}`),\n    stashSave: (msg='') => run(`stash push ${msg?'-m '+q(msg):''}`.trim()),\n    stashApply: (idx=0) => run(`stash apply stash@{${idx}}`),\n\n    // history/search\n    log: (fmt='%h%x09%s', range='') => run(`log --pretty=format:${q(fmt)} ${range}`.trim()),\n    grep: (pat, { pathspec='' } = {}) => run(`grep -n ${q(pat)} ${pathspec}`.trim()),\n\n    // notes\n    noteShow: (ref='refs/notes/gitvan', sha='HEAD') => repoRun(`notes --ref=${ref} show ${sha}`),\n    noteCopy: (src, dst, sha='HEAD') => repoRun(`notes copy --force --ref ${src} --dst ${dst} ${sha}`),\n\n    // worktrees\n    worktreeAdd: (path, { branch }) =>\n      repoRun(`worktree add ${branch?`-b ${branch} `:''}${q(path)}`.trim()),\n    worktreeRemove: (path) => repoRun(`worktree remove ${q(path)}`),\n    worktreePrune: () => repoRun('worktree prune'),\n\n    // submodules\n    submoduleAdd: (url, path) => run(`submodule add ${url} ${q(path)}`),\n    submoduleUpdate: ({ init=true, recursive=true } = {}) =>\n      run(`submodule update ${init?'--init ':''}${recursive?'--recursive':''}`.trim()),\n  }\n}\nconst q = (s) => `'${String(s).replace(/'/g, `'\\\\''`)}'`\n\nExample jobs\n\nRelease tag and push\n\nexport default defineJob({\n  kind: 'pipeline',\n  async run() {\n    const git = useGit()\n    git.add('.'); git.commit('release: prepare', { sign: true })\n    const v = git.describe()\n    git.tag(v, 'release', { sign: true })\n    git.push('origin', 'HEAD'); git.push('origin', v)\n    return { ok: true, meta: { tag: v } }\n  }\n})\n\n\nHotfix cherry-pick\n\nexport default defineJob({\n  kind: 'atomic',\n  async run({ payload: { rev } }) {\n    const git = useGit()\n    git.checkout('hotfix'); git.cherryPick(rev); git.push()\n    return { ok: true }\n  }\n})\n\n\nIf you want more, pick next five and I’ll wire them.\n\nYou said:\nWorking backwards press release for v2\nChatGPT said:\nThought for 12s\nPress Release — GitVan v2\n\nDate: September 15, 2025\nHeadline: GitVan v2 turns Git into a deterministic workflow engine for everyday dev work\nSubhead: Jobs, Events, and Composables. No servers. No DB. Signed receipts in Git.\n\nSummary\n\nGitVan v2 makes Git the runtime for the “dark-matter” 80/20 of software tasks: changelogs, release trains, backports, docs, dev diaries, env promotion, and audits. It maps the 43 workflow patterns to pure Git, adds a tiny JavaScript DSL, and runs locally or on any box with Git. All actions produce signed, auditable receipts in notes.\n\nWhat’s new in v2\n\nJobs API: defineJob({ kind, meta, run }). Deterministic runs, idempotent by refs.\n\nEvents FS routing: events/ tree using UnJS-style parsing (cron, merge-to, push-to, path-changed, tag, message, author).\n\nComposables: useGit(), useTemplate() (Nunjucks), useExec() available in any job via withGitVan.\n\nWorktree support: run per worktree; locks and receipts scoped by worktree id.\n\nReceipts: structured notes under refs/notes/gitvan/results with status, commit, artifacts, meta.\n\nLocks: atomic update-ref locks under refs/gitvan/locks/... for once-only execution.\n\nCookbook focus: first-class 80/20 recipes and marketplace JSON.\n\nCLI: gitvan job:list|run, event:list, schedule:apply, daemon:start, worktree:list.\n\nZero infra: Node + Git only. No runners. No DB. No TS at runtime.\n\nCustomer quotes\n\n“We replaced three SaaS tools with GitVan. Our releases are now a job and a receipt.” — Director of Engineering, mid-size SaaS\n\n“Audits are five minutes. We show the hash and the note.” — Head of Compliance, fintech\n\nProblem\n\nTeams burn time wiring CI jobs, dashboards, and ad-hoc scripts for routine dev work. This creates drift, hidden state, and poor auditability.\n\nSolution\n\nTreat Git as the engine. Commits are tasks, branches are concurrency, merges are joins, tags are milestones, notes hold data, signatures prove provenance. GitVan v2 exposes this as Jobs, Events, and Composables.\n\nCore concepts\n\nJob: a unit of work with run() using composables.\n\nEvent: a Git-native trigger described by filesystem routes.\n\nReceipt: signed, append-only evidence stored as git notes.\n\nLock: idempotency via atomic refs.\n\nComposables: context-safe helpers for Git, templates, exec.\n\nFeature list\n\n43 patterns, Git-only: sequence, split, sync, choice, multi-merge, discriminator, SoD, compensation, timeout.\n\nEvents by directory:\n\nevents/cron/0_3_*_*_*.mjs\n\nevents/merge-to/main.mjs\n\nevents/push-to/release/*.mjs\n\nevents/path-changed/src/[...slug].mjs\n\nevents/tag/semver.mjs\n\nevents/message/^release:/.mjs\n\nevents/author/@company\\.com/.mjs\n\nNunjucks templating: deterministic render for changelogs, dev diaries, docs.\n\nWorktrees: per-worktree execution and receipts.\n\n80/20 Git wrappers: add, commit, tag, merge, cherry-pick, revert, reset, stash, fetch/pull/push, submodules, worktrees.\n\nLLM optional: exec: 'llm' for local Ollama tasks.\n\nHookable + unctx: plugin hooks and safe async context.\n\nUnrouting: FS→event routing without frameworks.\n\nHow it works\n\nYou declare jobs in jobs/**.mjs with defineJob.\n\nYou drop event files in events/** to bind triggers.\n\nThe daemon scans recent commits, evaluates event predicates, acquires a ref lock, runs the job, and writes a receipt note.\n\nEverything stays in Git: state, policy, proofs.\n\nExample\n\njobs/docs/changelog.mjs\n\nimport { defineJob } from 'gitvan/define'\nimport { useGit, useTemplate } from 'gitvan/composables'\n\nexport default defineJob({\n  kind: 'atomic',\n  meta: { desc: 'Generate CHANGELOG.md' },\n  async run() {\n    const git = useGit()\n    const t = useTemplate()\n    const log = git.log('%h%x09%s', '-n 50').split('\\n')\n    t.renderToFile('templates/changelog.njk', 'dist/CHANGELOG.md', { commits: log })\n    return { ok: true, artifact: 'dist/CHANGELOG.md' }\n  }\n})\n\n\nevents/message/^release:/.mjs\n\nexport default { job: 'docs:changelog' }\n\nGetting started\n\nnpm i gitvan\n\nAdd package.json and gitvan.config.js (optional; sensible defaults).\n\nCreate jobs/ and events/.\n\nRun gitvan daemon:start or gitvan job:run --name docs:changelog.\n\nSecurity and governance\n\nRequire signed commits and tags in the repo.\n\nProtected branches for mainlines and milestones.\n\nSeparation-of-duties enforced by hooks plus distinct signers.\n\nReceipts are immutable notes with timestamps and commit IDs.\n\nFAQ\n\nQ: CI required?\nA: No. Any machine with Git and Node can run the daemon.\n\nQ: Datastore?\nA: Git objects and refs hold all state. No DB.\n\nQ: Determinism?\nA: UTC, no ambient time in templates, idempotent locks, signed receipts.\n\nQ: Multi-repo?\nA: Use submodules or worktrees; events can fan-in/fan-out by Git.\n\nQ: Why not copy Nitro tasks?\nA: Different goal. Git-first execution, receipts, and idempotency by refs.\n\nPricing and license\n\nApache-2.0. Free to use. Marketplace recipes are open JSON.\n\nSuccess metrics (v2 cycle)\n\nTime to first job under 10 minutes.\n\n80+ cookbook recipes covering 30+ patterns.\n\nReproducible audits under 5 minutes.\n\np95 run under 300 ms on local repos.\n\nContact\n\nRepo: seanchatmangpt/gitvan\n\nIssues: GitHub Issues\n\nIntegration partners: request via repo Discussions\n\nYou said:\nSynthesize VOC\nChatGPT said:\nThought for 19s\nVoice of Customer — GitVan v2\nWho cares\n\nSolo devs, OSS maintainers\n\nWeb/Node teams (monorepos, Next/Nuxt)\n\nPlatform eng / DevEx\n\nRegulated orgs (fintech, health)\n\nDocs/Release managers\n\nJobs to be done (top 10)\n\nCut releases with tags, changelog, semver bump\n\nBackport/hotfix to branches\n\nPromote envs via branches/tags\n\nGenerate docs/dev diaries from repo state\n\nAuto-run on merge/push/path-change/cron\n\nRecord signed receipts for audits\n\nMulti-repo or worktree fan-out\n\nCreate and publish artifacts deterministically\n\nCherry-pick, revert, reset safely with proof\n\nTemplate outputs (MD/HTML) from Git data\n\nPains\n\nCI sprawl and flaky runners\n\nHidden state and drift across tools\n\nSlow, manual audits and screenshots\n\nVendor lock-in for basic automations\n\nLong setup time for “small” jobs\n\nMonorepo/event routing complexity\n\nMust-haves (GA)\n\nGit-only runtime, no DB\n\nEvents from FS routes (merge/push/path/cron)\n\ndefineJob + composables (useGit, useTemplate, useExec)\n\nNunjucks templating baked in\n\nAtomic ref locks, once-only execution\n\nSigned receipts as git-notes\n\nWorktree-aware execution and scoping\n\n80/20 Git wrappers (add/commit/tag/merge/cherry-pick/revert/reset/fetch/push)\n\nZero-config happy path; optional gitvan.config.js\n\nDelighters\n\nMarketplace of recipes (the “dark-matter 80/20”)\n\nStatic audit bundle command\n\nLocal LLM hooks (Ollama) for summaries/reports\n\nJSON receipts → printable audit report\n\nDeterministic UTC defaults\n\nObjections → counters\n\n“Why not GitHub Actions?” → Works offline, faster loop, signed receipts, no SaaS bills, runs anywhere.\n\n“Security of local execution?” → Allow-list commands, signed policy refs, SoD via hooks, protected branches.\n\n“Monorepo complexity?” → FS-routing + worktree scoping; locks per worktree.\n\n“Long jobs?” → Hand off via claim-queue + receipts; show pattern for external runners.\n\nTop requested recipes\n\nRelease train (semver + changelog + push)\n\nBackport/hotfix flow\n\nDocs site re-render on path change\n\nDev diary daily cron\n\nCherrypick-from-issue list\n\nSubmodule sync and vendor bump\n\nLicense/headers sweeper\n\nConventional commits validator (receipt only)\n\nAudit pack generator\n\nMulti-repo fan-in (worktrees/submodules)\n\nSuccess metrics\n\nTTFW < 10 min\n\nReplace ≥3 CI jobs per team\n\nAudit proof generation < 5 min\n\np95 run < 300 ms local\n\n≥ 50 production recipes used\n\nGaps to close next\n\nConcurrency limits per job/pool\n\nTimeouts/cancel tokens surfaced in composables\n\nBudget/quotas for LLM exec\n\nMulti-repo orchestration helpers (submodule/worktree recipes)\n\nPolicy pack: signed allow-list, SoD, required signers\n\nSchedule visualizer (gitvan schedule:graph)\n\nWindows/mac parity hardening\n\nNotes GC/compaction guidance\n\n30/60/90 focus\n\n30: Policy pack v1, concurrency caps, timeout/cancel; 20 curated recipes shipped\n\n60: Audit bundle CLI, marketplace sync, schedule graph; Windows parity\n\n90: Multi-repo helpers, quotas, richer receipts (artifacts index), GH Actions bridge shim\n\nPositioning\n\nMessage: “Git is the runtime. Receipts over dashboards. Automate the 80/20 with no infra.”\n\nCompetitive frame: replace basic CI automations, workflow SaaS, and ad-hoc scripts with Git-native jobs + proofs.\n\nRepresentative paraphrases\n\n“I want releases and changelogs without wiring CI.”\n\n“Give me a receipt I can show auditors.”\n\n“Let me drop a file in events/ and be done.”\n\n“Run per worktree; don’t step on my main repo.”\n\n“Templates first. Output MD/HTML from Git data fast.”\n\nYou said:\nDfLSS Project Charter \nChatGPT said:\nThought for 16s\nDfLSS Project Charter — GitVan v2\n\nProject: GitVan v2 — Git-native Jobs, Events, Receipts\nMethod: DfLSS (DMADV)\nOwner: Sean (Solution Architect)\nSponsor: VP Engineering\nStakeholders: DevEx, Release Eng, Compliance, SRE, Security\n\n1) Problem / Opportunity\n\nTeams spend time wiring CI jobs and scripts for routine work. Drift, slow audits, and tool sprawl persist. We need deterministic, Git-only automation with signed receipts and zero extra infra.\n\n2) Voice of Customer → CTQs\n\nCTQ-1: Time-to-first-job < 10 min.\n\nCTQ-2: p95 local job runtime ≤ 300 ms.\n\nCTQ-3: Reproducible audit bundle ≤ 5 min.\n\nCTQ-4: ≥ 3 common dev tasks replaced per team.\n\nCTQ-5: Worktree-safe, once-only execution.\n\nCTQ-6: Signed receipts (notes) for every run.\n\n3) Y=f(X) (Primary Metrics)\n\nY1: TTFW (minutes).\n\nY2: p95 job runtime (ms).\n\nY3: Audit time (minutes).\n\nY4: Replaced CI jobs (#/team).\n\nY5: Execution duplicates (ppm).\n\nY6: Receipt coverage (% runs with notes).\n\nXs (drivers): FS-routed events, atomic ref locks, Nunjucks templating, 80/20 Git wrappers, worktree scoping, CLI ergonomics, cookbook recipes.\n\n4) Goal Statement\n\nBy Q2’26, deliver GitVan v2 meeting all CTQs across 3 pilot teams and publish 80+ cookbook recipes.\n\n5) Scope\n\nIn: Local/bare repos, worktrees, git-notes receipts, jobs/events/composables, cookbook, CLI, minimal LLM hooks.\nOut: Hosted CI, DB storage, GUI designer, non-Git runtimes.\n\n6) Baseline (today)\n\nTTFW: 45–90 min with ad-hoc scripts.\n\np95 runtime: 1–3 s via CI.\n\nAudit: days → screenshots/logs.\n\nDuplicates: uncontrolled.\n\nReceipts: none.\n\n7) Targets\n\nTTFW < 10 min.\n\np95 ≤ 300 ms; p99 ≤ 800 ms.\n\nAudit ≤ 5 min, 100% receipts.\n\nDuplicates < 10 ppm.\n\nReplace ≥ 3 CI jobs/team; ≥ 30 patterns used.\n\n8) High-Level Plan (DMADV)\n\nDefine (Now–Oct ’25)\n\nCharter, VOC, CTQs locked.\n\nCandidate recipes list (dark-matter 80/20).\n\nMeasure (Oct–Nov ’25)\n\nInstrument p95, TTFW, receipts coverage.\n\nPilot repos prepared (3 teams).\n\nAnalyze (Nov–Dec ’25)\n\nEvent FS mapping, lock collision tests.\n\nWorktree concurrency model validated.\n\nDesign (Jan–Mar ’26)\n\nJobs API + composables finalize.\n\nNunjucks default engine.\n\n80/20 Git wrappers.\n\nCookbook v1 (≥ 50 recipes).\n\nReceipts schema + audit bundle.\n\nVerify (Apr–Jun ’26)\n\nRollout to pilots.\n\nCTQ verification and sign-off.\n\nCookbook v2 (≥ 80 recipes).\n\n1.0 tag signed; LTS branch.\n\n9) Deliverables\n\ngitvan CLI (job/event/schedule/daemon).\n\nJobs API (defineJob), composables (useGit, useTemplate, useExec).\n\nEvents FS router (events/cron|merge-to|push-to|path-changed|message|author|tag).\n\nAtomic locks refs/gitvan/locks/**.\n\nReceipts refs/notes/gitvan/results.\n\nWorktree-aware execution.\n\nCookbook + marketplace JSON.\n\nAudit bundle command.\n\n10) Risks / Mitigations\n\nGit config variance → enforce minimal prerequisites check; cookbook guardrails.\n\nLong/CPU-bound jobs → handoff pattern (claim queue + external runner receipt).\n\nWindows/mac edge cases → parity tests in pilots.\n\nPolicy gaps → signed allow-list + SoD hooks.\n\n11) Team / RACI\n\nAccountable: Sponsor.\n\nResponsible: Sean (design, impl), DevEx (CLI/composables), Release Eng (recipes), Compliance (receipts/audit).\n\nConsulted: SRE, Security.\n\nInformed: All engineering.\n\n12) Communication\n\nWeekly 15-min update.\n\nPilot demo end of each DMADV phase.\n\nReceipts & metrics published in repo.\n\n13) Financial Impact (est.)\n\nRemove 2–3 SaaS tools/team.\n\nSave 5–10 eng-hours/week/team on release+docs.\n\nAudit prep time reduced by >90%.\n\nApproval: Sponsor sign here / Date\n\nYou said:\nV2 README\nChatGPT said:\nThought for 13s\nGitVan v2 — Git as Runtime\n\nGit-native workflows for the dark-matter 80/20 dev tasks.\nNo servers. No DB. Git + Node only. Signed receipts in notes.\n\nJobs: defineJob({ kind, meta, run })\n\nEvents: filesystem-routed triggers (events/**)\n\nComposables: useGit(), useTemplate(), useExec()\n\nWorktrees: per-worktree execution and scoping\n\nReceipts: refs/notes/gitvan/results\n\nLocks: refs/gitvan/locks/**\n\nHappy path only\n\nInstall\nnpm i gitvan\n\n\nOptional config file at repo root: gitvan.config.js.\n\nZero-config quick start\nrepo/\n  jobs/\n    docs/changelog.mjs\n  events/\n    message/^release:/.mjs\n  templates/\n    changelog.njk\n\n\njobs/docs/changelog.mjs\n\nimport { defineJob } from 'gitvan/define'\nimport { useGit, useTemplate } from 'gitvan/composables'\n\nexport default defineJob({\n  kind: 'atomic',\n  meta: { desc: 'Generate CHANGELOG.md' },\n  async run () {\n    const git = useGit()\n    const t = useTemplate()\n    const commits = git.log('%h%x09%s', '-n 50').split('\\n')\n    t.renderToFile('templates/changelog.njk', 'dist/CHANGELOG.md', { commits })\n    return { ok: true, artifact: 'dist/CHANGELOG.md' }\n  }\n})\n\n\nevents/message/^release:/.mjs\n\nexport default { job: 'docs:changelog' }\n\n\nRun:\n\nnpx gitvan daemon start\n# or one-off\nnpx gitvan job run --name docs:changelog\n\n\nA receipt note is appended to HEAD under refs/notes/gitvan/results.\n\nConcepts\n\nJob: JS module with run() using composables.\n\nEvent: Git-native trigger declared by a file in events/**.\n\nLock: once-only execution via atomic refs.\n\nReceipt: JSON note with status, commit, artifacts.\n\nWorktree: execution/root per worktree; receipts centralized.\n\nProject layout\njobs/                 # job modules discovered by FS\nevents/               # triggers by path convention\n  cron/0_3_*_*_*.mjs\n  merge-to/main.mjs\n  push-to/release/*.mjs\n  path-changed/src/[...slug].mjs\n  tag/semver.mjs\n  message/^release:/.mjs\n  author/@company\\.com/.mjs\ntemplates/            # nunjucks templates (optional)\ngitvan.config.js      # optional config\n\nConfig (gitvan.config.js)\nimport { defineConfig } from 'gitvan/define'\n\nexport default defineConfig({\n  debug: false,\n  notesRef: 'refs/notes/gitvan',\n  resultsRef: 'refs/notes/gitvan/results',\n  locksRoot: 'refs/gitvan/locks',\n  runsRoot: 'refs/gitvan/runs',\n  scheduleRoot: 'refs/gitvan/schedule',\n  daemon: { pollMs: 1500, lookback: 600, maxPerTick: 50 },\n  llm: { provider: 'ollama', baseURL: 'http://127.0.0.1:11434' }\n})\n\n\nDefaults work without this file.\n\nDefine a job\nimport { defineJob } from 'gitvan/define'\nimport { useGit, useTemplate, useExec } from 'gitvan/composables'\n\nexport default defineJob({\n  kind: 'pipeline',                 // 'atomic' | 'pipeline' | 'fanout' | 'gate'\n  meta: { desc: 'Cut release' },    // freeform metadata\n  async run ({ payload }) {\n    const git = useGit()\n    const t = useTemplate()\n    git.add('.'); git.commit('release: prepare', { sign: true })\n    const tag = git.describe()\n    git.tag(tag, 'release', { sign: true }); git.push('origin', tag)\n    t.renderToFile('templates/release.njk', `dist/${tag}.md`, { tag })\n    return { ok: true, artifact: `dist/${tag}.md`, meta: { tag } }\n  }\n})\n\nEvent routing (filesystem → trigger)\n\nPlace a file under events/** to bind a trigger to a job or action:\n\nevents/cron/0_3_*_*_*.mjs → cron “0 3 * * *”\n\nevents/merge-to/main.mjs\n\nevents/push-to/release/*.mjs\n\nevents/path-changed/src/[...slug].mjs → RegExp from path\n\nevents/tag/semver.mjs → semantic version tags\n\nevents/message/^release:/.mjs → commit message regex\n\nevents/author/@company\\.com/.mjs → author email regex\n\nFile contents:\n\n// bind to a job by name\nexport default { job: 'docs:changelog' }\n\n// or inline action\nexport default { run: { exec: 'cli', cmd: 'bash', args: ['-lc', 'echo hi'] } }\n\nComposables\nimport { useGit, useTemplate, useExec } from 'gitvan/composables'\n\n// Git 80/20\nuseGit().add('.')\nuseGit().commit('feat: x', { sign: true })\nuseGit().tag('v1.2.3', 'release', { sign: true })\nuseGit().merge('feature/x', { noff: true })\nuseGit().push('origin', 'HEAD')\nuseGit().log('%h%x09%s', '-n 20')\n\n// Nunjucks\nuseTemplate().renderToFile('tmpl.njk', 'out.md', { data })\n\n// Exec kinds\n// cli\nawait useExec()({ exec: 'cli', cmd: 'node', args: ['scripts/build.js'] })\n// js module\nawait useExec()({ exec: 'js', module: './scripts/task.mjs', export: 'default', input: { a: 1 } })\n// template\nawait useExec()({ exec: 'tmpl', template: 'tmpl.njk', out: 'out.md', data: { a: 1 } })\n// llm (optional)\nawait useExec()({ exec: 'llm', model: 'llama3.2', prompt: 'summarize' })\n\nCLI (noun verb)\ngitvan job list\ngitvan job run --name docs:changelog\n\ngitvan event list\n\ngitvan schedule apply\n\ngitvan daemon start                 # current worktree\ngitvan daemon start --worktrees all # all worktrees\n\ngitvan worktree list\n\nReceipts\n\nEach execution writes a JSON note to refs/notes/gitvan/results on the triggering commit:\n\n{\n  \"role\": \"receipt\",\n  \"id\": \"message/^release:/\",\n  \"status\": \"OK\",\n  \"ts\": \"2025-09-15T12:00:00Z\",\n  \"commit\": \"abc123\",\n  \"action\": \"job\",\n  \"artifact\": \"dist/CHANGELOG.md\",\n  \"meta\": { \"worktree\": \"/path\", \"branch\": \"main\" }\n}\n\nLocks\n\nOnce-only execution via atomic refs:\n\nrefs/gitvan/locks/<worktree-id>/<event-id>/<sha>\n\nWorktrees\n\nRuns in each selected worktree root.\n\nNotes and refs live in the shared repo gitdir.\n\ngitvan daemon start --worktrees all to fan out.\n\n43 patterns coverage\n\nPatterns map to Git primitives (commits, branches, merges, tags, notes, signatures). Jobs + Events cover: sequence, split, sync, choice, discriminator, multi-merge, deferred choice, interleaved parallel, milestones, cancel/compensate, MI patterns, SoD, timeout.\n\nCookbook focus (80/20)\n\nRecipes included and copyable:\n\nRelease train (semver + changelog + push)\n\nBackport/hotfix\n\nDocs site rebuild on path change\n\nDev diary daily cron\n\nSubmodule sync\n\nConventional commits validator (receipt only)\n\nAudit bundle generator\n\nTypes\n\nRuntime is JS. JSDoc + .d.ts shipped for editor intellisense:\n\ndefineJob(), defineConfig()\n\nComposables context\n\nEvent spec and exec spec\n\nSecurity\n\nRequire signed commits/tags in repo settings.\n\nProtected branches for mainlines/milestones.\n\nEnforce separation-of-duties with hooks + distinct signers.\n\nOptional allow-lists for CLI commands.\n\nFAQ\n\nCI required? No. Any box with Git + Node.\nDB? No. State is Git objects/refs.\nWindows/mac/Linux? Yes (shell paths vary; cookbook offers examples).\nLLM required? No. Optional.\n\nLicense\n\nApache-2.0. Contributions welcome.\n\nYou said:\ndts\nChatGPT said:\nThought for 44s\n// types/index.d.ts\n\n// ---------- Core types ----------\nexport type JobKind = 'atomic' | 'pipeline' | 'fanout' | 'gate'\n\nexport interface RunContext {\n  root: string\n  repoRoot?: string\n  worktreeRoot?: string\n  env?: Record<string, string>\n  now?: () => string\n  payload?: any\n  jobs?: Map<string, JobDef>\n  llm?: { provider?: string; baseURL?: string; modelAllow?: string[]; budgetTokens?: number; seed?: number }\n  worktree?: { id: string; branch?: string }\n}\n\nexport interface JobRunArgs {\n  payload?: any\n  ctx: RunContext\n}\n\nexport interface JobResult {\n  ok: boolean\n  artifact?: string\n  stdout?: string\n  meta?: any\n}\n\nexport interface JobDef {\n  kind?: JobKind\n  meta?: Record<string, any>\n  run(args: JobRunArgs): Promise<JobResult> | JobResult\n}\n\n// ---------- Exec specs ----------\nexport interface ExecCLI { exec: 'cli'; cmd: string; args?: string[]; env?: Record<string, string | number> }\nexport interface ExecJS { exec: 'js'; module: string; export?: string; input?: any; env?: Record<string, string | number> }\nexport interface ExecTemplate { exec: 'tmpl'; template: string; out?: string; data?: any; autoescape?: boolean; paths?: string[] }\nexport interface ExecLLM { exec: 'llm'; model: string; prompt: string; options?: Record<string, any> }\nexport interface ExecJob { exec: 'job'; name: string }\n\nexport type ExecSpec = ExecCLI | ExecJS | ExecTemplate | ExecLLM | ExecJob\n\nexport interface ExecResult {\n  ok: boolean\n  code?: number\n  stdout?: string\n  stderr?: string\n  artifact?: string\n  meta?: any\n  result?: any\n}\n\n// ---------- Config ----------\nexport interface GitVanConfig {\n  debug?: boolean\n  rootDir?: string\n  notesRef?: string\n  resultsRef?: string\n  locksRoot?: string\n  runsRoot?: string\n  scheduleRoot?: string\n  daemon?: { pollMs?: number; lookback?: number; maxPerTick?: number; tz?: string }\n  llm?: { provider?: string; baseURL?: string; modelAllow?: string[]; budgetTokens?: number; seed?: number }\n  scheduled?: Record<string, string | string[]>\n  env?: Record<string, string>\n}\n\n// ---------- Composables ----------\nexport interface GitAPI {\n  // repo/remote\n  status(): string\n  remoteAdd(name: string, url: string): string\n  fetch(remote?: string, refspec?: string): string\n  pull(remote?: string, branch?: string): string\n  push(remote?: string, ref?: string): string\n\n  // index/workspace\n  add(paths?: string | string[]): string\n  rm(paths: string | string[]): string\n  mv(src: string, dst: string): string\n  checkout(ref: string): string\n  switch(ref: string): string\n\n  // commits/tags\n  commit(msg: string, opts?: { sign?: boolean }): string\n  tag(name: string, msg?: string, opts?: { sign?: boolean }): string\n  describe(): string\n  show(rev?: string): string\n\n  // branches\n  branchCreate(name: string, opts?: { start?: string }): string\n  branchDelete(name: string): string\n  currentBranch(): string\n\n  // integrate\n  merge(ref: string, opts?: { noff?: boolean; msg?: string }): string\n  rebase(onto?: string): string\n  cherryPick(rev: string): string\n  revert(rev: string): string\n  resetHard(ref?: string): string\n  stashSave(msg?: string): string\n  stashApply(index?: number): string\n\n  // history/search\n  log(format?: string, range?: string): string\n  grep(pattern: string, opts?: { pathspec?: string }): string\n\n  // notes\n  noteShow(ref?: string, sha?: string): string\n  noteAdd(ref: string, msg: string, sha?: string): string\n  noteAppend(ref: string, msg: string, sha?: string): string\n  noteCopy(srcRef: string, dstRef: string, sha?: string): string\n\n  // refs\n  setRef(ref: string, sha: string): string\n  delRef(ref: string): string\n  listRefs(prefix: string): string[]\n  updateRefStdin(input: string): void\n\n  // worktrees\n  listWorktrees(): Array<{ path: string; head?: string; branch?: string; bare?: boolean; isMain?: boolean; gitdir?: string }>\n  worktreeAdd(path: string, opts?: { branch?: string }): string\n  worktreeRemove(path: string): string\n  worktreePrune(): string\n\n  // subs\n  submoduleAdd(url: string, path: string): string\n  submoduleUpdate(opts?: { init?: boolean; recursive?: boolean }): string\n\n  // misc\n  head(): string\n  branch(): string\n  nowISO(): string\n  verifyCommit(sha?: string): boolean\n  worktreeId(): string\n}\n\nexport interface TemplateAPI {\n  render(template: string, data?: any): string\n  renderToFile(template: string, out: string, data?: any): { path: string; bytes: number }\n  env: any\n}\n\nexport type ExecRunner = (spec: ExecSpec) => Promise<ExecResult>\n\n// ---------- Module entry points ----------\ndeclare module 'gitvan/define' {\n  export function defineJob<T extends JobDef>(def: T): T\n  export function defineConfig<T extends GitVanConfig>(cfg: T): T\n  export function definePlugin<T = any>(p: T): T\n}\n\ndeclare module 'gitvan/composables' {\n  export function useGit(): GitAPI\n  export function useTemplate(opts?: { autoescape?: boolean; paths?: string[] }): TemplateAPI\n  export function useExec(): ExecRunner\n\n  export function useGitVan(): RunContext\n  export function withGitVan<T>(ctx: RunContext, fn: () => T | Promise<T>): T | Promise<T>\n}\n\n// convenience re-exports\ndeclare module 'gitvan' {\n  export * from 'gitvan/define'\n  export * from 'gitvan/composables'\n}\n\n// ---------- Events authoring helper ----------\nexport type EventBinding = { job: string } | { run: ExecSpec }\n\nYou said:\nMissing typescript from dts\nChatGPT said:\nThought for 45s\n\nAdded the missing TypeScript. Drop this in types/index.d.ts and point package.json#types to it.\n\n/// <reference types=\"node\" />\n\n// ---------------- Version ----------------\nexport const version: string\n\n// ---------------- Job core ----------------\nexport type JobKind = 'atomic' | 'pipeline' | 'fanout' | 'gate'\nexport type JobName = string\n\nexport interface RunContext {\n  root: string\n  repoRoot?: string\n  worktreeRoot?: string\n  env?: Record<string, string>\n  now?: () => string\n  payload?: any\n  jobs?: Map<string, JobDef>\n  llm?: { provider?: string; baseURL?: string; modelAllow?: string[]; budgetTokens?: number; seed?: number }\n  worktree?: { id: string; branch?: string }\n}\n\nexport interface JobRunArgs { payload?: any; ctx: RunContext }\nexport interface JobResult { ok: boolean; artifact?: string; stdout?: string; meta?: any }\nexport interface JobDef { kind?: JobKind; meta?: Record<string, any>; run(args: JobRunArgs): Promise<JobResult> | JobResult }\n\n// ---------------- Exec specs ----------------\nexport interface ExecCLI { exec: 'cli'; cmd: string; args?: string[]; env?: Record<string, string | number> }\nexport interface ExecJS { exec: 'js'; module: string; export?: string; input?: any; env?: Record<string, string | number> }\nexport interface ExecTemplate { exec: 'tmpl'; template: string; out?: string; data?: any; autoescape?: boolean; paths?: string[] }\nexport interface ExecLLM { exec: 'llm'; model: string; prompt: string; options?: Record<string, any> }\nexport interface ExecJob { exec: 'job'; name: JobName }\nexport type ExecSpec = ExecCLI | ExecJS | ExecTemplate | ExecLLM | ExecJob\n\nexport interface ExecResult {\n  ok: boolean\n  code?: number\n  stdout?: string\n  stderr?: string\n  artifact?: string\n  meta?: any\n  result?: any\n}\n\n// ---------------- Events (FS routed) ----------------\nexport type EventKind =\n  | 'cron' | 'merge-to' | 'push-to' | 'path-changed'\n  | 'message' | 'author' | 'tag' | 'semver'\n\nexport type EventBinding = { job: JobName } | { run: ExecSpec }\n\nexport interface EventPredicate {\n  kind: EventKind\n  value: string            // e.g. 'main', 'release/*', '^release:', 'src/**', '0_3_*_*_*'\n}\n\nexport interface EventBindingResolved {\n  id: string               // stable from file path\n  predicate: EventPredicate\n  binding: EventBinding\n}\n\n// ---------------- Receipts & locks ----------------\nexport type ReceiptStatus = 'OK' | 'ERROR' | 'SKIP'\nexport type LockRef = `refs/gitvan/locks/${string}/${string}/${string}`\n\nexport interface Receipt {\n  role: 'receipt'\n  id: string               // event id or job name\n  status: ReceiptStatus\n  ts: string\n  commit: string\n  action: 'job' | 'exec'\n  artifact?: string\n  meta?: any\n  error?: string\n  result?: any\n}\n\n// ---------------- Config ----------------\nexport interface GitVanConfig {\n  debug?: boolean\n  rootDir?: string\n  notesRef?: string                    // default: refs/notes/gitvan\n  resultsRef?: string                  // default: refs/notes/gitvan/results\n  locksRoot?: string                   // default: refs/gitvan/locks\n  runsRoot?: string                    // default: refs/gitvan/runs\n  scheduleRoot?: string                // default: refs/gitvan/schedule\n  daemon?: DaemonOptions\n  llm?: { provider?: string; baseURL?: string; modelAllow?: string[]; budgetTokens?: number; seed?: number }\n  scheduled?: Record<string, string | string[]>\n  env?: Record<string, string>\n}\n\nexport interface DaemonOptions {\n  pollMs?: number        // default 1500\n  lookback?: number      // default 600\n  maxPerTick?: number    // default 50\n  tz?: string            // default 'UTC'\n}\n\nexport interface ResolvedConfig extends Required<Pick<\n  GitVanConfig,\n  'notesRef' | 'resultsRef' | 'locksRoot' | 'runsRoot' | 'scheduleRoot'\n>> {\n  rootDir: string\n  daemon: Required<DaemonOptions>\n  debug: boolean\n  env: Record<string, string>\n  llm?: GitVanConfig['llm']\n  scheduled: Record<string, string[]>\n}\n\n// ---------------- Composables ----------------\nexport interface GitAPI {\n  // repo/remote\n  status(): string\n  remoteAdd(name: string, url: string): string\n  fetch(remote?: string, refspec?: string): string\n  pull(remote?: string, branch?: string): string\n  push(remote?: string, ref?: string): string\n\n  // index/workspace\n  add(paths?: string | string[]): string\n  rm(paths: string | string[]): string\n  mv(src: string, dst: string): string\n  checkout(ref: string): string\n  switch(ref: string): string\n\n  // commits/tags\n  commit(msg: string, opts?: { sign?: boolean }): string\n  tag(name: string, msg?: string, opts?: { sign?: boolean }): string\n  describe(): string\n  show(rev?: string): string\n\n  // branches\n  branchCreate(name: string, opts?: { start?: string }): string\n  branchDelete(name: string): string\n  currentBranch(): string\n\n  // integrate\n  merge(ref: string, opts?: { noff?: boolean; msg?: string }): string\n  rebase(onto?: string): string\n  cherryPick(rev: string): string\n  revert(rev: string): string\n  resetHard(ref?: string): string\n  stashSave(msg?: string): string\n  stashApply(index?: number): string\n\n  // history/search\n  log(format?: string, range?: string): string\n  grep(pattern: string, opts?: { pathspec?: string }): string\n\n  // notes/refs\n  noteShow(ref?: string, sha?: string): string\n  noteAdd(ref: string, msg: string, sha?: string): string\n  noteAppend(ref: string, msg: string, sha?: string): string\n  noteCopy(srcRef: string, dstRef: string, sha?: string): string\n  setRef(ref: string, sha: string): string\n  delRef(ref: string): string\n  listRefs(prefix: string): string[]\n  updateRefStdin(input: string): void\n\n  // worktrees\n  listWorktrees(): Array<{ path: string; head?: string; branch?: string; bare?: boolean; isMain?: boolean; gitdir?: string }>\n  worktreeAdd(path: string, opts?: { branch?: string }): string\n  worktreeRemove(path: string): string\n  worktreePrune(): string\n  worktreeId(): string\n\n  // subs\n  submoduleAdd(url: string, path: string): string\n  submoduleUpdate(opts?: { init?: boolean; recursive?: boolean }): string\n\n  // misc\n  head(): string\n  branch(): string\n  nowISO(): string\n  verifyCommit(sha?: string): boolean\n}\n\nimport type { Environment } from 'nunjucks'\nexport interface TemplateAPI {\n  env: Environment\n  render(template: string, data?: any): string\n  renderToFile(template: string, out: string, data?: any): { path: string; bytes: number }\n}\n\nexport type ExecRunner = (spec: ExecSpec) => Promise<ExecResult>\n\n// ---------------- Hooks (hookable) ----------------\nexport interface GitVanHooks {\n  'job:before': (name: JobName, ctx: RunContext) => void | Promise<void>\n  'job:after': (name: JobName, ctx: RunContext, result: JobResult) => void | Promise<void>\n  'event:match': (binding: EventBindingResolved, sha: string) => void | Promise<void>\n  'exec:before': (spec: ExecSpec) => void | Promise<void>\n  'exec:after': (spec: ExecSpec, res: ExecResult) => void | Promise<void>\n  'receipt:write': (receipt: Receipt) => void | Promise<void>\n  'daemon:tick': (stats: { worktree: string; checked: number; ran: number }) => void | Promise<void>\n}\n\nexport interface GitVanPlugin { hooks?: Partial<GitVanHooks> }\n\n// ---------------- Module entry points ----------------\ndeclare module 'gitvan/define' {\n  export function defineJob<T extends JobDef>(def: T): T\n  export function defineConfig<T extends GitVanConfig>(cfg: T): T\n  export function definePlugin<T extends GitVanPlugin>(p: T): T\n}\n\ndeclare module 'gitvan/composables' {\n  export function useGit(): GitAPI\n  export function useTemplate(opts?: { autoescape?: boolean; paths?: string[] }): TemplateAPI\n  export function useExec(): ExecRunner\n\n  export function useGitVan(): RunContext\n  export function withGitVan<T>(ctx: RunContext, fn: () => T | Promise<T>): T | Promise<T>\n}\n\ndeclare module 'gitvan/daemon' {\n  export function startDaemon(select?: 'current' | 'all' | string[], opts?: Partial<DaemonOptions>): Promise<void>\n}\n\ndeclare module 'gitvan/runtime' {\n  export function loadConfig(cwd?: string): Promise<ResolvedConfig>\n  export function listJobs(): Promise<JobName[]>\n  export function runJob(name: JobName, payload?: any): Promise<Receipt>\n  export function listEvents(): Promise<EventBindingResolved[]>\n}\n\n// convenience re-export\ndeclare module 'gitvan' {\n  export * from 'gitvan/define'\n  export * from 'gitvan/composables'\n  export * from 'gitvan/daemon'\n  export * from 'gitvan/runtime'\n}\n\n// UMD-style namespace (optional)\nexport as namespace GitVan\n\n\nCovers the gaps: daemon/options, events & predicates, receipts/locks, resolved config, hooks/plugins, runtime API, Nunjucks Environment, version export, worktree metadata.\n\nYou said:\nProject structure for gitvan (not a project using gitvan)\nChatGPT said:\nThought for 20s\n\nHere’s the repo layout for GitVan itself (library + CLI), ESM, no TS at runtime, ships .d.ts.\n\ngitvan/\n├─ src/\n│  ├─ index.mjs                    # public exports (re-exports define/* + composables)\n│  ├─ define.mjs                   # defineJob, defineConfig, definePlugin\n│  ├─ composables/\n│  │  ├─ ctx.mjs                   # unctx namespace, withGitVan/useGitVan\n│  │  ├─ git.mjs                   # 80/20 git wrappers, worktrees, notes/refs\n│  │  ├─ template.mjs              # Nunjucks env + render/renderToFile\n│  │  └─ exec.mjs                  # exec runner: cli|js|tmpl|llm\n│  ├─ runtime/\n│  │  ├─ config.mjs                # load/resolve gitvan.config.js, defaults\n│  │  ├─ jobs.mjs                  # FS load jobs/, name mapping (dir:name)\n│  │  ├─ events/\n│  │  │  ├─ fs-router.mjs          # unrouting-style parser → predicates\n│  │  │  ├─ cron.mjs               # 0_3_*_*_* ↔ crontab\n│  │  │  └─ match.mjs              # commit meta + predicate eval\n│  │  ├─ locks.mjs                 # refs/gitvan/locks/** acquire/release\n│  │  ├─ receipt.mjs               # write JSON notes to resultsRef\n│  │  ├─ scheduler.mjs             # scheduled map → events\n│  │  └─ daemon.mjs                # per-worktree loop, once-only exec\n│  ├─ cli/\n│  │  ├─ main.mjs                  # noun-verb router\n│  │  └─ commands/\n│  │     ├─ job-list.mjs\n│  │     ├─ job-run.mjs\n│  │     ├─ event-list.mjs\n│  │     ├─ schedule-apply.mjs\n│  │     ├─ daemon-start.mjs\n│  │     └─ worktree-list.mjs\n│  ├─ plugins/\n│  │  └─ allowlist.mjs             # example plugin using hookable\n│  └─ hooks.mjs                    # createHooks, hook names, plugin loader\n├─ types/\n│  └─ index.d.ts                   # full DTS (jobs, exec, events, hooks, daemon, composables)\n├─ bin/\n│  └─ gitvan.mjs                   # shebang → src/cli/main.mjs\n├─ templates/\n│  └─ examples/README.njk          # sample template used by tests/docs\n├─ test/\n│  ├─ daemon.basic.test.mjs\n│  ├─ events.router.test.mjs\n│  ├─ jobs.load.test.mjs\n│  └─ receipts.test.mjs\n├─ package.json\n├─ README.md\n├─ LICENSE\n├─ .editorconfig\n├─ .gitignore\n├─ eslint.config.mjs               # minimal ESM lint\n├─ .prettierrc\n└─ .github/workflows/ci.yml\n\nKey files (stubs)\nsrc/index.mjs\nexport * from './define.mjs'\nexport * from './composables/ctx.mjs'\nexport * from './composables/git.mjs'\nexport * from './composables/template.mjs'\nexport * from './composables/exec.mjs'\n\nsrc/define.mjs\nexport const defineJob = (def) => def\nexport const defineConfig = (cfg) => cfg\nexport const definePlugin = (p) => p\n\nsrc/composables/ctx.mjs\nimport { createContext } from 'unctx'\nconst gvCtx = createContext({ asyncContext: true, AsyncLocalStorage: globalThis.AsyncLocalStorage })\nexport const useGitVan = () => gvCtx.use()\nexport const withGitVan = (ctx, fn) => gvCtx.call(ctx, fn)\n\nsrc/cli/main.mjs\n#!/usr/bin/env node\nimport { jobList } from './commands/job-list.mjs'\nimport { jobRun } from './commands/job-run.mjs'\nimport { eventList } from './commands/event-list.mjs'\nimport { scheduleApply } from './commands/schedule-apply.mjs'\nimport { daemonStart } from './commands/daemon-start.mjs'\nimport { worktreeList } from './commands/worktree-list.mjs'\n\nconst [,, noun, verb, ...rest] = process.argv\nconst args = Object.fromEntries(rest.map(s => s.startsWith('--') ? s.slice(2).split('=') : []))\nconst table = {\n  'job:list': jobList,\n  'job:run': jobRun,\n  'event:list': eventList,\n  'schedule:apply': scheduleApply,\n  'daemon:start': daemonStart,\n  'worktree:list': worktreeList\n}\nconst key = [noun, verb].filter(Boolean).join(':')\nawait (table[key] ? table[key](args) : console.log('usage: gitvan <noun> <verb> [--k=v]'))\n\nbin/gitvan.mjs\n#!/usr/bin/env node\nimport '../src/cli/main.mjs'\n\npackage.json (minimal)\n{\n  \"name\": \"gitvan\",\n  \"version\": \"2.0.0\",\n  \"type\": \"module\",\n  \"bin\": { \"gitvan\": \"bin/gitvan.mjs\" },\n  \"exports\": {\n    \".\": { \"import\": \"./src/index.mjs\", \"types\": \"./types/index.d.ts\" },\n    \"./define\": { \"import\": \"./src/define.mjs\", \"types\": \"./types/index.d.ts\" },\n    \"./composables\": { \"import\": \"./src/composables/ctx.mjs\", \"types\": \"./types/index.d.ts\" },\n    \"./daemon\": { \"import\": \"./src/runtime/daemon.mjs\", \"types\": \"./types/index.d.ts\" },\n    \"./runtime\": { \"import\": \"./src/runtime/config.mjs\", \"types\": \"./types/index.d.ts\" }\n  },\n  \"files\": [\"src\", \"bin\", \"types\", \"templates\", \"README.md\", \"LICENSE\"],\n  \"dependencies\": {\n    \"hookable\": \"^5.5.3\",\n    \"nunjucks\": \"^3.2.4\",\n    \"unctx\": \"^2.3.1\"\n  },\n  \"devDependencies\": {\n    \"vitest\": \"^2.0.0\",\n    \"eslint\": \"^9.0.0\",\n    \"prettier\": \"^3.3.0\"\n  },\n  \"scripts\": {\n    \"dev\": \"vitest -u --watch=false\",\n    \"test\": \"vitest run\",\n    \"lint\": \"eslint .\",\n    \"types\": \"echo types only\",\n    \"release\": \"npm publish --access public\"\n  }\n}\n\nNotes\n\nNo runtime TS. .d.ts lives in types/.\n\nCLI noun-verb. gitvan <noun> <verb>.\n\nHookable/unctx baked in.\n\nUnrouting-like FS router sits in src/runtime/events/fs-router.mjs.\n\nWorktrees/locks/receipts in runtime/*.\n\nTemplates default to Nunjucks via composables/template.mjs."
        }
    ]
}