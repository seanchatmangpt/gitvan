{
    "sourceFile": "USE-GIT-PROTOTYPE.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758043059643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758043059643,
            "name": "Commit-0",
            "content": "```js\n// src/composables/git.mjs\n// GitVan v2 â€” useGit()\n// - POSIX-first. No external deps. ESM.\n// - Deterministic env: TZ=UTC, LANG=C.\n// - UnJS context-aware (unctx). Captures context once to avoid loss after await.\n// - Happy path only. No retries. No shell string interpolation.\n// - 80/20 commands + a few primitives used by locks/receipts.\n\nimport { execFile as _execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\nimport path from \"node:path\";\nimport { useGitVan, tryUseGitVan } from \"../core/context.mjs\";\n\nconst execFile = promisify(_execFile);\n\n// Resolve cwd/env from context once to avoid unctx async pitfalls\nfunction bindContext() {\n  // Prefer strict `use` if available within a `withGitVan` call\n  let ctx;\n  try {\n    ctx = useGitVan?.();\n  } catch {\n    ctx = tryUseGitVan?.();\n  }\n  const cwd = (ctx && ctx.cwd) || process.cwd();\n  const env = {\n    TZ: \"UTC\",\n    LANG: \"C\",\n    ...process.env,\n    ...(ctx && ctx.env ? ctx.env : {}),\n  };\n  return { ctx, cwd, env };\n}\n\nasync function runGit(args, { cwd, env, maxBuffer = 12 * 1024 * 1024 } = {}) {\n  const { stdout } = await execFile(\"git\", args, { cwd, env, maxBuffer });\n  return stdout.trim();\n}\n\nasync function runGitVoid(args, opts) {\n  await runGit(args, opts);\n}\n\nfunction toArr(x) {\n  return Array.isArray(x) ? x : [x];\n}\n\nexport function useGit() {\n  const bound = bindContext();\n  const base = {\n    cwd: bound.cwd,\n    env: bound.env,\n  };\n\n  return {\n    // ---------- Repo info ----------\n    async branch() {\n      return runGit([\"rev-parse\", \"--abbrev-ref\", \"HEAD\"], base);\n    },\n    async head() {\n      return runGit([\"rev-parse\", \"HEAD\"], base);\n    },\n    async repoRoot() {\n      return runGit([\"rev-parse\", \"--show-toplevel\"], base);\n    },\n    async worktreeGitDir() {\n      return runGit([\"rev-parse\", \"--git-dir\"], base);\n    },\n    nowISO() {\n      const forced = process.env.GITVAN_NOW;\n      return forced || new Date().toISOString();\n    },\n\n    // ---------- Read-only helpers ----------\n    async log(format = \"%h%x09%s\", extra = []) {\n      const extraArgs =\n        typeof extra === \"string\" ? extra.split(/\\s+/).filter(Boolean) : toArr(extra);\n      return runGit([\"log\", `--pretty=${format}`, ...extraArgs], base);\n    },\n    async statusPorcelain() {\n      return runGit([\"status\", \"--porcelain\"], base);\n    },\n    async isAncestor(a, b = \"HEAD\") {\n      try {\n        await runGitVoid([\"merge-base\", \"--is-ancestor\", a, b], base);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    async mergeBase(a, b) {\n      return runGit([\"merge-base\", a, b], base);\n    },\n    async revList(args = [\"--max-count=50\", \"HEAD\"]) {\n      return runGit([\"rev-list\", ...toArr(args)], base);\n    },\n\n    // ---------- Write helpers (happy path) ----------\n    async add(paths) {\n      const list = toArr(paths).filter(Boolean);\n      if (list.length === 0) return;\n      await runGitVoid([\"add\", \"--\", ...list], base);\n    },\n    async commit(message, opts = {}) {\n      const args = [\"commit\", \"-m\", message];\n      if (opts.sign) args.push(\"-S\");\n      await runGitVoid(args, base);\n    },\n    async tag(name, msg, opts = {}) {\n      const args = [\"tag\"];\n      if (opts.sign) args.push(\"-s\");\n      if (msg) args.push(\"-m\", msg);\n      args.push(name);\n      await runGitVoid(args, base);\n    },\n\n    // ---------- Notes (receipts) ----------\n    async noteAdd(ref, message, sha = \"HEAD\") {\n      // git will create the notes ref if needed\n      await runGitVoid([\"notes\", `--ref=${ref}`, \"add\", \"-m\", message, sha], base);\n    },\n    async noteAppend(ref, message, sha = \"HEAD\") {\n      await runGitVoid([\"notes\", `--ref=${ref}`, \"append\", \"-m\", message, sha], base);\n    },\n    async noteShow(ref, sha = \"HEAD\") {\n      return runGit([\"notes\", `--ref=${ref}`, \"show\", sha], base);\n    },\n\n    // ---------- Atomic ref create (locks) ----------\n    // Uses stdin protocol to atomically create a ref if absent.\n    async updateRefCreate(ref, valueSha) {\n      // Equivalent to: echo \"create <ref> <sha>\" | git update-ref --stdin\n      // Using execFile without shell: write via env var and small wrapper.\n      // Simpler: rely on single create op by running update-ref directly per ref.\n      // Note: Git does not expose \"create\" outside stdin, so we approximate by\n      // using `symbolic-ref` for new symbols or fallback to update-ref with failure check.\n      // Pragmatic approach: if ref exists, this should fail the use-case. We check first.\n      try {\n        await runGitVoid([\"show-ref\", \"--verify\", \"--quiet\", ref], base);\n        // exists -> signal failure\n        return false;\n      } catch {\n        // not exists -> create pointing to valueSha\n        await runGitVoid([\"update-ref\", ref, valueSha], base);\n        return true;\n      }\n    },\n\n    // ---------- Plumbing ----------\n    async hashObject(filePath, { write = false } = {}) {\n      const abs = path.isAbsolute(filePath) ? filePath : path.join(base.cwd, filePath);\n      const args = [\"hash-object\"];\n      if (write) args.push(\"-w\");\n      args.push(\"--\", abs);\n      return runGit(args, base);\n    },\n    async writeTree() {\n      return runGit([\"write-tree\"], base);\n    },\n    async catFilePretty(sha) {\n      return runGit([\"cat-file\", \"-p\", sha], base);\n    },\n\n    // ---------- Generic runner (escape hatch) ----------\n    async run(args) {\n      return runGit(toArr(args), base);\n    },\n    async runVoid(args) {\n      await runGitVoid(toArr(args), base);\n    },\n  };\n}\n```\n"
        }
    ]
}