// tests/jtbd-meaningful-work-validation.test.mjs
// Integration tests that validate meaningful work outcomes
// These tests verify that workflows produce real business value

import { describe, it, expect } from "vitest";
import { withMemFSTestEnvironment } from "../src/composables/test-environment.mjs";
import { StepRunner } from "../src/workflow/StepRunner.mjs";
import { ContextManager } from "../src/workflow/ContextManager.mjs";
import { readFile } from "node:fs/promises";

describe("JTBD Turtle Workflow - Meaningful Work Validation", () => {
  describe("Business Intelligence: Executive Dashboard Generation", () => {
    it("should generate a complete executive dashboard with actionable insights", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "data/sales-q1.json": `{
              "quarter": "Q1 2024",
              "sales": [
                {"product": "Enterprise License", "revenue": 125000, "units": 25, "region": "North America"},
                {"product": "SaaS Subscription", "revenue": 89000, "units": 445, "region": "Europe"},
                {"product": "Professional Services", "revenue": 156000, "units": 12, "region": "Asia Pacific"},
                {"product": "Enterprise License", "revenue": 98000, "units": 19, "region": "Europe"},
                {"product": "SaaS Subscription", "revenue": 67000, "units": 335, "region": "North America"}
              ],
              "targets": {"revenue": 500000, "units": 800}
            }`,
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "executive-dashboard",
            inputs: { dataFile: "./data/sales-q1.json" },
            startTime: Date.now(),
          });

          // Step 1: Process sales data
          const dataStep = {
            id: "process-data",
            type: "file",
            config: {
              filePath: "./data/sales-q1.json",
              operation: "read"
            }
          };

          const dataResult = await stepRunner.executeStep(dataStep, contextManager, null, null);
          expect(dataResult.success).toBe(true);
          
          const rawData = JSON.parse(dataResult.outputs.content);
          const sales = rawData.sales;
          const targets = rawData.targets;

          // Calculate business metrics
          const totalRevenue = sales.reduce((sum, s) => sum + s.revenue, 0);
          const totalUnits = sales.reduce((sum, s) => sum + s.units, 0);
          const revenueAchievement = (totalRevenue / targets.revenue) * 100;
          const unitsAchievement = (totalUnits / targets.units) * 100;

          // Step 2: Generate executive dashboard
          const dashboardStep = {
            id: "generate-dashboard",
            type: "template",
            config: {
              template: `# {{ quarter }} Executive Dashboard

**Generated**: {{ "now" | date("YYYY-MM-DD HH:mm:ss") }}

## Key Performance Indicators

| Metric | Actual | Target | Achievement | Status |
|--------|--------|--------|-------------|--------|
| **Revenue** | ${{ totalRevenue | int }} | ${{ targets.revenue | int }} | {{ revenueAchievement | round(1) }}% | {% if revenueAchievement >= 100 %}✅{% else %}❌{% endif %} |
| **Units Sold** | {{ totalUnits }} | {{ targets.units }} | {{ unitsAchievement | round(1) }}% | {% if unitsAchievement >= 100 %}✅{% else %}❌{% endif %} |

## Product Performance

{% for product in sales | groupby('product') %}
### {{ product.key }}
- **Revenue**: ${{ product.list | sum(attribute='revenue') | int }}
- **Units**: {{ product.list | sum(attribute='units') }}
- **Regions**: {{ product.list | map(attribute='region') | unique | join(', ') }}
{% endfor %}

## Regional Analysis

{% for region in sales | groupby('region') %}
### {{ region.key }}
- **Revenue**: ${{ region.list | sum(attribute='revenue') | int }}
- **Units**: {{ region.list | sum(attribute='units') }}
{% endfor %}

## Executive Summary

{% if revenueAchievement >= 100 %}
✅ **Revenue target achieved** - Strong performance across all products
{% else %}
❌ **Revenue target missed** - Focus needed on high-revenue products
{% endif %}

{% if unitsAchievement >= 100 %}
✅ **Units target achieved** - Good market penetration
{% else %}
❌ **Units target missed** - Consider pricing or marketing adjustments
{% endif %}

---
*Generated by GitVan Business Intelligence Workflow*`,
              filePath: "./reports/{{ quarter | slug }}-dashboard.md"
            }
          };

          // Set calculated metrics
          contextManager.setOutput("quarter", rawData.quarter);
          contextManager.setOutput("sales", sales);
          contextManager.setOutput("targets", targets);
          contextManager.setOutput("totalRevenue", totalRevenue);
          contextManager.setOutput("totalUnits", totalUnits);
          contextManager.setOutput("revenueAchievement", revenueAchievement);
          contextManager.setOutput("unitsAchievement", unitsAchievement);

          const dashboardResult = await stepRunner.executeStep(dashboardStep, contextManager, null, null);
          expect(dashboardResult.success).toBe(true);

          // Step 3: Generate actionable JSON data
          const jsonStep = {
            id: "generate-json-data",
            type: "file",
            config: {
              filePath: "./data/dashboard-summary.json",
              operation: "write",
              content: `{
                "quarter": "{{ quarter }}",
                "generated": "{{ 'now' | date('YYYY-MM-DDTHH:mm:ssZ') }}",
                "kpis": {
                  "revenue": {
                    "actual": {{ totalRevenue }},
                    "target": {{ targets.revenue }},
                    "achievement": {{ revenueAchievement | round(2) }},
                    "status": "{% if revenueAchievement >= 100 %}achieved{% else %}missed{% endif %}"
                  },
                  "units": {
                    "actual": {{ totalUnits }},
                    "target": {{ targets.units }},
                    "achievement": {{ unitsAchievement | round(2) }},
                    "status": "{% if unitsAchievement >= 100 %}achieved{% else %}missed{% endif %}"
                  }
                },
                "topProduct": {
                  "name": "{{ sales | max(attribute='revenue') | attr('product') }}",
                  "revenue": {{ sales | max(attribute='revenue') | attr('revenue') }}
                },
                "topRegion": {
                  "name": "{{ sales | groupby('region') | map('list') | map('sum', 'revenue') | max | attr('region') }}",
                  "revenue": {{ sales | groupby('region') | map('list') | map('sum', 'revenue') | max }}
                }
              }`
            }
          };

          const jsonResult = await stepRunner.executeStep(jsonStep, contextManager, null, null);
          expect(jsonResult.success).toBe(true);

          // VALIDATE MEANINGFUL RESULTS
          const dashboardContent = await readFile("./reports/q1-2024-dashboard.md", "utf8");
          const summaryData = JSON.parse(await readFile("./data/dashboard-summary.json", "utf8"));

          // Validate executive dashboard contains actionable insights
          expect(dashboardContent).toContain("Q1 2024 Executive Dashboard");
          expect(dashboardContent).toContain("Key Performance Indicators");
          expect(dashboardContent).toContain("$535000"); // Total revenue
          expect(dashboardContent).toContain("836"); // Total units
          expect(dashboardContent).toContain("107.0%"); // Revenue achievement
          expect(dashboardContent).toContain("104.5%"); // Units achievement
          expect(dashboardContent).toContain("✅"); // Achieved targets
          expect(dashboardContent).toContain("Executive Summary");
          expect(dashboardContent).toContain("Revenue target achieved");

          // Validate product performance analysis
          expect(dashboardContent).toContain("Product Performance");
          expect(dashboardContent).toContain("Enterprise License");
          expect(dashboardContent).toContain("SaaS Subscription");
          expect(dashboardContent).toContain("Professional Services");

          // Validate regional analysis
          expect(dashboardContent).toContain("Regional Analysis");
          expect(dashboardContent).toContain("North America");
          expect(dashboardContent).toContain("Europe");
          expect(dashboardContent).toContain("Asia Pacific");

          // Validate JSON data is structured for downstream systems
          expect(summaryData.kpis.revenue.actual).toBe(535000);
          expect(summaryData.kpis.revenue.achievement).toBeGreaterThan(100);
          expect(summaryData.kpis.revenue.status).toBe("achieved");
          expect(summaryData.kpis.units.actual).toBe(836);
          expect(summaryData.kpis.units.achievement).toBeGreaterThan(100);
          expect(summaryData.kpis.units.status).toBe("achieved");
          expect(summaryData.topProduct.name).toBe("Professional Services");
          expect(summaryData.topProduct.revenue).toBe(156000);

          console.log("✅ Generated executive dashboard with actionable business insights");
          console.log(`   Revenue: $${summaryData.kpis.revenue.actual} (${summaryData.kpis.revenue.achievement}% of target)`);
          console.log(`   Units: ${summaryData.kpis.units.actual} (${summaryData.kpis.units.achievement}% of target)`);
          console.log(`   Top Product: ${summaryData.topProduct.name} ($${summaryData.topProduct.revenue})`);
        }
      );
    });
  });

  describe("Software Development: Automated Code Generation", () => {
    it("should generate production-ready TypeScript code from API specifications", async () => {
      await withMemFSTestEnvironment(
        {
          initialFiles: {
            "specs/user-api.json": `{
              "service": "User Management API",
              "version": "2.1.0",
              "endpoints": [
                {
                  "path": "/api/users",
                  "method": "GET",
                  "description": "List all users",
                  "response": "User[]"
                },
                {
                  "path": "/api/users/{id}",
                  "method": "GET",
                  "description": "Get user by ID",
                  "response": "User"
                },
                {
                  "path": "/api/users",
                  "method": "POST",
                  "description": "Create new user",
                  "body": "UserInput",
                  "response": "User"
                }
              ],
              "models": {
                "User": {
                  "id": "string",
                  "email": "string",
                  "name": "string",
                  "role": "string"
                },
                "UserInput": {
                  "email": "string",
                  "name": "string",
                  "role": "string"
                }
              }
            }`,
          },
        },
        async (env) => {
          const stepRunner = new StepRunner();
          const contextManager = new ContextManager();
          await contextManager.initialize({
            workflowId: "code-generation",
            inputs: { specFile: "./specs/user-api.json" },
            startTime: Date.now(),
          });

          // Step 1: Read API specification
          const specStep = {
            id: "read-spec",
            type: "file",
            config: {
              filePath: "./specs/user-api.json",
              operation: "read"
            }
          };

          const specResult = await stepRunner.executeStep(specStep, contextManager, null, null);
          expect(specResult.success).toBe(true);
          
          const apiSpec = JSON.parse(specResult.outputs.content);
          contextManager.setOutput("apiSpec", apiSpec);

          // Step 2: Generate TypeScript interfaces
          const typesStep = {
            id: "generate-types",
            type: "template",
            config: {
              template: `// Generated TypeScript interfaces for {{ apiSpec.service }} v{{ apiSpec.version }}

export interface User {
  id: string;
  email: string;
  name: string;
  role: string;
}

export interface UserInput {
  email: string;
  name: string;
  role: string;
}

export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

// Endpoint types
{% for endpoint in apiSpec.endpoints %}
export interface {{ endpoint.path | replace('/', '') | replace('{', '') | replace('}', '') | title }}Request {
  {% if endpoint.method == 'GET' and endpoint.path.includes('{id}') %}
  id: string;
  {% elif endpoint.method == 'POST' %}
  body: UserInput;
  {% endif %}
}

export interface {{ endpoint.path | replace('/', '') | replace('{', '') | replace('}', '') | title }}Response {
  data: {{ endpoint.response }};
}
{% endfor %}`,
              filePath: "./src/types/{{ apiSpec.service | slug }}.ts"
            }
          };

          const typesResult = await stepRunner.executeStep(typesStep, contextManager, null, null);
          expect(typesResult.success).toBe(true);

          // Step 3: Generate API service
          const serviceStep = {
            id: "generate-service",
            type: "template",
            config: {
              template: `// Generated API service for {{ apiSpec.service }} v{{ apiSpec.version }}

import { User, UserInput, ApiResponse } from '../types/{{ apiSpec.service | slug }}';

export class {{ apiSpec.service | replace(' ', '') }}Service {
  private baseUrl: string;
  private apiKey: string;

  constructor(baseUrl: string, apiKey: string) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }

  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<ApiResponse<T>> {
    const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, {
      ...options,
      headers: {
        'Authorization': \`Bearer \${this.apiKey}\`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      throw new Error(\`API request failed: \${response.statusText}\`);
    }

    return await response.json();
  }

{% for endpoint in apiSpec.endpoints %}
  /**
   * {{ endpoint.description }}
   */
  async {{ endpoint.path | replace('/', '') | replace('{', '') | replace('}', '') | slug }}(
    {% if endpoint.method == 'GET' and endpoint.path.includes('{id}') %}
    id: string
    {% elif endpoint.method == 'POST' %}
    userData: UserInput
    {% endif %}
  ): Promise<{{ endpoint.path | replace('/', '') | replace('{', '') | replace('}', '') | title }}Response> {
    {% if endpoint.method == 'GET' %}
    return this.request<{{ endpoint.response }}>('{{ endpoint.path }}'{% if endpoint.path.includes('{id}') %}.replace('{id}', id){% endif %});
    {% elif endpoint.method == 'POST' %}
    return this.request<{{ endpoint.response }}>('{{ endpoint.path }}', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
    {% endif %}
  }
{% endfor %}
}`,
              filePath: "./src/services/{{ apiSpec.service | slug }}.ts"
            }
          };

          const serviceResult = await stepRunner.executeStep(serviceStep, contextManager, null, null);
          expect(serviceResult.success).toBe(true);

          // VALIDATE MEANINGFUL RESULTS - Production-ready code
          const typesContent = await readFile("./src/types/user-management-api.ts", "utf8");
          const serviceContent = await readFile("./src/services/user-management-api.ts", "utf8");

          // Validate TypeScript interfaces
          expect(typesContent).toContain("export interface User {");
          expect(typesContent).toContain("id: string;");
          expect(typesContent).toContain("email: string;");
          expect(typesContent).toContain("name: string;");
          expect(typesContent).toContain("role: string;");
          expect(typesContent).toContain("export interface UserInput {");
          expect(typesContent).toContain("export interface ApiResponse<T> {");

          // Validate service class
          expect(serviceContent).toContain("export class UserManagementAPIService {");
          expect(serviceContent).toContain("constructor(baseUrl: string, apiKey: string)");
          expect(serviceContent).toContain("private async request<T>");
          expect(serviceContent).toContain("Authorization");
          expect(serviceContent).toContain("Bearer");
          expect(serviceContent).toContain("async users(");
          expect(serviceContent).toContain("async usersId(");
          expect(serviceContent).toContain("async usersPost(");

          console.log("✅ Generated production-ready TypeScript code");
          console.log(`   Service: ${apiSpec.service} v${apiSpec.version}`);
          console.log(`   Endpoints: ${apiSpec.endpoints.length}`);
          console.log(`   Files: types, service`);
        }
      );
    });
  });
});
