{
    "sourceFile": "tests/jobs-comprehensive.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758048492138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758048492138,
            "name": "Commit-0",
            "content": "// tests/jobs-comprehensive.test.mjs\n// GitVan v2 â€” Comprehensive Job System Tests\n// Tests job discovery, definition, execution, and CLI\n\nimport { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"pathe\";\nimport {\n  scanJobs,\n  getJobById,\n  validateJobs,\n  getJobStats,\n} from \"../src/jobs/scan.mjs\";\nimport { defineJob, createJobDefinition } from \"../src/jobs/define.mjs\";\nimport { JobRunner, JobResult } from \"../src/jobs/runner.mjs\";\nimport { jobCLI } from \"../src/cli/job.mjs\";\n\ndescribe(\"GitVan Job System - Comprehensive Tests\", () => {\n  let tempDir;\n  let jobsDir;\n\n  beforeEach(async () => {\n    // Create temporary directory for testing\n    tempDir = join(process.cwd(), \"test-jobs-temp\");\n    jobsDir = join(tempDir, \"jobs\");\n    await fs.mkdir(jobsDir, { recursive: true });\n  });\n\n  afterEach(async () => {\n    // Clean up temporary directory\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  });\n\n  describe(\"job definition system\", () => {\n    it(\"should create valid job definition\", () => {\n      const jobDef = defineJob({\n        id: \"test:job\",\n        meta: { desc: \"Test job\" },\n        async run({ payload, ctx }) {\n          return { ok: true };\n        },\n      });\n\n      expect(jobDef.id).toBe(\"test:job\");\n      expect(jobDef.kind).toBe(\"atomic\");\n      expect(jobDef.meta.desc).toBe(\"Test job\");\n      expect(typeof jobDef.run).toBe(\"function\");\n    });\n\n    it(\"should infer job properties from file path\", () => {\n      const jobDef = createJobDefinition(\n        {\n          async run({ payload, ctx }) {\n            return { ok: true };\n          },\n        },\n        \"jobs/db/migrate.mjs\",\n      );\n\n      expect(jobDef.id).toBe(\"db:migrate\");\n      expect(jobDef.mode).toBe(\"on-demand\");\n      expect(jobDef.filename).toBe(\"migrate.mjs\");\n    });\n\n    it(\"should infer cron mode from filename\", () => {\n      const jobDef = createJobDefinition(\n        {\n          async run({ payload, ctx }) {\n            return { ok: true };\n          },\n        },\n        \"jobs/cleanup.cron.mjs\",\n      );\n\n      expect(jobDef.id).toBe(\"cleanup\");\n      expect(jobDef.mode).toBe(\"cron\");\n    });\n\n    it(\"should validate job definition\", () => {\n      expect(() => {\n        defineJob({\n          // Missing run function\n          meta: { desc: \"Invalid job\" },\n        });\n      }).toThrow(\"Job definition validation failed\");\n    });\n\n    it(\"should validate event predicates\", () => {\n      expect(() => {\n        defineJob({\n          async run({ payload, ctx }) {\n            return { ok: true };\n          },\n          on: {\n            invalidPredicate: \"test\",\n          },\n        });\n      }).toThrow(\"Job definition validation failed\");\n    });\n  });\n\n  describe(\"job discovery\", () => {\n    beforeEach(async () => {\n      // Create test job files\n      await fs.writeFile(\n        join(jobsDir, \"test.mjs\"),\n        `import { defineJob } from \"../../src/jobs/define.mjs\";\n\nexport default defineJob({\n  meta: { desc: \"Test job\" },\n  async run({ payload, ctx }) {\n    return { ok: true };\n  }\n});`,\n      );\n\n      await fs.writeFile(\n        join(jobsDir, \"cleanup.cron.mjs\"),\n        `import { defineJob } from \"../../src/jobs/define.mjs\";\n\nexport default defineJob({\n  cron: \"0 2 * * *\",\n  meta: { desc: \"Cleanup job\" },\n  async run({ payload, ctx }) {\n    return { ok: true };\n  }\n});`,\n      );\n\n      await fs.writeFile(\n        join(jobsDir, \"notify.evt.mjs\"),\n        `import { defineJob } from \"../../src/jobs/define.mjs\";\n\nexport default defineJob({\n  on: { tagCreate: \"v*.*.*\" },\n  meta: { desc: \"Notification job\" },\n  async run({ payload, ctx }) {\n    return { ok: true };\n  }\n});`,\n      );\n    });\n\n    it(\"should discover job files\", async () => {\n      const jobs = await scanJobs({ cwd: tempDir });\n\n      console.log(\n        \"Discovered jobs:\",\n        jobs.map((j) => j.id),\n      );\n      console.log(\"Expected jobs: test, cleanup, notify\");\n\n      expect(jobs).toHaveLength(3);\n      expect(jobs.find((job) => job.id === \"test\")).toBeDefined();\n      expect(jobs.find((job) => job.id === \"cleanup\")).toBeDefined();\n      expect(jobs.find((job) => job.id === \"notify\")).toBeDefined();\n    });\n\n    it(\"should get job by ID\", async () => {\n      const job = await getJobById(\"test\", { cwd: tempDir });\n\n      expect(job).toBeDefined();\n      expect(job.id).toBe(\"test\");\n      expect(job.mode).toBe(\"on-demand\");\n    });\n\n    it(\"should validate discovered jobs\", async () => {\n      const jobs = await scanJobs({ cwd: tempDir });\n      const validation = validateJobs(jobs);\n\n      expect(validation.valid).toBe(true);\n      expect(validation.errors).toHaveLength(0);\n      expect(validation.count).toBe(3);\n    });\n\n    it(\"should provide job statistics\", async () => {\n      const jobs = await scanJobs({ cwd: tempDir });\n      const stats = getJobStats(jobs);\n\n      expect(stats.total).toBe(3);\n      expect(stats.byMode[\"on-demand\"]).toBe(1);\n      expect(stats.byMode.cron).toBe(1);\n      expect(stats.byMode.event).toBe(1);\n    });\n  });\n\n  describe(\"job execution\", () => {\n    let runner;\n\n    beforeEach(async () => {\n      // Initialize git repository\n      await fs.writeFile(join(tempDir, \"README.md\"), \"# Test Repository\\n\");\n\n      // Mock git operations for testing\n      runner = new JobRunner({\n        receiptsRef: \"refs/notes/gitvan/test\",\n        locksRef: \"refs/gitvan/test-locks\",\n        executionsRef: \"refs/gitvan/test-executions\",\n      });\n    });\n\n    it(\"should execute job successfully\", async () => {\n      const jobDef = defineJob({\n        id: \"test:execution\",\n        async run({ payload, ctx }) {\n          return { ok: true, artifacts: [\"test.txt\"] };\n        },\n      });\n\n      // Mock the git operations\n      const mockGit = {\n        head: () => Promise.resolve(\"abc123\"),\n        getCurrentBranch: () => Promise.resolve(\"main\"),\n        updateRefCreate: () => Promise.resolve(true),\n        runVoid: () => Promise.resolve(),\n        noteAdd: () => Promise.resolve(),\n        logger: console,\n      };\n\n      // Replace git operations in runner\n      runner.git = mockGit;\n\n      const result = await runner.runJob(jobDef, {\n        payload: { test: \"data\" },\n      });\n\n      expect(result.ok).toBe(true);\n      expect(result.id).toBe(\"test:execution\");\n      expect(result.artifacts).toEqual([\"test.txt\"]);\n    });\n\n    it(\"should handle job execution errors\", async () => {\n      const jobDef = defineJob({\n        id: \"test:error\",\n        async run({ payload, ctx }) {\n          throw new Error(\"Test error\");\n        },\n      });\n\n      const mockGit = {\n        head: () => Promise.resolve(\"abc123\"),\n        getCurrentBranch: () => Promise.resolve(\"main\"),\n        updateRefCreate: () => Promise.resolve(true),\n        runVoid: () => Promise.resolve(),\n        noteAdd: () => Promise.resolve(),\n        logger: console,\n      };\n\n      runner.git = mockGit;\n\n      await expect(runner.runJob(jobDef)).rejects.toThrow(\"Test error\");\n    });\n\n    it(\"should generate unique fingerprints\", async () => {\n      const jobDef = defineJob({\n        id: \"test:fingerprint\",\n        async run({ payload, ctx }) {\n          return { ok: true };\n        },\n      });\n\n      const mockGit = {\n        head: () => Promise.resolve(\"abc123\"),\n        getCurrentBranch: () => Promise.resolve(\"main\"),\n        updateRefCreate: () => Promise.resolve(true),\n        runVoid: () => Promise.resolve(),\n        noteAdd: () => Promise.resolve(),\n        logger: console,\n      };\n\n      runner.git = mockGit;\n\n      const fingerprint1 = runner.generateFingerprint(\n        jobDef,\n        \"abc123\",\n        {},\n        null,\n      );\n      const fingerprint2 = runner.generateFingerprint(\n        jobDef,\n        \"def456\",\n        {},\n        null,\n      );\n      const fingerprint3 = runner.generateFingerprint(\n        jobDef,\n        \"abc123\",\n        { test: \"data\" },\n        null,\n      );\n\n      expect(fingerprint1).not.toBe(fingerprint2);\n      expect(fingerprint1).not.toBe(fingerprint3);\n      expect(fingerprint2).not.toBe(fingerprint3);\n    });\n  });\n\n  describe(\"job CLI\", () => {\n    beforeEach(async () => {\n      // Create test job files\n      await fs.writeFile(\n        join(jobsDir, \"cli-test.mjs\"),\n        `export default {\n          meta: { desc: \"CLI test job\" },\n          async run({ payload, ctx }) {\n            return { ok: true, artifacts: [\"cli-test.txt\"] };\n          }\n        }`,\n      );\n    });\n\n    it(\"should list jobs\", async () => {\n      // Mock the CLI to avoid file system issues\n      const result = await jobCLI(\"list\", { format: \"json\" });\n      expect(result).toBeDefined();\n    });\n\n    it(\"should show job details\", async () => {\n      // This would require mocking the git operations\n      // For now, just test that the command exists\n      expect(typeof jobCLI).toBe(\"function\");\n    });\n  });\n\n  describe(\"job result\", () => {\n    it(\"should create job result\", () => {\n      const result = new JobResult({\n        id: \"test:result\",\n        fingerprint: \"abc123\",\n        startedAt: \"2024-01-01T00:00:00Z\",\n        finishedAt: \"2024-01-01T00:01:00Z\",\n        head: \"def456\",\n        ok: true,\n        artifacts: [\"test.txt\"],\n        duration: 60000,\n      });\n\n      expect(result.id).toBe(\"test:result\");\n      expect(result.ok).toBe(true);\n      expect(result.artifacts).toEqual([\"test.txt\"]);\n      expect(result.duration).toBe(60000);\n    });\n\n    it(\"should serialize to JSON\", () => {\n      const result = new JobResult({\n        id: \"test:serialize\",\n        fingerprint: \"abc123\",\n        startedAt: \"2024-01-01T00:00:00Z\",\n        finishedAt: \"2024-01-01T00:01:00Z\",\n        head: \"def456\",\n        ok: true,\n        artifacts: [\"test.txt\"],\n        duration: 60000,\n      });\n\n      const json = result.toJSON();\n      expect(json.id).toBe(\"test:serialize\");\n      expect(json.ok).toBe(true);\n      expect(json.artifacts).toEqual([\"test.txt\"]);\n    });\n  });\n});\n"
        }
    ]
}